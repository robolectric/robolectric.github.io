{
  "methods": {
    "addGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "addGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "addNmeaListener(android.location.OnNmeaMessageListener,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "addNmeaListener(android.location.OnNmeaMessageListener,android.os.Handler)"
    },
    "addNmeaListener(java.util.concurrent.Executor,android.location.OnNmeaMessageListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "addNmeaListener(java.util.concurrent.Executor,android.location.OnNmeaMessageListener)"
    },
    "distanceBetween(android.location.Location,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "static"
      ],
      "params": [
        "location1",
        "location2"
      ],
      "returnType": "float",
      "exceptions": [],
      "name": "distanceBetween(android.location.Location,android.location.Location)",
      "documentation": "Returns the distance between the two locations in meters. Adapted from:\nhttp://stackoverflow.com/questions/837872/calculate-distance-in-meters-when-you-know-longitude-and-latitude-in-java\n"
    },
    "flushGnssBatch()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 26,
      "name": "flushGnssBatch()"
    },
    "getAllProviders()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getAllProviders()"
    },
    "getBestProvider(android.location.Criteria,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getBestProvider(android.location.Criteria,boolean)"
    },
    "getContext()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "android.content.Context",
      "exceptions": [],
      "name": "getContext()"
    },
    "getCurrentLocation(java.lang.String,android.location.LocationRequest,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "request",
        "cancellationSignal",
        "executor",
        "consumer"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "getCurrentLocation(java.lang.String,android.location.LocationRequest,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)"
    },
    "getCurrentLocation(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "cancellationSignal",
        "executor",
        "consumer"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "getCurrentLocation(java.lang.String,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)"
    },
    "getCurrentLocationInternal(java.lang.String,android.location.LocationRequest,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "request",
        "cancellationSignal",
        "executor",
        "consumer"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "getCurrentLocationInternal(java.lang.String,android.location.LocationRequest,android.os.CancellationSignal,java.util.concurrent.Executor,java.util.function.Consumer\u003candroid.location.Location\u003e)"
    },
    "getGnssBatchSize()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "minSdk": 26,
      "name": "getGnssBatchSize()"
    },
    "getGnssHardwareModelName()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "minSdk": 28,
      "name": "getGnssHardwareModelName()"
    },
    "getGnssYearOfHardware()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "minSdk": 28,
      "name": "getGnssYearOfHardware()"
    },
    "getGpsStatusListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.GpsStatus.Listener\u003e",
      "exceptions": [],
      "name": "getGpsStatusListeners()",
      "documentation": "Returns the list of currently registered {@link GpsStatus.Listener}s. "
    },
    "getLastKnownLocation(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider"
      ],
      "returnType": "android.location.Location",
      "exceptions": [],
      "name": "getLastKnownLocation(java.lang.String)"
    },
    "getLegacyLocationRequests(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003corg.robolectric.shadows.ShadowLocationManager.RoboLocationRequest\u003e",
      "exceptions": [],
      "name": "getLegacyLocationRequests(java.lang.String)",
      "documentation": "Returns the list of {@link RoboLocationRequest} currently registered under the given provider.\nSince {@link LocationRequest} was not publicly visible prior to S, and did not exist prior to\nKitkat, {@link RoboLocationRequest} allows querying the location requests prior to those\nplatforms, and also implements proper equality comparisons for testing.\n"
    },
    "getLocationMode()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getLocationMode()"
    },
    "getLocationRequests(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003candroid.location.LocationRequest\u003e",
      "exceptions": [],
      "name": "getLocationRequests(java.lang.String)",
      "documentation": "Returns the list of {@link LocationRequest} currently registered under the given provider.\nClients compiled against the public Android SDK should only use this method on S+, clients\ncompiled against the system Android SDK may only use this method on Kitkat+.\n\n\u003cp\u003ePrior to Android S {@link LocationRequest} equality is not well defined, so prefer using\n{@link #getLegacyLocationRequests(String)} instead if equality is required for testing.\n"
    },
    "getLocationUpdateListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getLocationUpdateListeners()",
      "documentation": "@deprecated Do not test listeners, instead use {@link #simulateLocation(Location)} and test the\n    results of those listeners being invoked.\n"
    },
    "getLocationUpdateListeners(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getLocationUpdateListeners(java.lang.String)",
      "documentation": "@deprecated Do not test listeners, instead use {@link #simulateLocation(Location)} and test the\n    results of those listeners being invoked.\n"
    },
    "getLocationUpdatePendingIntents()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.app.PendingIntent\u003e",
      "exceptions": [],
      "name": "getLocationUpdatePendingIntents()",
      "documentation": "@deprecated Do not test pending intents, instead use {@link #simulateLocation(Location)} and\n    test the results of those pending intent being invoked.\n"
    },
    "getLocationUpdatePendingIntents(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "java.util.List\u003candroid.app.PendingIntent\u003e",
      "exceptions": [],
      "name": "getLocationUpdatePendingIntents(java.lang.String)",
      "documentation": "Retrieves a list of all currently registered pending intents for the given provider.\n\n@deprecated Do not test pending intents, instead use {@link #simulateLocation(Location)} and\n    test the results of those pending intent being invoked.\n"
    },
    "getOrCreateProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
      "exceptions": [],
      "name": "getOrCreateProviderEntry(java.lang.String)"
    },
    "getProvider(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "name"
      ],
      "returnType": "android.location.LocationProvider",
      "exceptions": [],
      "name": "getProvider(java.lang.String)"
    },
    "getProviderEntries()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "java.util.Set\u003corg.robolectric.shadows.ShadowLocationManager.ProviderEntry\u003e",
      "exceptions": [],
      "name": "getProviderEntries()"
    },
    "getProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
      "exceptions": [],
      "name": "getProviderEntry(java.lang.String)"
    },
    "getProviderProperties(java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "providerStr"
      ],
      "returnType": "java.lang.Object",
      "exceptions": [],
      "minSdk": 31,
      "name": "getProviderProperties(java.lang.Object)"
    },
    "getProviders(android.location.Criteria,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProviders(android.location.Criteria,boolean)"
    },
    "getProviders(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "enabledOnly"
      ],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProviders(boolean)"
    },
    "getRequestLocationUpdateListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getRequestLocationUpdateListeners()",
      "documentation": "@deprecated Do not test listeners, instead use {@link #simulateLocation(Location)} and test the\n    results of those listeners being invoked.\n"
    },
    "hasProvider(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "hasProvider(java.lang.String)"
    },
    "injectLocation(android.location.Location)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "location"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "injectLocation(android.location.Location)"
    },
    "isLocationEnabled()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "isLocationEnabled()"
    },
    "isLocationEnabledForUser(android.os.UserHandle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "userHandle"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "isLocationEnabledForUser(android.os.UserHandle)"
    },
    "isProviderEnabled(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isProviderEnabled(java.lang.String)"
    },
    "registerAntennaInfoListener(java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "java.lang.Object",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerAntennaInfoListener(java.lang.Object,java.lang.Object)"
    },
    "registerGnssBatchedLocationCallback(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "periodNanos",
        "wakeOnFifoFull",
        "callback",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 26,
      "name": "registerGnssBatchedLocationCallback(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"
    },
    "registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "registerGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback,android.os.Handler)"
    },
    "registerGnssMeasurementsCallback(java.lang.Object,java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "executor",
        "callback"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerGnssMeasurementsCallback(java.lang.Object,java.lang.Object,java.lang.Object)"
    },
    "registerGnssMeasurementsCallback(java.util.concurrent.Executor,android.location.GnssMeasurementsEvent.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerGnssMeasurementsCallback(java.util.concurrent.Executor,android.location.GnssMeasurementsEvent.Callback)"
    },
    "registerGnssStatusCallback(android.location.GnssStatus.Callback,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback",
        "handler"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 24,
      "name": "registerGnssStatusCallback(android.location.GnssStatus.Callback,android.os.Handler)"
    },
    "registerGnssStatusCallback(java.util.concurrent.Executor,android.location.GnssStatus.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "executor",
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 30,
      "name": "registerGnssStatusCallback(java.util.concurrent.Executor,android.location.GnssStatus.Callback)"
    },
    "removeGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "removeNmeaListener(android.location.OnNmeaMessageListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "removeNmeaListener(android.location.OnNmeaMessageListener)"
    },
    "removeProvider(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeProvider(java.lang.String)",
      "documentation": "Completely removes a provider. "
    },
    "removeProviderEntry(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeProviderEntry(java.lang.String)"
    },
    "removeUpdates(android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.app.PendingIntent)"
    },
    "removeUpdates(android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.location.LocationListener)"
    },
    "removeUpdatesInternal(java.lang.Object)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "key"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdatesInternal(java.lang.Object)"
    },
    "requestFlush(java.lang.String,android.app.PendingIntent,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "pendingIntent",
        "requestCode"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "requestFlush(java.lang.String,android.app.PendingIntent,int)"
    },
    "requestFlush(java.lang.String,android.location.LocationListener,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "listener",
        "requestCode"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "requestFlush(java.lang.String,android.location.LocationListener,int)"
    },
    "requestLocationUpdates(android.location.LocationRequest,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(android.location.LocationRequest,android.app.PendingIntent)"
    },
    "requestLocationUpdates(android.location.LocationRequest,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(android.location.LocationRequest,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(android.location.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "request",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "requestLocationUpdates(android.location.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,android.location.LocationRequest,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "request",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "requestLocationUpdates(java.lang.String,android.location.LocationRequest,android.app.PendingIntent)"
    },
    "requestLocationUpdates(java.lang.String,android.location.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "request",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "requestLocationUpdates(java.lang.String,android.location.LocationRequest,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(java.lang.String,long,float,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "requestLocationUpdates(java.lang.String,long,float,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(long,float,android.location.Criteria,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "requestLocationUpdates(long,float,android.location.Criteria,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.RoboLocationRequest,android.app.PendingIntent)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "request",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.RoboLocationRequest,android.app.PendingIntent)"
    },
    "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.RoboLocationRequest,java.util.concurrent.Executor,android.location.LocationListener)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "request",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdatesInternal(java.lang.String,org.robolectric.shadows.ShadowLocationManager.RoboLocationRequest,java.util.concurrent.Executor,android.location.LocationListener)"
    },
    "requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(android.location.Criteria,android.app.PendingIntent)"
    },
    "requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "criteria",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(android.location.Criteria,android.location.LocationListener,android.os.Looper)"
    },
    "requestSingleUpdate(java.lang.String,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(java.lang.String,android.app.PendingIntent)"
    },
    "requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "provider",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestSingleUpdate(java.lang.String,android.location.LocationListener,android.os.Looper)"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static",
        "synchronized"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "sendGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "antennaInfos"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)",
      "documentation": "@deprecated Use {@link #simulateGnssAntennaInfo(List)} instead.\n"
    },
    "sendGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "event"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)",
      "documentation": "@deprecated Use {@link #simulateGnssMeasurementsEvent(GnssMeasurementsEvent)} instead.\n"
    },
    "sendGnssStatus(android.location.GnssStatus)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "status"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendGnssStatus(android.location.GnssStatus)",
      "documentation": "@deprecated Use {@link #simulateGnssStatus(GnssStatus)} instead.\n"
    },
    "sendNmeaMessage(java.lang.String,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "message",
        "timestamp"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "sendNmeaMessage(java.lang.String,long)",
      "documentation": "@deprecated Use {@link #simulateNmeaMessage(String, long)} instead.\n"
    },
    "setGnssBatchSize(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "gnssBatchSize"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setGnssBatchSize(int)",
      "documentation": "Sets the GNSS hardware batch size. Values greater than 0 enables hardware GNSS batching APIs.\n"
    },
    "setGnssHardwareModelName(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "gnssHardwareModelName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setGnssHardwareModelName(java.lang.String)",
      "documentation": "Sets the GNSS hardware model name returned by {@link\nLocationManager#getGnssHardwareModelName()}.\n"
    },
    "setGnssYearOfHardware(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "gnssYearOfHardware"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setGnssYearOfHardware(int)",
      "documentation": "Sets the GNSS year of hardware returned by {@link LocationManager#getGnssYearOfHardware()}. "
    },
    "setLastKnownLocation(java.lang.String,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLastKnownLocation(java.lang.String,android.location.Location)",
      "documentation": "@deprecated Use {@link #simulateLocation(Location)} to update the last location for a provider.\n"
    },
    "setLocationEnabled(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "enabled"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationEnabled(boolean)",
      "documentation": "On P and above, turns location on or off. On pre-P devices, sets the location mode to {@link\nandroid.provider.Settings.Secure#LOCATION_MODE_HIGH_ACCURACY} or {@link\nandroid.provider.Settings.Secure#LOCATION_MODE_OFF}.\n"
    },
    "setLocationEnabledForUser(boolean,android.os.UserHandle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "enabled",
        "userHandle"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 28,
      "name": "setLocationEnabledForUser(boolean,android.os.UserHandle)"
    },
    "setLocationMode(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "locationMode"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationMode(int)",
      "documentation": "On pre-P devices, sets the device location mode. For P and above, use {@link\n#setLocationEnabled(boolean)} and {@link #setProviderEnabled(String, boolean)} in combination\nto achieve the desired effect.\n"
    },
    "setLocationModeInternal(int)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "locationMode"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLocationModeInternal(int)"
    },
    "setProviderEnabled(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name",
        "enabled"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderEnabled(java.lang.String,boolean)",
      "documentation": "Sets the given provider enabled or disabled. The provider will be created if it doesn\u0027t exist\nalready. On P and above, location must also be enabled via {@link #setLocationEnabled(boolean)}\nin order for a provider to be considered enabled.\n"
    },
    "setProviderProperties(java.lang.String,org.robolectric.shadows.ShadowLocationManager.ProviderProperties)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name",
        "properties"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderProperties(java.lang.String,org.robolectric.shadows.ShadowLocationManager.ProviderProperties)",
      "documentation": "Sets the properties of the given provider. The provider will be created if it doesn\u0027t exist\nalready. This overload functions for all Android SDK levels.\n"
    },
    "simulateGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "antennaInfos"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssAntennaInfo(java.util.List\u003candroid.location.GnssAntennaInfo\u003e)",
      "documentation": "Simulates a GNSS antenna info event. "
    },
    "simulateGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "event"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssMeasurementsEvent(android.location.GnssMeasurementsEvent)",
      "documentation": "Simulates a GNSS measurements event. "
    },
    "simulateGnssMeasurementsStatus(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "status"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssMeasurementsStatus(int)",
      "documentation": "Simulates a GNSS measurements status change. "
    },
    "simulateGnssStatus(android.location.GnssStatus)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "status"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssStatus(android.location.GnssStatus)",
      "documentation": "Simulates a GNSS status event. "
    },
    "simulateGnssStatusFirstFix(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "ttff"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssStatusFirstFix(int)",
      "documentation": "Simulates a GNSS status first fix event. "
    },
    "simulateGnssStatusStarted()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssStatusStarted()",
      "documentation": "Simulates a GNSS status started event. "
    },
    "simulateGnssStatusStopped()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGnssStatusStopped()",
      "documentation": "Simulates a GNSS status stopped event. "
    },
    "simulateLocation(android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateLocation(android.location.Location)",
      "documentation": "A convenience function equivalent to invoking {@link #simulateLocation(String, Location)} with\nthe provider of the given location.\n"
    },
    "simulateLocation(java.lang.String,android.location.Location...)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "locations"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateLocation(java.lang.String,android.location.Location...)",
      "documentation": "Delivers to the given provider (which will be created if necessary) a new location which will\nbe delivered to appropriate listeners and updates state accordingly. Delivery will ignore the\nenabled/disabled state of providers, unlike location on a real device.\n\n\u003cp\u003eThe location will also be delivered to the passive provider.\n"
    },
    "simulateNmeaMessage(java.lang.String,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "message",
        "timestamp"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateNmeaMessage(java.lang.String,long)",
      "documentation": "Simulates a NMEA message. "
    },
    "unregisterAntennaInfoListener(java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 30,
      "name": "unregisterAntennaInfoListener(java.lang.Object)"
    },
    "unregisterGnssBatchedLocationCallback(java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 26,
      "name": "unregisterGnssBatchedLocationCallback(java.lang.Object)"
    },
    "unregisterGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "unregisterGnssMeasurementsCallback(android.location.GnssMeasurementsEvent.Callback)"
    },
    "unregisterGnssStatusCallback(android.location.GnssStatus.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "unregisterGnssStatusCallback(android.location.GnssStatus.Callback)"
    }
  },
  "imports": [
    "android.location.LocationManager.GPS_PROVIDER",
    "android.location.LocationManager.NETWORK_PROVIDER",
    "android.location.LocationManager.PASSIVE_PROVIDER",
    "android.os.Build.VERSION_CODES.P",
    "android.provider.Settings.Secure.LOCATION_MODE",
    "android.provider.Settings.Secure.LOCATION_MODE_BATTERY_SAVING",
    "android.provider.Settings.Secure.LOCATION_MODE_HIGH_ACCURACY",
    "android.provider.Settings.Secure.LOCATION_MODE_OFF",
    "android.provider.Settings.Secure.LOCATION_MODE_SENSORS_ONLY",
    "android.provider.Settings.Secure.LOCATION_PROVIDERS_ALLOWED",
    "java.util.concurrent.TimeUnit.NANOSECONDS",
    "android.annotation.Nullable",
    "android.annotation.RequiresApi",
    "android.app.PendingIntent",
    "android.app.PendingIntent.CanceledException",
    "android.content.Context",
    "android.content.Intent",
    "android.location.Criteria",
    "android.location.GnssAntennaInfo",
    "android.location.GnssMeasurementsEvent",
    "android.location.GnssStatus",
    "android.location.GpsStatus",
    "android.location.Location",
    "android.location.LocationListener",
    "android.location.LocationManager",
    "android.location.LocationProvider",
    "android.location.LocationRequest",
    "android.location.OnNmeaMessageListener",
    "android.os.Build.VERSION_CODES",
    "android.os.Bundle",
    "android.os.CancellationSignal",
    "android.os.Handler",
    "android.os.Looper",
    "android.os.Process",
    "android.os.SystemClock",
    "android.os.UserHandle",
    "android.os.WorkSource",
    "android.provider.Settings.Secure",
    "android.text.TextUtils",
    "android.util.Log",
    "com.android.internal.annotations.GuardedBy",
    "com.google.common.collect.ImmutableList",
    "com.google.common.collect.Iterables",
    "java.lang.reflect.Constructor",
    "java.util.ArrayList",
    "java.util.Arrays",
    "java.util.Collections",
    "java.util.HashSet",
    "java.util.List",
    "java.util.Objects",
    "java.util.Set",
    "java.util.concurrent.CopyOnWriteArrayList",
    "java.util.concurrent.Executor",
    "java.util.concurrent.RejectedExecutionException",
    "java.util.function.Consumer",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadows.ShadowSettings.ShadowSecure",
    "org.robolectric.util.ReflectionHelpers",
    "org.robolectric.util.ReflectionHelpers.ClassParameter",
    "org.robolectric.shadows.ShadowLocationManager.ProviderProperties",
    "org.robolectric.shadows.ShadowLocationManager.ProviderEntry",
    "org.robolectric.shadows.ShadowLocationManager.RoboLocationRequest",
    "org.robolectric.shadows.ShadowLocationManager.LocationTransport",
    "org.robolectric.shadows.ShadowLocationManager.LocationListenerTransport",
    "org.robolectric.shadows.ShadowLocationManager.LocationPendingIntentTransport",
    "org.robolectric.shadows.ShadowLocationManager.LegacyBatchedTransport",
    "org.robolectric.shadows.ShadowLocationManager.CurrentLocationTransport",
    "org.robolectric.shadows.ShadowLocationManager.GnssStatusCallbackTransport",
    "org.robolectric.shadows.ShadowLocationManager.OnNmeaMessageListenerTransport",
    "org.robolectric.shadows.ShadowLocationManager.GnssMeasurementsEventCallbackTransport",
    "org.robolectric.shadows.ShadowLocationManager.GnssAntennaInfoListenerTransport",
    "org.robolectric.shadows.ShadowLocationManager.HandlerExecutor"
  ],
  "name": "org.robolectric.shadows.ShadowLocationManager",
  "documentation": "Shadow for {@link LocationManager}. Note that the default state of location on Android devices is\nlocation on, gps provider enabled, network provider disabled.\n"
}