{
  "methods": {
    "\u003cC\u003eaddComponent(java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,com.google.common.base.Function\u003candroid.content.pm.PackageInfo,C[]\u003e,java.util.function.BiConsumer\u003candroid.content.pm.PackageInfo,C[]\u003e,C,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "filtersMap",
        "componentArrayInPackage",
        "componentsSetter",
        "newComponent",
        "updateIfExists"
      ],
      "returnType": "C",
      "exceptions": [],
      "name": "\u003cC\u003eaddComponent(java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,com.google.common.base.Function\u003candroid.content.pm.PackageInfo,C[]\u003e,java.util.function.BiConsumer\u003candroid.content.pm.PackageInfo,C[]\u003e,C,boolean)"
    },
    "\u003cC\u003eremoveComponent(android.content.ComponentName,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,com.google.common.base.Function\u003candroid.content.pm.PackageInfo,C[]\u003e,java.util.function.BiConsumer\u003candroid.content.pm.PackageInfo,C[]\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "componentName",
        "filtersMap",
        "componentArrayInPackage",
        "componentsSetter"
      ],
      "returnType": "C",
      "exceptions": [],
      "name": "\u003cC\u003eremoveComponent(android.content.ComponentName,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,com.google.common.base.Function\u003candroid.content.pm.PackageInfo,C[]\u003e,java.util.function.BiConsumer\u003candroid.content.pm.PackageInfo,C[]\u003e)"
    },
    "\u003cC\u003eupdateName(android.content.ComponentName,C)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "name",
        "component"
      ],
      "returnType": "C",
      "exceptions": [],
      "name": "\u003cC\u003eupdateName(android.content.ComponentName,C)"
    },
    "\u003cV\u003emapForPackage(java.util.SortedMap\u003candroid.content.ComponentName,V\u003e,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "input",
        "packageName"
      ],
      "returnType": "java.util.SortedMap\u003candroid.content.ComponentName,V\u003e",
      "exceptions": [],
      "name": "\u003cV\u003emapForPackage(java.util.SortedMap\u003candroid.content.ComponentName,V\u003e,java.lang.String)"
    },
    "addActivityIcon(android.content.ComponentName,android.graphics.drawable.Drawable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "component",
        "drawable"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addActivityIcon(android.content.ComponentName,android.graphics.drawable.Drawable)"
    },
    "addActivityIcon(android.content.Intent,android.graphics.drawable.Drawable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "drawable"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addActivityIcon(android.content.Intent,android.graphics.drawable.Drawable)"
    },
    "addActivityIfNotPresent(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ActivityInfo",
      "exceptions": [],
      "name": "addActivityIfNotPresent(android.content.ComponentName)",
      "documentation": "Makes sure that given activity exists.\n\nIf the activity doesn\u0027t exist yet, it will be created with {@code applicationInfo} set to an\nexisting application, or if it doesn\u0027t exist, a new package will be created.\n\n@return existing or newly created activity info.\n"
    },
    "addCanonicalName(java.lang.String,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "currentName",
        "canonicalName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addCanonicalName(java.lang.String,java.lang.String)",
      "documentation": "Adds a canonical package name for a package.\n\n\u003cp\u003eThis will be reflected when calling {@link\nPackageManager#currentToCanonicalPackageNames(String[])} or {@link\nPackageManager#canonicalToCurrentPackageNames(String[])} (String[])}.\n"
    },
    "addChangedPackage(int,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "sequenceNumber",
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addChangedPackage(int,java.lang.String)",
      "documentation": "Adds {@code packageName} to the list of changed packages for the particular {@code\nsequenceNumber}.\n\n@param sequenceNumber has to be \u003e\u003d 0\n@param packageName name of the package that was changed\n"
    },
    "addCurrentToCannonicalName(java.lang.String,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "currentName",
        "canonicalName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addCurrentToCannonicalName(java.lang.String,java.lang.String)"
    },
    "addDrawableResolution(java.lang.String,int,android.graphics.drawable.Drawable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName",
        "resourceId",
        "drawable"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addDrawableResolution(java.lang.String,int,android.graphics.drawable.Drawable)"
    },
    "addFilters(java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,java.util.List\u003c? extends android.content.pm.PackageParser.Component\u003c?\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "componentMap",
        "components"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addFilters(java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e,java.util.List\u003c? extends android.content.pm.PackageParser.Component\u003c?\u003e\u003e)"
    },
    "addIntentFilterForActivity(android.content.ComponentName,android.content.IntentFilter)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName",
        "filter"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "addIntentFilterForActivity(android.content.ComponentName,android.content.IntentFilter)",
      "documentation": "Add intent filter for given activity.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "addIntentFilterForComponent(android.content.ComponentName,android.content.IntentFilter,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "componentName",
        "filter",
        "filterMap"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "addIntentFilterForComponent(android.content.ComponentName,android.content.IntentFilter,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "addIntentFilterForProvider(android.content.ComponentName,android.content.IntentFilter)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName",
        "filter"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "addIntentFilterForProvider(android.content.ComponentName,android.content.IntentFilter)",
      "documentation": "Add intent filter for given provider.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "addIntentFilterForReceiver(android.content.ComponentName,android.content.IntentFilter)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName",
        "filter"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "addIntentFilterForReceiver(android.content.ComponentName,android.content.IntentFilter)",
      "documentation": "Add intent filter for given receiver.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "addIntentFilterForService(android.content.ComponentName,android.content.IntentFilter)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName",
        "filter"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "addIntentFilterForService(android.content.ComponentName,android.content.IntentFilter)",
      "documentation": "Add intent filter for given service.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "addOrUpdateActivity(android.content.pm.ActivityInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "activityInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addOrUpdateActivity(android.content.pm.ActivityInfo)",
      "documentation": "Adds or updates given activity in the system.\n\nIf activity with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}\nexists it will be updated. Its {@link ComponentInfo#applicationInfo} is always set to {@link\nApplicationInfo} already existing in the system, but if no application exists a new one will\nbe created using {@link ComponentInfo#applicationInfo} in this component.\n"
    },
    "addOrUpdateProvider(android.content.pm.ProviderInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "providerInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addOrUpdateProvider(android.content.pm.ProviderInfo)",
      "documentation": "Adds or updates given content provider in the system.\n\nIf content provider with the same {@link ComponentInfo#name} and {@code\nComponentInfo#packageName} exists it will be updated. Its {@link ComponentInfo#applicationInfo}\nis always set to {@link ApplicationInfo} already existing in the system, but if no\napplication exists a new one will be created using {@link ComponentInfo#applicationInfo} in\nthis component.\n"
    },
    "addOrUpdateReceiver(android.content.pm.ActivityInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "receiverInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addOrUpdateReceiver(android.content.pm.ActivityInfo)",
      "documentation": "Adds or updates given broadcast receiver in the system.\n\nIf broadcast receiver with the same {@link ComponentInfo#name} and {@code\nComponentInfo#packageName} exists it will be updated. Its {@link ComponentInfo#applicationInfo}\nis always set to {@link ApplicationInfo} already existing in the system, but if no\napplication exists a new one will be created using {@link ComponentInfo#applicationInfo} in\nthis component.\n"
    },
    "addOrUpdateService(android.content.pm.ServiceInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "serviceInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addOrUpdateService(android.content.pm.ServiceInfo)",
      "documentation": "Adds or updates given service in the system.\n\nIf service with the same {@link ComponentInfo#name} and {@code ComponentInfo#packageName}\nexists it will be updated. Its {@link ComponentInfo#applicationInfo} is always set to {@link\nApplicationInfo} already existing in the system, but if no application exists a new one will be\ncreated using {@link ComponentInfo#applicationInfo} in this component.\n"
    },
    "addPackage(android.content.pm.PackageInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPackage(android.content.pm.PackageInfo)",
      "documentation": "This method is getting renamed to {link {@link #installPackage}. "
    },
    "addPackage(android.content.pm.PackageInfo,android.content.pm.PackageStats)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "synchronized"
      ],
      "params": [
        "packageInfo",
        "packageStats"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPackage(android.content.pm.PackageInfo,android.content.pm.PackageStats)",
      "documentation": "Installs a package with its stats with the {@link PackageManager}.\n\nThis method doesn\u0027t add any defaults to the {@code packageInfo} parameters. You should make\nsure it is valid (see {@link #installPackage(PackageInfo)}).\n"
    },
    "addPackage(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPackage(java.lang.String)",
      "documentation": "@deprecated Use {@link #installPackage(PackageInfo)} instead. "
    },
    "addPackageInternal(android.content.pm.PackageParser.Package)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "appPackage"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPackageInternal(android.content.pm.PackageParser.Package)",
      "documentation": "Internal use only.\n\n@param appPackage\n"
    },
    "addPackageNoDefaults(android.content.pm.PackageInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPackageNoDefaults(android.content.pm.PackageInfo)",
      "documentation": "Adds a package to the {@link PackageManager}, but doesn\u0027t set any default values on it.\n\nRight now it will not set {@link ApplicationInfo#FLAG_INSTALLED} flag on its application, so\nif not set explicitly, it will be treated as not installed.\n"
    },
    "addPermissionGroupInfo(android.content.pm.PermissionGroupInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "permissionGroupInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPermissionGroupInfo(android.content.pm.PermissionGroupInfo)",
      "documentation": "Allows overriding or adding permission-group elements. These would be otherwise specified by\neither (the\nsystem)[https://developer.android.com/guide/topics/permissions/requesting.html#perm-groups] or\nby (the app\nitself)[https://developer.android.com/guide/topics/manifest/permission-group-element.html], as\npart of its manifest\n\n{@link android.content.pm.PackageParser.PermissionGroup}s added through this method have\nprecedence over those specified with the same name by one of the aforementioned methods.\n\n@see PackageManager#getAllPermissionGroups(int)\n@see PackageManager#getPermissionGroupInfo(String, int)\n"
    },
    "addPermissionInfo(android.content.pm.PermissionInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "permissionInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPermissionInfo(android.content.pm.PermissionInfo)"
    },
    "addPersistentPreferredActivity(android.content.IntentFilter,android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [],
      "params": [
        "filter",
        "activity"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPersistentPreferredActivity(android.content.IntentFilter,android.content.ComponentName)"
    },
    "addPreferredActivityInternal(android.content.IntentFilter,android.content.ComponentName,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "filter",
        "activity",
        "preferredActivitiesMap"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addPreferredActivityInternal(android.content.IntentFilter,android.content.ComponentName,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "addProviderIfNotPresent(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ProviderInfo",
      "exceptions": [],
      "name": "addProviderIfNotPresent(android.content.ComponentName)",
      "documentation": "Makes sure that given provider exists.\n\nIf the provider doesn\u0027t exist yet, it will be created with {@code applicationInfo} set to an\nexisting application, or if it doesn\u0027t exist, a new package will be created.\n\n@return existing or newly created provider info.\n"
    },
    "addReceiverIfNotPresent(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ActivityInfo",
      "exceptions": [],
      "name": "addReceiverIfNotPresent(android.content.ComponentName)",
      "documentation": "Makes sure that given receiver exists.\n\nIf the receiver doesn\u0027t exist yet, it will be created with {@code applicationInfo} set to an\nexisting application, or if it doesn\u0027t exist, a new package will be created.\n\n@return existing or newly created receiver info.\n"
    },
    "addResolveInfoForIntent(android.content.Intent,android.content.pm.ResolveInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addResolveInfoForIntent(android.content.Intent,android.content.pm.ResolveInfo)",
      "documentation": "Adds extra resolve info for an intent.\n\nNote that this resolve info will have {@link ResolveInfo#isDefault} field set to {@code\ntrue} to allow its resolution for implicit intents. If this is not what you want, then please\nuse {@link #addResolveInfoForIntentNoDefaults} instead.\n\n@deprecated use {@link #addIntentFilterForComponent} instead and if the component doesn\u0027t exist\n    add it using any of {@link #installPackage}, {@link #addOrUpdateActivity}, {@link\n    #addActivityIfNotPresent} or their counterparts for other types of components.\n"
    },
    "addResolveInfoForIntent(android.content.Intent,java.util.List\u003candroid.content.pm.ResolveInfo\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addResolveInfoForIntent(android.content.Intent,java.util.List\u003candroid.content.pm.ResolveInfo\u003e)",
      "documentation": "@deprecated see note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}. "
    },
    "addResolveInfoForIntentNoDefaults(android.content.Intent,android.content.pm.ResolveInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addResolveInfoForIntentNoDefaults(android.content.Intent,android.content.pm.ResolveInfo)",
      "documentation": "Adds the {@code info} as {@link ResolveInfo} for the intent but without applying any default\nvalues.\n\nIn particular it will not make the {@link ResolveInfo#isDefault} field {@code true}, that\nmeans that this resolve info will not resolve for {@link Intent#resolveActivity} and {@link\nContext#startActivity}.\n\n@deprecated see the note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}.\n"
    },
    "addServiceIfNotPresent(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ServiceInfo",
      "exceptions": [],
      "name": "addServiceIfNotPresent(android.content.ComponentName)",
      "documentation": "Makes sure that given service exists.\n\nIf the service doesn\u0027t exist yet, it will be created with {@code applicationInfo} set to an\nexisting application, or if it doesn\u0027t exist, a new package will be created.\n\n@return existing or newly created service info.\n"
    },
    "addSystemAvailableFeature(android.content.pm.FeatureInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "featureInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addSystemAvailableFeature(android.content.pm.FeatureInfo)"
    },
    "addSystemSharedLibraryName(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addSystemSharedLibraryName(java.lang.String)",
      "documentation": "Adds a value to be returned by {@link PackageManager#getSystemSharedLibraryNames()}. "
    },
    "clearIntentFilterForActivity(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "clearIntentFilterForActivity(android.content.ComponentName)",
      "documentation": "Clears intent filters for given activity.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "clearIntentFilterForComponent(android.content.ComponentName,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "componentName",
        "filterMap"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "clearIntentFilterForComponent(android.content.ComponentName,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "clearIntentFilterForProvider(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "clearIntentFilterForProvider(android.content.ComponentName)",
      "documentation": "Clears intent filters for given provider.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "clearIntentFilterForReceiver(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "clearIntentFilterForReceiver(android.content.ComponentName)",
      "documentation": "Clears intent filters for given receiver.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "clearIntentFilterForService(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "void",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "clearIntentFilterForService(android.content.ComponentName)",
      "documentation": "Clears intent filters for given service.\n\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "clearPackagePersistentPreferredActivities(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [],
      "params": [
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "clearPackagePersistentPreferredActivities(java.lang.String)"
    },
    "clearPackagePreferredActivitiesInternal(java.lang.String,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "packageName",
        "preferredActivitiesMap"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "clearPackagePreferredActivitiesInternal(java.lang.String,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "clearSystemAvailableFeatures()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "clearSystemAvailableFeatures()"
    },
    "clearSystemSharedLibraryNames()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "clearSystemSharedLibraryNames()",
      "documentation": "Clears the values returned by {@link PackageManager#getSystemSharedLibraryNames()}. "
    },
    "compareSignature(android.content.pm.Signature[],android.content.pm.Signature[])": {
      "isImplementation": false,
      "modifiers": [
        "static"
      ],
      "params": [
        "signatures1",
        "signatures2"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "compareSignature(android.content.pm.Signature[],android.content.pm.Signature[])"
    },
    "createTempDir(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "name"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "createTempDir(java.lang.String)"
    },
    "deleteModule(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "java.lang.Object",
      "exceptions": [],
      "name": "deleteModule(java.lang.String)",
      "documentation": "Deletes a module when given the module\u0027s package name {@link ModuleInfo} be sure to give the\ncorrect name as this method does not ensure existence of the module before deletion. Since\nmodule installation ensures that a package exists in the device, also delete the package for\nfull deletion.\n\n@param packageName should be the value of {@link ModuleInfo#getPackageName}.\n@return deleted module of {@code null} if no module with this name exists.\n"
    },
    "deletePackage(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "deletePackage(java.lang.String)",
      "documentation": "Uninstalls the package from the system in a way, that will allow its discovery through {@link\nPackageManager#MATCH_UNINSTALLED_PACKAGES}.\n"
    },
    "deletePackage(java.lang.String,android.content.pm.IPackageDeleteObserver,int)": {
      "isImplementation": false,
      "modifiers": [
        "protected"
      ],
      "params": [
        "packageName",
        "observer",
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "deletePackage(java.lang.String,android.content.pm.IPackageDeleteObserver,int)"
    },
    "doPendingUninstallCallbacks()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doPendingUninstallCallbacks()",
      "documentation": "Runs the callbacks pending from calls to {@link PackageManager#deletePackage(String,\nIPackageDeleteObserver, int)}\n"
    },
    "freeStorage(long,android.content.IntentSender)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "freeStorageSize",
        "pi"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "freeStorage(long,android.content.IntentSender)"
    },
    "freeStorageAndNotify(long,android.content.pm.IPackageDataObserver)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "freeStorageSize",
        "observer"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "freeStorageAndNotify(long,android.content.pm.IPackageDataObserver)"
    },
    "getComponentEnabledSettingFlags(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "getComponentEnabledSettingFlags(android.content.ComponentName)",
      "documentation": "Return the flags set in call to {@link\nandroid.app.ApplicationPackageManager#setComponentEnabledSetting(ComponentName, int, int)}.\n\n@param componentName The component name.\n@return The flags.\n"
    },
    "getDeletedPackages()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.Set\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getDeletedPackages()",
      "documentation": "Returns package names successfully deleted with {@link PackageManager#deletePackage(String,\nIPackageDeleteObserver, int)} Note that like real {@link PackageManager} the calling context\nmust have {@link android.Manifest.permission#DELETE_PACKAGES} permission set.\n"
    },
    "getDistractingPackageRestrictions(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "pkg"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "getDistractingPackageRestrictions(java.lang.String)",
      "documentation": "Returns the last value provided to {@code setDistractingPackageRestrictions} for {@code pkg}.\n\nDefaults to {@code PackageManager.RESTRICTION_NONE} if {@code\nsetDistractingPackageRestrictions} has not been called for {@code pkg}.\n"
    },
    "getIntentFiltersForActivity(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "java.util.List\u003candroid.content.IntentFilter\u003e",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "getIntentFiltersForActivity(android.content.ComponentName)",
      "documentation": "Get list of intent filters defined for given activity.\n\n@param componentName Name of the activity whose intent filters are to be retrieved\n@return the activity\u0027s intent filters\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "getIntentFiltersForComponent(android.content.ComponentName,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "componentName",
        "filterMap"
      ],
      "returnType": "java.util.List\u003candroid.content.IntentFilter\u003e",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "getIntentFiltersForComponent(android.content.ComponentName,java.util.Map\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "getIntentFiltersForProvider(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "java.util.List\u003candroid.content.IntentFilter\u003e",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "getIntentFiltersForProvider(android.content.ComponentName)",
      "documentation": "Get list of intent filters defined for given provider.\n\n@param componentName Name of the provider whose intent filters are to be retrieved\n@return the provider\u0027s intent filters\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "getIntentFiltersForReceiver(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "java.util.List\u003candroid.content.IntentFilter\u003e",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "getIntentFiltersForReceiver(android.content.ComponentName)",
      "documentation": "Get list of intent filters defined for given receiver.\n\n@param componentName Name of the receiver whose intent filters are to be retrieved\n@return the receiver\u0027s intent filters\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "getIntentFiltersForService(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "java.util.List\u003candroid.content.IntentFilter\u003e",
      "exceptions": [
        "android.content.pm.PackageManager.NameNotFoundException"
      ],
      "name": "getIntentFiltersForService(android.content.ComponentName)",
      "documentation": "Get list of intent filters defined for given service.\n\n@param componentName Name of the service whose intent filters are to be retrieved\n@return the service\u0027s intent filters\n@throws NameNotFoundException if component with given name doesn\u0027t exist.\n"
    },
    "getInternalMutablePackageInfo(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "android.content.pm.PackageInfo",
      "exceptions": [],
      "name": "getInternalMutablePackageInfo(java.lang.String)",
      "documentation": "Testing API allowing to retrieve internal package representation.\n\nThis will allow to modify the package in a way visible to Robolectric, as this is\nRobolectric\u0027s internal full package representation.\n\nNote that maybe a better way is to just modify the test manifest to make those modifications\nin a standard way.\n\nRetrieving package info using {@link PackageManager#getPackageInfo} / {@link\nPackageManager#getApplicationInfo} will return defensive copies that will be stripped out of\ninformation according to provided flags. Don\u0027t use it to modify Robolectric state.\n"
    },
    "getPackageArchiveInfo(java.lang.String,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "archiveFilePath",
        "flags"
      ],
      "returnType": "android.content.pm.PackageInfo",
      "exceptions": [],
      "name": "getPackageArchiveInfo(java.lang.String,int)"
    },
    "getPackageInfoForTesting(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "android.content.pm.PackageInfo",
      "exceptions": [],
      "name": "getPackageInfoForTesting(java.lang.String)",
      "documentation": "@deprecated Use {@link #getInternalMutablePackageInfo} instead. It has better name. "
    },
    "getPackageName(android.content.pm.ResolveInfo)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "resolveInfo"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getPackageName(android.content.pm.ResolveInfo)"
    },
    "getPackageSetting(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "org.robolectric.shadows.ShadowPackageManager.PackageSetting",
      "exceptions": [],
      "name": "getPackageSetting(java.lang.String)",
      "documentation": "Returns the current {@link PackageSetting} of {@code packageName}.\n\nIf {@code packageName} is not present in this {@link ShadowPackageManager}, this method will\nreturn null.\n"
    },
    "getPackagesForUid(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "uid"
      ],
      "returnType": "java.lang.String[]",
      "exceptions": [],
      "name": "getPackagesForUid(int)"
    },
    "getPersistentPreferredActivities(java.util.List\u003candroid.content.IntentFilter\u003e,java.util.List\u003candroid.content.ComponentName\u003e,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "outFilters",
        "outActivities",
        "packageName"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "getPersistentPreferredActivities(java.util.List\u003candroid.content.IntentFilter\u003e,java.util.List\u003candroid.content.ComponentName\u003e,java.lang.String)",
      "documentation": "Method to retrieve persistent preferred activities as set by {@link\nandroid.app.admin.DevicePolicyManager#addPersistentPreferredActivity}.\n\nWorks the same way as analogous {@link PackageManager#getPreferredActivities} for regular\npreferred activities.\n"
    },
    "getPreferredActivitiesInternal(java.util.List\u003candroid.content.IntentFilter\u003e,java.util.List\u003candroid.content.ComponentName\u003e,java.lang.String,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "outFilters",
        "outActivities",
        "packageName",
        "preferredActivitiesMap"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "getPreferredActivitiesInternal(java.util.List\u003candroid.content.IntentFilter\u003e,java.util.List\u003candroid.content.ComponentName\u003e,java.lang.String,java.util.SortedMap\u003candroid.content.ComponentName,java.util.List\u003candroid.content.IntentFilter\u003e\u003e)"
    },
    "getVerificationExtendedTimeout(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "id"
      ],
      "returnType": "long",
      "exceptions": [],
      "name": "getVerificationExtendedTimeout(int)"
    },
    "getVerificationResult(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "id"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "getVerificationResult(int)"
    },
    "installModule(java.lang.Object)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "moduleInfoObject"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "installModule(java.lang.Object)",
      "documentation": "Installs a module with the {@link PackageManager} as long as it is not {@code null}\n\n\u003cp\u003eIn order to create ModuleInfo objects in a valid state please use {@link ModuleInfoBuilder}.\n"
    },
    "installPackage(android.content.pm.PackageInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "installPackage(android.content.pm.PackageInfo)",
      "documentation": "Installs a package with the {@link PackageManager}.\n\nIn order to create PackageInfo objects in a valid state please use {@link\nandroidx.test.core.content.pm.PackageInfoBuilder}.\n\nThis method automatically simulates instalation of a package in the system, so it adds a\nflag {@link ApplicationInfo#FLAG_INSTALLED} to the application info and makes sure it exits. It\nwill update applicationInfo in package components as well.\n\nIf you don\u0027t want the package to be installed, use {@link #addPackageNoDefaults} instead.\n"
    },
    "isComponentEnabled(android.content.pm.ComponentInfo)": {
      "isImplementation": false,
      "modifiers": [
        "static"
      ],
      "params": [
        "componentInfo"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isComponentEnabled(android.content.pm.ComponentInfo)"
    },
    "queryBroadcastReceivers(android.content.Intent,int,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "intent",
        "flags",
        "userId"
      ],
      "returnType": "java.util.List\u003candroid.content.pm.ResolveInfo\u003e",
      "exceptions": [],
      "minSdk": 17,
      "name": "queryBroadcastReceivers(android.content.Intent,int,int)"
    },
    "queryBroadcastReceiversAsUser(android.content.Intent,int,android.os.UserHandle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "intent",
        "flags",
        "userHandle"
      ],
      "returnType": "java.util.List\u003candroid.content.pm.ResolveInfo\u003e",
      "exceptions": [],
      "minSdk": 24,
      "name": "queryBroadcastReceiversAsUser(android.content.Intent,int,android.os.UserHandle)"
    },
    "queryOverriddenIntents(android.content.Intent,int)": {
      "isImplementation": false,
      "modifiers": [
        "protected"
      ],
      "params": [
        "intent",
        "flags"
      ],
      "returnType": "java.util.List\u003candroid.content.pm.ResolveInfo\u003e",
      "exceptions": [],
      "name": "queryOverriddenIntents(android.content.Intent,int)"
    },
    "removeActivity(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ActivityInfo",
      "exceptions": [],
      "name": "removeActivity(android.content.ComponentName)",
      "documentation": "Removes activity from the package manager.\n\n@return the removed component or {@code null} if no such component existed.\n"
    },
    "removePackage(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removePackage(java.lang.String)"
    },
    "removeProvider(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ProviderInfo",
      "exceptions": [],
      "name": "removeProvider(android.content.ComponentName)",
      "documentation": "Removes content provider from the package manager.\n\n@return the removed component or {@code null} if no such component existed.\n"
    },
    "removeReceiver(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ActivityInfo",
      "exceptions": [],
      "name": "removeReceiver(android.content.ComponentName)",
      "documentation": "Removes broadcast receiver from the package manager.\n\n@return the removed component or {@code null} if no such component existed.\n"
    },
    "removeResolveInfosForIntent(android.content.Intent,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "packageName"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeResolveInfosForIntent(android.content.Intent,java.lang.String)",
      "documentation": "Removes {@link ResolveInfo}s registered using {@link #addResolveInfoForIntent}.\n\n@deprecated see note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}.\n"
    },
    "removeService(android.content.ComponentName)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "componentName"
      ],
      "returnType": "android.content.pm.ServiceInfo",
      "exceptions": [],
      "name": "removeService(android.content.ComponentName)",
      "documentation": "Removes service from the package manager.\n\n@return the removed component or {@code null} if no such component existed.\n"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "setApplicationIcon(java.lang.String,android.graphics.drawable.Drawable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName",
        "drawable"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setApplicationIcon(java.lang.String,android.graphics.drawable.Drawable)"
    },
    "setCanRequestPackageInstalls(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "canRequestPackageInstalls"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCanRequestPackageInstalls(boolean)",
      "documentation": "Sets if the {@link PackageManager} is allowed to request package installs through package\ninstaller.\n"
    },
    "setNameForUid(int,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "uid",
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setNameForUid(int,java.lang.String)"
    },
    "setPackageArchiveInfo(java.lang.String,android.content.pm.PackageInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "archiveFilePath",
        "packageInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setPackageArchiveInfo(java.lang.String,android.content.pm.PackageInfo)"
    },
    "setPackagesForCallingUid(java.lang.String...)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packagesForCallingUid"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setPackagesForCallingUid(java.lang.String...)"
    },
    "setPackagesForUid(int,java.lang.String...)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "uid",
        "packagesForCallingUid"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setPackagesForUid(int,java.lang.String...)"
    },
    "setResolveInfosForIntent(android.content.Intent,java.util.List\u003candroid.content.pm.ResolveInfo\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setResolveInfosForIntent(android.content.Intent,java.util.List\u003candroid.content.pm.ResolveInfo\u003e)",
      "documentation": "Sets extra resolve infos for an intent.\n\nThose entries are added to whatever might be in the manifest already.\n\nNote that all resolve infos will have {@link ResolveInfo#isDefault} field set to {@code\ntrue} to allow their resolution for implicit intents. If this is not what you want, then you\nstill have the reference to those ResolveInfos, and you can set the field back to {@code\nfalse}.\n\n@deprecated see the note on {@link #addResolveInfoForIntent(Intent, ResolveInfo)}.\n"
    },
    "setSafeMode(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "safeMode"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setSafeMode(boolean)",
      "documentation": "Set value to be returned by {@link PackageManager#isSafeMode}. "
    },
    "setShouldShowActivityChooser(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "shouldShowActivityChooser"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setShouldShowActivityChooser(boolean)",
      "documentation": "If this method has been called with true, then in cases where many activities match a filter,\nan activity chooser will be resolved instead of just the first pick.\n"
    },
    "setShouldShowRequestPermissionRationale(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "permission",
        "show"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setShouldShowRequestPermissionRationale(java.lang.String,boolean)"
    },
    "setSystemFeature(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name",
        "supported"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setSystemFeature(java.lang.String,boolean)"
    },
    "setUnbadgedApplicationIcon(java.lang.String,android.graphics.drawable.Drawable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "packageName",
        "drawable"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setUnbadgedApplicationIcon(java.lang.String,android.graphics.drawable.Drawable)"
    },
    "setUpPackageStorage(android.content.pm.ApplicationInfo)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "applicationInfo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setUpPackageStorage(android.content.pm.ApplicationInfo)"
    }
  },
  "imports": [
    "android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED",
    "android.content.pm.PackageManager.GET_ACTIVITIES",
    "android.content.pm.PackageManager.GET_CONFIGURATIONS",
    "android.content.pm.PackageManager.GET_GIDS",
    "android.content.pm.PackageManager.GET_INSTRUMENTATION",
    "android.content.pm.PackageManager.GET_INTENT_FILTERS",
    "android.content.pm.PackageManager.GET_META_DATA",
    "android.content.pm.PackageManager.GET_PERMISSIONS",
    "android.content.pm.PackageManager.GET_PROVIDERS",
    "android.content.pm.PackageManager.GET_RECEIVERS",
    "android.content.pm.PackageManager.GET_RESOLVED_FILTER",
    "android.content.pm.PackageManager.GET_SERVICES",
    "android.content.pm.PackageManager.GET_SHARED_LIBRARY_FILES",
    "android.content.pm.PackageManager.GET_SIGNATURES",
    "android.content.pm.PackageManager.GET_URI_PERMISSION_PATTERNS",
    "android.content.pm.PackageManager.MATCH_DIRECT_BOOT_AWARE",
    "android.content.pm.PackageManager.MATCH_DIRECT_BOOT_UNAWARE",
    "android.content.pm.PackageManager.MATCH_DISABLED_COMPONENTS",
    "android.content.pm.PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS",
    "android.content.pm.PackageManager.MATCH_UNINSTALLED_PACKAGES",
    "android.content.pm.PackageManager.SIGNATURE_FIRST_NOT_SIGNED",
    "android.content.pm.PackageManager.SIGNATURE_MATCH",
    "android.content.pm.PackageManager.SIGNATURE_NEITHER_SIGNED",
    "android.content.pm.PackageManager.SIGNATURE_NO_MATCH",
    "android.content.pm.PackageManager.SIGNATURE_SECOND_NOT_SIGNED",
    "android.os.Build.VERSION_CODES.JELLY_BEAN_MR1",
    "android.os.Build.VERSION_CODES.KITKAT",
    "android.os.Build.VERSION_CODES.N",
    "java.util.Arrays.asList",
    "org.robolectric.util.reflector.Reflector.reflector",
    "android.Manifest",
    "android.annotation.UserIdInt",
    "android.content.ComponentName",
    "android.content.Context",
    "android.content.Intent",
    "android.content.IntentFilter",
    "android.content.IntentSender",
    "android.content.pm.ActivityInfo",
    "android.content.pm.ApplicationInfo",
    "android.content.pm.ComponentInfo",
    "android.content.pm.FeatureInfo",
    "android.content.pm.IPackageDataObserver",
    "android.content.pm.IPackageDeleteObserver",
    "android.content.pm.ModuleInfo",
    "android.content.pm.PackageInfo",
    "android.content.pm.PackageManager",
    "android.content.pm.PackageManager.NameNotFoundException",
    "android.content.pm.PackageParser",
    "android.content.pm.PackageParser.Component",
    "android.content.pm.PackageParser.IntentInfo",
    "android.content.pm.PackageParser.Package",
    "android.content.pm.PackageParser.PermissionGroup",
    "android.content.pm.PackageStats",
    "android.content.pm.PermissionGroupInfo",
    "android.content.pm.PermissionInfo",
    "android.content.pm.ProviderInfo",
    "android.content.pm.ResolveInfo",
    "android.content.pm.ServiceInfo",
    "android.content.pm.Signature",
    "android.content.res.Resources",
    "android.graphics.drawable.Drawable",
    "android.net.Uri",
    "android.os.Binder",
    "android.os.Build",
    "android.os.PersistableBundle",
    "android.os.Process",
    "android.os.RemoteException",
    "android.os.UserHandle",
    "android.util.Log",
    "android.util.Pair",
    "com.google.common.base.Function",
    "com.google.common.base.Preconditions",
    "com.google.common.collect.HashMultimap",
    "com.google.common.collect.Multimap",
    "java.lang.reflect.Array",
    "java.util.ArrayList",
    "java.util.Arrays",
    "java.util.Collections",
    "java.util.Comparator",
    "java.util.HashMap",
    "java.util.HashSet",
    "java.util.Iterator",
    "java.util.LinkedHashMap",
    "java.util.List",
    "java.util.Map",
    "java.util.Map.Entry",
    "java.util.Set",
    "java.util.SortedMap",
    "java.util.TreeMap",
    "java.util.concurrent.ConcurrentHashMap",
    "java.util.function.BiConsumer",
    "javax.annotation.Nullable",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.shadows.ShadowPackageParser._PackageParser_",
    "org.robolectric.shadows.ShadowPackageManager.PackageSetting",
    "org.robolectric.shadows.ShadowPackageManager.IntentComparator",
    "org.robolectric.shadows.ShadowPackageManager.ResolveInfoComparator",
    "org.robolectric.shadows.ShadowPackageManager.ComponentState"
  ],
  "name": "org.robolectric.shadows.ShadowPackageManager"
}