{
  "methods": {
    "__constructor__()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "__constructor__()"
    },
    "__staticInitializer__()": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "__staticInitializer__()"
    },
    "_pause()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_pause()",
      "documentation": "Simulates {@link MediaPlayer#_pause()}. Invokes {@link #doStop()} to suspend playback event\ncallbacks and sets the state to PAUSED.\n\n@see #doStop()\n"
    },
    "_release()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_release()",
      "documentation": "Simulates call to {@link MediaPlayer#_release()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to END.\n"
    },
    "_reset()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_reset()",
      "documentation": "Simulates call to {@link MediaPlayer#_reset()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to IDLE.\n"
    },
    "_stop()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_stop()",
      "documentation": "Simulates call to {@link MediaPlayer#release()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to STOPPED.\n"
    },
    "addException(org.robolectric.shadows.util.DataSource,java.io.IOException)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addException(org.robolectric.shadows.util.DataSource,java.io.IOException)"
    },
    "addException(org.robolectric.shadows.util.DataSource,java.lang.RuntimeException)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addException(org.robolectric.shadows.util.DataSource,java.lang.RuntimeException)"
    },
    "addMediaInfo(org.robolectric.shadows.util.DataSource,org.robolectric.shadows.ShadowMediaPlayer.MediaInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addMediaInfo(org.robolectric.shadows.util.DataSource,org.robolectric.shadows.ShadowMediaPlayer.MediaInfo)",
      "documentation": "Adds a {@link MediaInfo} for a {@link DataSource}.\n"
    },
    "attachAuxEffect(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "effectId"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "attachAuxEffect(int)"
    },
    "checkStateError(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "checkStateError(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that asynchronously invoke {@link\nandroid.media.MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int) onError()} when\ninvoked in an illegal state. Such methods always throw {@link IllegalStateException} rather\nthan invoke {@code onError()} if they are invoked from the END state.\n\n\u003cp\u003eThis method will either emulate this behavior by posting an {@code onError()} callback to\nthe current thread\u0027s message queue (or throw an {@link IllegalStateException} if invoked from\nthe END state), or else it will generate an assertion if {@link #setAssertOnError\nassertOnError} is set.\n\n@param method the name of the method being tested.\n@param allowedStates the states that this method is allowed to be called from.\n@see #getHandler\n@see #setAssertOnError\n@see #checkStateLog(String, EnumSet)\n@see #checkStateException(String, EnumSet)\n"
    },
    "checkStateException(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "checkStateException(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that synchronously throw an exception when invoked in an illegal\nstate. This method will likewise throw an {@link IllegalArgumentException} if it determines\nthat the method has been invoked from a disallowed state, or else it will generate an assertion\nif {@link #setAssertOnError assertOnError} is set.\n\n@param method the name of the method being tested.\n@param allowedStates the states that this method is allowed to be called from.\n@see #setAssertOnError\n@see #checkStateLog(String, EnumSet)\n@see #checkStateError(String, EnumSet)\n"
    },
    "checkStateLog(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "checkStateLog(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that only log when there is an error. Such methods throw an {@link\nIllegalArgumentException} when invoked in the END state, but log an error in other disallowed\nstates. This method will either emulate this behavior or else will generate an assertion if\ninvoked from a disallowed state if {@link #setAssertOnError assertOnError} is set.\n\n@param method the name of the method being tested.\n@param allowedStates the states that this method is allowed to be called from.\n@see #setAssertOnError\n@see #checkStateError(String, EnumSet)\n@see #checkStateException(String, EnumSet)\n"
    },
    "create(android.content.Context,android.net.Uri)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "uri"
      ],
      "returnType": "android.media.MediaPlayer",
      "exceptions": [],
      "name": "create(android.content.Context,android.net.Uri)"
    },
    "create(android.content.Context,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "resId"
      ],
      "returnType": "android.media.MediaPlayer",
      "exceptions": [],
      "name": "create(android.content.Context,int)"
    },
    "doSetDataSource(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "doSetDataSource(org.robolectric.shadows.util.DataSource)",
      "documentation": "Sets the data source without doing any other emulation. Sets the internal data source only.\nCalling directly can be useful for setting up a {@link ShadowMediaPlayer} instance during\nspecific testing so that you don\u0027t have to clutter your tests catching exceptions you know\nwon\u0027t be thrown.\n\n@param dataSource the data source that is being set.\n@see #setDataSource(DataSource)\n"
    },
    "doStart()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doStart()",
      "documentation": "Starts simulated playback. Until this method is called, the player is not \"really playing\" (see\n{@link #isReallyPlaying} for a definition of \"really playing\").\n\n\u003cp\u003eThis method is used internally by the various shadow method implementations of the\nMediaPlayer public API, but may also be called directly by the test suite if you wish to\nsimulate an internal pause. For example, to simulate a buffer underrun (player is in PLAYING\nstate but isn\u0027t actually advancing the current position through the media), you could call\n{@link #doStop()} to mark the start of the buffer underrun and {@link #doStart()} to mark its\nend and restart normal playback (which is what {@link\nShadowMediaPlayer.MediaInfo#scheduleBufferUnderrunAtOffset(int, int)\nscheduleBufferUnderrunAtOffset()} does).\n\n@see #isReallyPlaying()\n@see #doStop()\n"
    },
    "doStop()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doStop()",
      "documentation": "Pauses simulated playback. After this method is called, the player is no longer \"really\nplaying\" (see {@link #isReallyPlaying} for a definition of \"really playing\").\n\n\u003cp\u003eThis method is used internally by the various shadow method implementations of the\nMediaPlayer public API, but may also be called directly by the test suite if you wish to\nsimulate an internal pause.\n\n@see #isReallyPlaying()\n@see #doStart()\n"
    },
    "getAudioSessionId()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getAudioSessionId()"
    },
    "getAuxEffect()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getAuxEffect()",
      "documentation": "Useful for assertions.\n\n@return The current {@code auxEffect} setting.\n"
    },
    "getCurrentPosition()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getCurrentPosition()",
      "documentation": "Simulates call to {@link MediaPlayer#getCurrentPosition()}. Simply does the state validity\nchecks and then invokes {@link #getCurrentPositionRaw()} to calculate the simulated playback\nposition.\n\n@return The current offset (in ms) of the simulated playback.\n@see #getCurrentPositionRaw()\n"
    },
    "getCurrentPositionRaw()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getCurrentPositionRaw()",
      "documentation": "Retrieves the current position without doing the state checking that the emulated version of\n{@link #getCurrentPosition()} does.\n\n@return The current playback position within the current clip.\n"
    },
    "getDataSource()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.util.DataSource",
      "exceptions": [],
      "name": "getDataSource()",
      "documentation": "Retrieves the data source (if any) that was passed in to {@link #setDataSource(DataSource)}.\n\n\u003cp\u003eUseful for assertions.\n\n@return The source passed in to {@code setDataSource}.\n"
    },
    "getDuration()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getDuration()",
      "documentation": "Simulates call to {@link MediaPlayer#getDuration()}. Retrieves the duration as defined by the\ncurrent {@link MediaInfo} instance.\n\n@return The duration (in ms) of the current simulated playback.\n@see #addMediaInfo(DataSource, MediaInfo)\n"
    },
    "getDurationRaw()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getDurationRaw()",
      "documentation": "Retrieves the current duration without doing the state checking that the emulated version does.\n\n@return The duration of the current clip loaded by the player.\n"
    },
    "getHandler()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.os.Handler",
      "exceptions": [],
      "name": "getHandler()",
      "documentation": "Retrieves the {@link Handler} object used by this {@code ShadowMediaPlayer}. Can be used for\nposting custom asynchronous events to the thread (eg, asynchronous errors). Use this for\nscheduling events to take place at a particular \"real\" time (ie, time as measured by the\nscheduler). For scheduling events to occur at a particular playback offset (no matter how long\nplayback may be paused for, or where you seek to, etc), see {@link\nMediaInfo#scheduleEventAtOffset(int, ShadowMediaPlayer.MediaEvent)} and its various helpers.\n\n@return Handler object that can be used to schedule asynchronous events on this media player.\n"
    },
    "getHandler(android.os.Looper)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "looper"
      ],
      "returnType": "android.os.Handler",
      "exceptions": [],
      "name": "getHandler(android.os.Looper)"
    },
    "getInvalidStateBehavior()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior",
      "exceptions": [],
      "name": "getInvalidStateBehavior()",
      "documentation": "Retrieves current flag specifying the behavior of the media player when a method is invoked in\nan invalid state. See {@link #setInvalidStateBehavior(InvalidStateBehavior)} for a discussion\nof the available modes and their associated behaviors.\n\n@return The current invalid state behavior mode.\n@see #setInvalidStateBehavior\n"
    },
    "getLeftVolume()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "float",
      "exceptions": [],
      "name": "getLeftVolume()",
      "documentation": "Retrieves the current setting for the left channel volume.\n\n@return The left channel volume.\n"
    },
    "getMediaInfo()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
      "exceptions": [],
      "name": "getMediaInfo()",
      "documentation": "Retrieves the currently selected {@link MediaInfo}. This instance is used to define current\nduration, preparation delay, exceptions for {@code setDataSource()}, playback events, etc.\n\n@return The currently selected {@link MediaInfo}.\n@see #addMediaInfo\n@see #setMediaInfoProvider\n@see #doSetDataSource(DataSource)\n"
    },
    "getMediaInfo(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
      "exceptions": [],
      "name": "getMediaInfo(org.robolectric.shadows.util.DataSource)"
    },
    "getOnCompletionListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.media.MediaPlayer.OnCompletionListener",
      "exceptions": [],
      "name": "getOnCompletionListener()",
      "documentation": "@return the OnCompletionListener "
    },
    "getOnPreparedListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.media.MediaPlayer.OnPreparedListener",
      "exceptions": [],
      "name": "getOnPreparedListener()",
      "documentation": "@return the OnPreparedListener "
    },
    "getPendingSeek()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getPendingSeek()",
      "documentation": "Retrieves the pending seek setting.\n\n@return The position to which the shadow player is seeking for the seek in progress (ie, after\n    the call to {@link #seekTo} but before a call to {@link #invokeSeekCompleteListener()}).\n    Returns {@code -1} if no seek is in progress.\n"
    },
    "getRightVolume()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "float",
      "exceptions": [],
      "name": "getRightVolume()",
      "documentation": "@return The right channel volume. "
    },
    "getSeekDelay()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getSeekDelay()",
      "documentation": "@return seekDelay "
    },
    "getSourceResId()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getSourceResId()",
      "documentation": "Retrieves the resource ID used in the call to {@link #create(Context, int)} (if any).\n\n@return The resource ID passed in to {@code create()}, or {@code -1} if a different method of\n    setting the source was used.\n"
    },
    "getSourceUri()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.net.Uri",
      "exceptions": [],
      "name": "getSourceUri()",
      "documentation": "Retrieves the source path (if any) that was passed in to {@link\nMediaPlayer#setDataSource(Context, Uri, Map)} or {@link MediaPlayer#setDataSource(Context,\nUri)}.\n\n@return The source Uri passed in to {@code setDataSource}.\n"
    },
    "getState()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.State",
      "exceptions": [],
      "name": "getState()",
      "documentation": "Retrieves the current state of the {@link MediaPlayer}. Uses the states as defined in the\n{@link MediaPlayer} documentation.\n\n@return The current state of the {@link MediaPlayer}, as defined in the MediaPlayer\n    documentation.\n@see #setState\n@see MediaPlayer\n"
    },
    "getTheAudioStreamType()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getTheAudioStreamType()",
      "documentation": "Note: This has a funny name at the moment to avoid having to produce an API-specific shadow -\nif it were called {@code getAudioStreamType()} then the {@code RobolectricWiringTest} will\ninform us that it should be annotated with {@link Implementation}, because there is a private\nmethod in the later API versions with the same name, however this would fail on earlier\nversions.\n\n@return audioStreamType\n"
    },
    "getVideoHeight()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getVideoHeight()"
    },
    "getVideoWidth()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getVideoWidth()"
    },
    "invokeCompletionListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeCompletionListener()",
      "documentation": "Simulates end-of-playback. Changes the player into PLAYBACK_COMPLETED state and calls {@link\nMediaPlayer.OnCompletionListener#onCompletion(MediaPlayer) onCompletion()} if a listener has\nbeen set.\n"
    },
    "invokeErrorListener(int,int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "what",
        "extra"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeErrorListener(int,int)",
      "documentation": "Allows test cases to directly simulate invocation of the OnError event.\n\n@param what parameter to pass in to {@code what} in {@link\n    MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int)}.\n@param extra parameter to pass in to {@code extra} in {@link\n    MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int)}.\n"
    },
    "invokeInfoListener(int,int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "what",
        "extra"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeInfoListener(int,int)",
      "documentation": "Allows test cases to directly simulate invocation of the OnInfo event.\n\n@param what parameter to pass in to {@code what} in {@link\n    MediaPlayer.OnInfoListener#onInfo(MediaPlayer, int, int)}.\n@param extra parameter to pass in to {@code extra} in {@link\n    MediaPlayer.OnInfoListener#onInfo(MediaPlayer, int, int)}.\n"
    },
    "invokePreparedListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokePreparedListener()",
      "documentation": "Allows test cases to simulate \u0027prepared\u0027 state by invoking callback. Sets the player\u0027s state to\nPREPARED and invokes the {@link MediaPlayer.OnPreparedListener#onPrepared preparedListener()}\n"
    },
    "invokeSeekCompleteListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeSeekCompleteListener()",
      "documentation": "Allows test cases to simulate seek completion by invoking callback. "
    },
    "isLooping()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isLooping()"
    },
    "isPlaying()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isPlaying()"
    },
    "isPrepared()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isPrepared()",
      "documentation": "Tests to see if the player is in the PREPARED state. This is mainly used for backward\ncompatibility. {@link #getState} may be more useful for new testing applications.\n\n@return {@code true} if the MediaPlayer is in the PREPARED state, false otherwise.\n"
    },
    "isReallyPlaying()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isReallyPlaying()",
      "documentation": "Tests to see if the player is really playing.\n\n\u003cp\u003eThe player is defined as \"really playing\" if simulated playback events (including playback\ncompletion) are being scheduled and invoked and {@link #getCurrentPosition currentPosition} is\nbeing updated as time passes. Note that while the player will normally be really playing if in\nthe STARTED state, this is not always the case - for example, if a pending seek is in progress,\nor perhaps a buffer underrun is being simulated.\n\n@return {@code true} if the player is really playing or {@code false} if the player is\n    internally paused.\n@see #doStart\n@see #doStop\n"
    },
    "native_setOutputDevice(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "preferredDeviceId"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 28,
      "name": "native_setOutputDevice(int)"
    },
    "postEvent(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "postEvent(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent)"
    },
    "postEventDelayed(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "e",
        "delay"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "postEventDelayed(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent,long)"
    },
    "prepare()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "prepare()",
      "documentation": "Simulates {@link MediaPlayer#prepareAsync()}. Sleeps for {@link MediaInfo#getPreparationDelay()\npreparationDelay} ms by calling {@link SystemClock#sleep(long)} before calling {@link\n#invokePreparedListener()}.\n\n\u003cp\u003eIf {@code preparationDelay} is not positive and non-zero, there is no sleep.\n\n@see MediaInfo#setPreparationDelay(int)\n@see #invokePreparedListener()\n"
    },
    "prepareAsync()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "prepareAsync()",
      "documentation": "Simulates {@link MediaPlayer#prepareAsync()}. Sets state to PREPARING and posts a callback to\n{@link #invokePreparedListener()} if the current preparation delay for the current media (see\n{@link #getMediaInfo()}) is \u0026gt;\u003d 0, otherwise the test suite is responsible for calling {@link\n#invokePreparedListener()} directly if required.\n\n@see MediaInfo#setPreparationDelay(int)\n@see #invokePreparedListener()\n"
    },
    "resetStaticState()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "resetStaticState()"
    },
    "scheduleNextPlaybackEvent()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "scheduleNextPlaybackEvent()"
    },
    "seekTo(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "seekTo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "seekTo(int)",
      "documentation": "Simulates seeking to specified position. The seek will complete after {@link #seekDelay} ms\n(defaults to 0), or else if seekDelay is negative then the controlling test is expected to\nsimulate seek completion by manually invoking {@link #invokeSeekCompleteListener}.\n\n@param seekTo the offset (in ms) from the start of the track to seek to.\n"
    },
    "seekTo(long,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "seekTo",
        "mode"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 26,
      "name": "seekTo(long,int)"
    },
    "setAudioSessionId(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "sessionId"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setAudioSessionId(int)"
    },
    "setAudioStreamType(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "audioStreamType"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setAudioStreamType(int)"
    },
    "setCreateListener(org.robolectric.shadows.ShadowMediaPlayer.CreateListener)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "createListener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCreateListener(org.robolectric.shadows.ShadowMediaPlayer.CreateListener)",
      "documentation": "Sets a listener that is invoked whenever a new shadowed {@link MediaPlayer} object is\nconstructed.\n\n\u003cp\u003eRegistering a listener gives you a chance to customize the shadowed object appropriately\nwithout needing to modify the application-under-test to provide access to the instance at the\nappropriate point in its life cycle. This is useful because normally a new {@link MediaPlayer}\nis created and {@link #setDataSource setDataSource()} is invoked soon after, without a break in\nthe code. Using this callback means you don\u0027t have to change this common pattern just so that\nyou can customize the shadow for testing.\n\n@param createListener the listener to be invoked\n"
    },
    "setCurrentPosition(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "position"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCurrentPosition(int)",
      "documentation": "Sets the current position, bypassing the normal state checking. Use with care.\n\n@param position the new playback position.\n"
    },
    "setDataSource(android.content.Context,android.net.Uri)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "maxSdk": 25,
      "name": "setDataSource(android.content.Context,android.net.Uri)"
    },
    "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri",
        "headers"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "maxSdk": 25,
      "name": "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)"
    },
    "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e,java.util.List\u003cjava.net.HttpCookie\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri",
        "headers",
        "cookies"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 26,
      "name": "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e,java.util.List\u003cjava.net.HttpCookie\u003e)"
    },
    "setDataSource(android.content.res.AssetFileDescriptor)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "assetFileDescriptor"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 24,
      "name": "setDataSource(android.content.res.AssetFileDescriptor)"
    },
    "setDataSource(android.media.MediaDataSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "mediaDataSource"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 23,
      "name": "setDataSource(android.media.MediaDataSource)"
    },
    "setDataSource(java.io.FileDescriptor,long,long)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "fd",
        "offset",
        "length"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.io.FileDescriptor,long,long)"
    },
    "setDataSource(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "path"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.lang.String)"
    },
    "setDataSource(java.lang.String,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "uri",
        "headers"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.lang.String,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)"
    },
    "setDataSource(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(org.robolectric.shadows.util.DataSource)",
      "documentation": "Common code path for all {@code setDataSource()} implementations.\n\n\u003cp\u003e* Checks for any specified exceptions for the specified data source and throws them. *\nChecks the current state and throws an exception if it is in an invalid state. * If no\nexception is thrown in either of the previous two steps, then {@link\n#doSetDataSource(DataSource)} is called to set the data source. * Sets the player state to\n{@code INITIALIZED}. Usually this method would not be called directly, but indirectly through\none of the other {@link #setDataSource(String)} implementations, which use {@link\nDataSource#toDataSource(String)} methods to convert their discrete parameters into a single\n{@link DataSource} instance.\n\n@param dataSource the data source that is being set.\n@throws IOException if the specified data source has been configured to throw an IO exception.\n@see #addException(DataSource, IOException)\n@see #addException(DataSource, RuntimeException)\n@see #doSetDataSource(DataSource)\n"
    },
    "setInvalidStateBehavior(org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "invalidStateBehavior"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setInvalidStateBehavior(org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior)",
      "documentation": "Specifies how the media player should behave when a method is invoked in an invalid state.\nThree modes are supported (as defined by the {@link InvalidStateBehavior} enum):\n\n\u003ch3\u003e{@link InvalidStateBehavior#SILENT SILENT}\u003c/h3\u003e\n\nNo invalid state checking is done at all. All methods can be invoked from any state without\nthrowing any exceptions or invoking the error listener.\n\n\u003cp\u003eThis mode is provided primarily for backwards compatibility, and for this reason it is the\ndefault. For proper testing one of the other two modes is probably preferable.\n\n\u003ch3\u003e{@link InvalidStateBehavior#EMULATE EMULATE}\u003c/h3\u003e\n\nThe shadow will attempt to emulate the behavior of the actual {@link MediaPlayer}\nimplementation. This is based on a reading of the documentation and on actual experiments done\non a Jelly Bean device. The official documentation is not all that clear, but basically methods\nfall into three categories:\n\n\u003cul\u003e\n  \u003cli\u003eThose that log an error when invoked in an invalid state but don\u0027t throw an exception or\n      invoke {@code onError()}. An example is {@link #getVideoHeight()}.\n  \u003cli\u003eSynchronous error handling: methods always throw an exception (usually {@link\n      IllegalStateException} but don\u0027t invoke {@code onError()}. Examples are {@link\n      #prepare()} and {@link #setDataSource(String)}.\n  \u003cli\u003eAsynchronous error handling: methods don\u0027t throw an exception but invoke {@code\n      onError()}.\n\u003c/ul\u003e\n\nAdditionally, all three methods behave synchronously (throwing {@link IllegalStateException}\nwhen invoked from the END state.\n\n\u003cp\u003eTo complicate matters slightly, the official documentation sometimes contradicts observed\nbehavior. For example, the documentation says it is illegal to call {@link #setDataSource} from\nthe ERROR state - however, in practice it works fine. Conversely, the documentation says that\nit is legal to invoke {@link #getCurrentPosition()} from the INITIALIZED state, however testing\nshowed that this caused an error. Wherever there is a discrepancy between documented and\nobserved behavior, this implementation has gone with the most conservative implementation (ie,\nit is illegal to invoke {@link #setDataSource} from the ERROR state and likewise illegal to\ninvoke {@link #getCurrentPosition()} from the INITIALIZED state.\n\n\u003ch3\u003e{@link InvalidStateBehavior#ASSERT ASSERT}\u003c/h3\u003e\n\nThe shadow will raise an assertion any time that a method is invoked in an invalid state. The\nphilosophy behind this mode is that to invoke a method in an invalid state is a programming\nerror - a bug, pure and simple. As such it should be discovered and eliminated at development\nand testing time, rather than anticipated and handled at runtime. Asserting is a way of testing\nfor these bugs during testing.\n\n@param invalidStateBehavior the behavior mode for this shadow to use during testing.\n@see #getInvalidStateBehavior()\n"
    },
    "setLooping(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "looping"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLooping(boolean)"
    },
    "setMediaInfoProvider(org.robolectric.shadows.ShadowMediaPlayer.MediaInfoProvider)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "mediaInfoProvider"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setMediaInfoProvider(org.robolectric.shadows.ShadowMediaPlayer.MediaInfoProvider)",
      "documentation": "Sets a {@link MediaInfoProvider} to be used to get {@link MediaInfo} for any {@link\nDataSource}.\n\n\u003cp\u003eThis overrides any {@link MediaInfo} previously set by calling {@link #addMediaInfo}, i.e.,\n{@link MediaInfo} provided by this {@link MediaInfoProvider} will be used instead.\n"
    },
    "setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)"
    },
    "setOnErrorListener(android.media.MediaPlayer.OnErrorListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnErrorListener(android.media.MediaPlayer.OnErrorListener)"
    },
    "setOnInfoListener(android.media.MediaPlayer.OnInfoListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnInfoListener(android.media.MediaPlayer.OnInfoListener)"
    },
    "setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)"
    },
    "setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)"
    },
    "setSeekDelay(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "seekDelay"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setSeekDelay(int)",
      "documentation": "Sets the length of time (ms) that seekTo() will delay before completing. Default is 0. If set\nto -1, then seekTo() will not call the OnSeekCompleteListener automatically; you will need to\ncall invokeSeekCompleteListener() manually.\n\n@param seekDelay length of time to delay (ms)\n"
    },
    "setState(org.robolectric.shadows.ShadowMediaPlayer.State)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "state"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setState(org.robolectric.shadows.ShadowMediaPlayer.State)",
      "documentation": "Forces the @link MediaPlayer} into the specified state. Uses the states as defined in the\n{@link MediaPlayer} documentation.\n\n\u003cp\u003eNote that by invoking this method directly you can get the player into an inconsistent state\nthat a real player could not be put in (eg, in the END state but with playback events still\nhappening). Use with care.\n\n@param state the new state of the {@link MediaPlayer}, as defined in the MediaPlayer\n    documentation.\n@see #getState\n@see MediaPlayer\n"
    },
    "setVolume(float,float)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "left",
        "right"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setVolume(float,float)"
    },
    "start()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "start()",
      "documentation": "Simulates private native method {@link MediaPlayer#_start()}. Sets state to STARTED and calls\n{@link #doStart()} to start scheduling playback callback events.\n\n\u003cp\u003eIf the current state is PLAYBACK_COMPLETED, the current position is reset to zero before\nstarting playback.\n\n@see #doStart()\n"
    }
  },
  "imports": [
    "android.os.Build.VERSION_CODES.M",
    "android.os.Build.VERSION_CODES.N",
    "android.os.Build.VERSION_CODES.N_MR1",
    "android.os.Build.VERSION_CODES.O",
    "android.os.Build.VERSION_CODES.P",
    "org.robolectric.shadows.ShadowMediaPlayer.State.END",
    "org.robolectric.shadows.ShadowMediaPlayer.State.ERROR",
    "org.robolectric.shadows.ShadowMediaPlayer.State.IDLE",
    "org.robolectric.shadows.ShadowMediaPlayer.State.INITIALIZED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PAUSED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PLAYBACK_COMPLETED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PREPARED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PREPARING",
    "org.robolectric.shadows.ShadowMediaPlayer.State.STARTED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.STOPPED",
    "org.robolectric.shadows.util.DataSource.toDataSource",
    "android.content.Context",
    "android.content.res.AssetFileDescriptor",
    "android.media.MediaDataSource",
    "android.media.MediaPlayer",
    "android.net.Uri",
    "android.os.Handler",
    "android.os.Looper",
    "android.os.Message",
    "android.os.SystemClock",
    "java.io.FileDescriptor",
    "java.io.IOException",
    "java.net.HttpCookie",
    "java.util.ArrayList",
    "java.util.EnumSet",
    "java.util.HashMap",
    "java.util.Iterator",
    "java.util.List",
    "java.util.Map",
    "java.util.Map.Entry",
    "java.util.Optional",
    "java.util.Random",
    "java.util.TreeMap",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.shadows.util.DataSource",
    "org.robolectric.shadows.ShadowMediaPlayer.MediaInfoProvider",
    "org.robolectric.shadows.ShadowMediaPlayer.State",
    "org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior",
    "org.robolectric.shadows.ShadowMediaPlayer.RunList",
    "org.robolectric.shadows.ShadowMediaPlayer.MediaEvent",
    "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
    "org.robolectric.shadows.ShadowMediaPlayer.CreateListener",
    "org.robolectric.shadows.ShadowMediaPlayer.ErrorCallback"
  ],
  "name": "org.robolectric.shadows.ShadowMediaPlayer",
  "documentation": "Automated testing of media playback can be a difficult thing - especially testing that your code\nproperly handles asynchronous errors and events. This near impossible task is made quite\nstraightforward using this implementation of {@link MediaPlayer} with Robolectric.\n\n\u003cp\u003eThis shadow implementation provides much of the functionality needed to emulate {@link\nMediaPlayer} initialization and playback behavior without having to play actual media files. A\nsummary of the features included are:\n\n\u003cul\u003e\n  \u003cli\u003eConstruction-time callback hook {@link CreateListener} so that newly-created {@link\n      MediaPlayer} instances can have their shadows configured before they are used.\n  \u003cli\u003eEmulation of the {@link android.media.MediaPlayer.OnCompletionListener\n      OnCompletionListener}, {@link android.media.MediaPlayer.OnErrorListener OnErrorListener},\n      {@link android.media.MediaPlayer.OnInfoListener OnInfoListener}, {@link\n      android.media.MediaPlayer.OnPreparedListener OnPreparedListener} and {@link\n      android.media.MediaPlayer.OnSeekCompleteListener OnSeekCompleteListener}.\n  \u003cli\u003eFull support of the {@link MediaPlayer} internal states and their transition map.\n  \u003cli\u003eConfigure time parameters such as playback duration, preparation delay and {@link\n      #setSeekDelay(int)}.\n  \u003cli\u003eEmulation of asynchronous callback events during playback through Robolectric\u0027s scheduling\n      system using the {@link MediaInfo} inner class.\n  \u003cli\u003eEmulation of error behavior when methods are called from invalid states, or to throw\n      assertions when methods are invoked in invalid states (using {@link\n      #setInvalidStateBehavior}).\n  \u003cli\u003eEmulation of different playback behaviors based on the current data source, as passed in to\n      {@link #setDataSource(String) setDataSource()}, using {@link #addMediaInfo} or {@link\n      #setMediaInfoProvider(MediaInfoProvider)}.\n  \u003cli\u003eEmulation of exceptions when calling {@link #setDataSource} using {@link #addException}.\n\u003c/ul\u003e\n\n\u003cb\u003eNote\u003c/b\u003e: One gotcha with this shadow is that you need to either configure an exception using\n{@link #addException(DataSource, IOException)} or a {@link ShadowMediaPlayer.MediaInfo} instance\nfor that data source using {@link #addMediaInfo(DataSource, MediaInfo)} or {@link\n#setMediaInfoProvider(MediaInfoProvider)} \u003ci\u003ebefore\u003c/i\u003e calling {@link #setDataSource}, otherwise\nyou\u0027ll get an {@link IllegalArgumentException}.\n\n\u003cp\u003eThe current features of {@code ShadowMediaPlayer} were focused on development for testing\nplayback of audio tracks. Thus support for emulating timed text and video events is incomplete.\nNone of these features would be particularly onerous to add/fix - contributions welcome, of\ncourse!\n\n@author Fr Jeremy Krieg, Holy Monastery of St Nectarios, Adelaide, Australia\n"
}