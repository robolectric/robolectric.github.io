{
  "methods": {
    "__constructor__()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "__constructor__()"
    },
    "__staticInitializer__()": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "__staticInitializer__()"
    },
    "_pause()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_pause()",
      "documentation": "Simulates {@link MediaPlayer#_pause()}. Invokes {@link #doStop()} to suspend playback event\ncallbacks and sets the state to PAUSED.\n\n@see #doStop()\n"
    },
    "_release()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_release()",
      "documentation": "Simulates call to {@link MediaPlayer#_release()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to END.\n"
    },
    "_reset()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_reset()",
      "documentation": "Simulates call to {@link MediaPlayer#_reset()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to IDLE.\n"
    },
    "_stop()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "_stop()",
      "documentation": "Simulates call to {@link MediaPlayer#release()}. Calls {@link #doStop()} to suspend playback\nevent callbacks and sets the state to STOPPED.\n"
    },
    "addException(org.robolectric.shadows.util.DataSource,java.io.IOException)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addException(org.robolectric.shadows.util.DataSource,java.io.IOException)"
    },
    "addException(org.robolectric.shadows.util.DataSource,java.lang.RuntimeException)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addException(org.robolectric.shadows.util.DataSource,java.lang.RuntimeException)"
    },
    "addMediaInfo(org.robolectric.shadows.util.DataSource,org.robolectric.shadows.ShadowMediaPlayer.MediaInfo)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addMediaInfo(org.robolectric.shadows.util.DataSource,org.robolectric.shadows.ShadowMediaPlayer.MediaInfo)"
    },
    "attachAuxEffect(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "effectId"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "attachAuxEffect(int)"
    },
    "checkStateError(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "checkStateError(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that asynchronously invoke\n{@link android.media.MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int)\nonError()} when invoked in an illegal state. Such methods always throw\n{@link IllegalStateException} rather than invoke {@code onError()} if\nthey are invoked from the END state.\n\nThis method will either emulate this behavior by posting an\n{@code onError()} callback to the current thread\u0027s message queue (or\nthrow an {@link IllegalStateException} if invoked from the END state), or\nelse it will generate an assertion if {@link #setAssertOnError\nassertOnError} is set.\n\n@param method\n         the name of the method being tested.\n@param allowedStates\n         the states that this method is allowed to be called from.\n@see #getHandler\n@see #setAssertOnError\n@see #checkStateLog(String, EnumSet)\n@see #checkStateException(String, EnumSet)\n"
    },
    "checkStateException(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "checkStateException(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that synchronously throw an exception when\ninvoked in an illegal state. This method will likewise throw an\n{@link IllegalArgumentException} if it determines that the method has been\ninvoked from a disallowed state, or else it will generate an assertion if\n{@link #setAssertOnError assertOnError} is set.\n\n@param method\n         the name of the method being tested.\n@param allowedStates\n         the states that this method is allowed to be called from.\n@see #setAssertOnError\n@see #checkStateLog(String, EnumSet)\n@see #checkStateError(String, EnumSet)\n"
    },
    "checkStateLog(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "method",
        "allowedStates"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "checkStateLog(java.lang.String,java.util.EnumSet\u003corg.robolectric.shadows.ShadowMediaPlayer.State\u003e)",
      "documentation": "Checks states for methods that only log when there is an error. Such\nmethods throw an {@link IllegalArgumentException} when invoked in the END\nstate, but log an error in other disallowed states. This method will either\nemulate this behavior or else will generate an assertion if invoked from a\ndisallowed state if {@link #setAssertOnError assertOnError} is set.\n\n@param method\n         the name of the method being tested.\n@param allowedStates\n         the states that this method is allowed to be called from.\n@see #setAssertOnError\n@see #checkStateError(String, EnumSet)\n@see #checkStateException(String, EnumSet)\n"
    },
    "create(android.content.Context,android.net.Uri)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "uri"
      ],
      "returnType": "android.media.MediaPlayer",
      "exceptions": [],
      "name": "create(android.content.Context,android.net.Uri)"
    },
    "create(android.content.Context,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "resId"
      ],
      "returnType": "android.media.MediaPlayer",
      "exceptions": [],
      "name": "create(android.content.Context,int)"
    },
    "doSetDataSource(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "doSetDataSource(org.robolectric.shadows.util.DataSource)",
      "documentation": "Sets the data source without doing any other emulation. Sets the internal data source only.\nCalling directly can be useful for setting up a {@link ShadowMediaPlayer} instance during\nspecific testing so that you don\u0027t have to clutter your tests catching exceptions you know\nwon\u0027t be thrown.\n\n@param dataSource the data source that is being set.\n@see #setDataSource(DataSource)\n"
    },
    "doStart()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doStart()",
      "documentation": "Starts simulated playback. Until this method is called, the player is not\n\"really playing\" (see {@link #isReallyPlaying} for a definition of\n\"really playing\").\n\nThis method is used internally by the various shadow method implementations\nof the MediaPlayer public API, but may also be called directly by the test\nsuite if you wish to simulate an internal pause. For example, to simulate\na buffer underrun (player is in PLAYING state but isn\u0027t actually advancing\nthe current position through the media), you could call {@link #doStop()} to\nmark the start of the buffer underrun and {@link #doStart()} to mark its\nend and restart normal playback (which is what\n{@link ShadowMediaPlayer.MediaInfo#scheduleBufferUnderrunAtOffset(int, int) scheduleBufferUnderrunAtOffset()}\ndoes).\n\n@see #isReallyPlaying()\n@see #doStop()\n"
    },
    "doStop()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doStop()",
      "documentation": "Pauses simulated playback. After this method is called, the player is no\nlonger \"really playing\" (see {@link #isReallyPlaying} for a definition of\n\"really playing\").\n\nThis method is used internally by the various shadow method implementations\nof the MediaPlayer public API, but may also be called directly by the test\nsuite if you wish to simulate an internal pause.\n\n@see #isReallyPlaying()\n@see #doStart()\n"
    },
    "getAudioSessionId()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getAudioSessionId()"
    },
    "getAuxEffect()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getAuxEffect()",
      "documentation": "Useful for assertions.\n\n@return The current {@code auxEffect} setting.\n"
    },
    "getCurrentPosition()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getCurrentPosition()",
      "documentation": "Simulates call to {@link MediaPlayer#getCurrentPosition()}. Simply does the state validity\nchecks and then invokes {@link #getCurrentPositionRaw()} to calculate the simulated playback\nposition.\n\n@return The current offset (in ms) of the simulated playback.\n@see #getCurrentPositionRaw()\n"
    },
    "getCurrentPositionRaw()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getCurrentPositionRaw()",
      "documentation": "Retrieves the current position without doing the state checking that the\nemulated version of {@link #getCurrentPosition()} does.\n\n@return The current playback position within the current clip.\n"
    },
    "getDataSource()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.util.DataSource",
      "exceptions": [],
      "name": "getDataSource()",
      "documentation": "Retrieves the data source (if any) that was passed in to\n{@link #setDataSource(DataSource)}.\n\nUseful for assertions.\n\n@return The source passed in to {@code setDataSource}.\n"
    },
    "getDuration()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getDuration()",
      "documentation": "Simulates call to {@link MediaPlayer#getDuration()}. Retrieves the duration as defined by the\ncurrent {@link MediaInfo} instance.\n\n@return The duration (in ms) of the current simulated playback.\n@see #addMediaInfo(DataSource, MediaInfo)\n"
    },
    "getDurationRaw()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getDurationRaw()",
      "documentation": "Retrieves the current duration without doing the state checking that the\nemulated version does.\n\n@return The duration of the current clip loaded by the player.\n"
    },
    "getHandler()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.os.Handler",
      "exceptions": [],
      "name": "getHandler()",
      "documentation": "Retrieves the {@link Handler} object used by this\n{@code ShadowMediaPlayer}. Can be used for posting custom asynchronous\nevents to the thread (eg, asynchronous errors). Use this for scheduling\nevents to take place at a particular \"real\" time (ie, time as measured by\nthe scheduler). For scheduling events to occur at a particular playback\noffset (no matter how long playback may be paused for, or where you seek\nto, etc), see {@link MediaInfo#scheduleEventAtOffset(int, ShadowMediaPlayer.MediaEvent)} and\nits various helpers.\n\n@return Handler object that can be used to schedule asynchronous events on\n        this media player.\n"
    },
    "getHandler(android.os.Looper)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "looper"
      ],
      "returnType": "android.os.Handler",
      "exceptions": [],
      "name": "getHandler(android.os.Looper)"
    },
    "getInvalidStateBehavior()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior",
      "exceptions": [],
      "name": "getInvalidStateBehavior()",
      "documentation": "Retrieves current flag specifying the behavior of the media player when a\nmethod is invoked in an invalid state. See\n{@link #setInvalidStateBehavior(InvalidStateBehavior)} for a discussion of\nthe available modes and their associated behaviors.\n\n@return The current invalid state behavior mode.\n@see #setInvalidStateBehavior\n"
    },
    "getLeftVolume()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "float",
      "exceptions": [],
      "name": "getLeftVolume()",
      "documentation": "Retrieves the current setting for the left channel volume.\n\n@return The left channel volume.\n"
    },
    "getMediaInfo()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
      "exceptions": [],
      "name": "getMediaInfo()",
      "documentation": "Retrieves the currently selected {@link MediaInfo}. This instance is used\nto define current duration, preparation delay, exceptions for\n{@code setDataSource()}, playback events, etc.\n\n@return The currently selected {@link MediaInfo}.\n@see #addMediaInfo\n@see #doSetDataSource(DataSource)\n"
    },
    "getMediaInfo(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
      "exceptions": [],
      "name": "getMediaInfo(org.robolectric.shadows.util.DataSource)"
    },
    "getOnCompletionListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.media.MediaPlayer.OnCompletionListener",
      "exceptions": [],
      "name": "getOnCompletionListener()",
      "documentation": "@return the OnCompletionListener\n"
    },
    "getOnPreparedListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.media.MediaPlayer.OnPreparedListener",
      "exceptions": [],
      "name": "getOnPreparedListener()",
      "documentation": "@return the OnPreparedListener\n"
    },
    "getPendingSeek()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getPendingSeek()",
      "documentation": "Retrieves the pending seek setting.\n\n@return The position to which the shadow player is seeking for the seek in\n        progress (ie, after the call to {@link #seekTo} but before a call\n        to {@link #invokeSeekCompleteListener()}). Returns {@code -1}\n        if no seek is in progress.\n"
    },
    "getRightVolume()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "float",
      "exceptions": [],
      "name": "getRightVolume()",
      "documentation": "@return The right channel volume.\n"
    },
    "getSeekDelay()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getSeekDelay()",
      "documentation": "@return seekDelay\n"
    },
    "getSourceResId()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getSourceResId()",
      "documentation": "Retrieves the resource ID used in the call to {@link #create(Context, int)}\n(if any).\n\n@return The resource ID passed in to {@code create()}, or\n        {@code -1} if a different method of setting the source was\n        used.\n"
    },
    "getSourceUri()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.net.Uri",
      "exceptions": [],
      "name": "getSourceUri()",
      "documentation": "Retrieves the source path (if any) that was passed in to\n{@link MediaPlayer#setDataSource(Context, Uri, Map)} or\n{@link MediaPlayer#setDataSource(Context, Uri)}.\n\n@return The source Uri passed in to {@code setDataSource}.\n"
    },
    "getState()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowMediaPlayer.State",
      "exceptions": [],
      "name": "getState()",
      "documentation": "Retrieves the current state of the {@link MediaPlayer}. Uses the states as\ndefined in the {@link MediaPlayer} documentation.\n\n@return The current state of the {@link MediaPlayer}, as defined in the\n        MediaPlayer documentation.\n@see #setState\n@see MediaPlayer\n"
    },
    "getTheAudioStreamType()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getTheAudioStreamType()",
      "documentation": "Note: This has a funny name at the\nmoment to avoid having to produce an API-specific shadow -\nif it were called {@code getAudioStreamType()} then\nthe {@code RobolectricWiringTest} will inform us that\nit should be annotated with {@link Implementation}, because\nthere is a private method in the later API versions with\nthe same name, however this would fail on earlier versions.\n\n@return audioStreamType\n"
    },
    "getVideoHeight()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getVideoHeight()"
    },
    "getVideoWidth()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getVideoWidth()"
    },
    "invokeCompletionListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeCompletionListener()",
      "documentation": "Simulates end-of-playback. Changes the player into PLAYBACK_COMPLETED state\nand calls\n{@link MediaPlayer.OnCompletionListener#onCompletion(MediaPlayer)\nonCompletion()} if a listener has been set.\n"
    },
    "invokeErrorListener(int,int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "what",
        "extra"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeErrorListener(int,int)",
      "documentation": "Allows test cases to directly simulate invocation of the OnError event.\n\n@param what\n         parameter to pass in to {@code what} in\n         {@link MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int)}.\n@param extra\n         parameter to pass in to {@code extra} in\n         {@link MediaPlayer.OnErrorListener#onError(MediaPlayer, int, int)}.\n"
    },
    "invokeInfoListener(int,int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "what",
        "extra"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeInfoListener(int,int)",
      "documentation": "Allows test cases to directly simulate invocation of the OnInfo event.\n\n@param what\n         parameter to pass in to {@code what} in\n         {@link MediaPlayer.OnInfoListener#onInfo(MediaPlayer, int, int)}.\n@param extra\n         parameter to pass in to {@code extra} in\n         {@link MediaPlayer.OnInfoListener#onInfo(MediaPlayer, int, int)}.\n"
    },
    "invokePreparedListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokePreparedListener()",
      "documentation": "Allows test cases to simulate \u0027prepared\u0027 state by invoking callback. Sets\nthe player\u0027s state to PREPARED and invokes the\n{@link MediaPlayer.OnPreparedListener#onPrepared preparedListener()}\n"
    },
    "invokeSeekCompleteListener()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "invokeSeekCompleteListener()",
      "documentation": "Allows test cases to simulate seek completion by invoking callback.\n"
    },
    "isLooping()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isLooping()"
    },
    "isPlaying()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isPlaying()"
    },
    "isPrepared()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isPrepared()",
      "documentation": "Tests to see if the player is in the PREPARED state.\nThis is mainly used for backward compatibility.\n{@link #getState} may be more useful for new testing applications.\n\n@return {@code true} if the MediaPlayer is in the PREPARED state,\n        false otherwise.\n"
    },
    "isReallyPlaying()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isReallyPlaying()",
      "documentation": "Tests to see if the player is really playing.\n\nThe player is defined as \"really playing\" if simulated playback events\n(including playback completion) are being scheduled and invoked and\n{@link #getCurrentPosition currentPosition} is being updated as time\npasses. Note that while the player will normally be really playing if in\nthe STARTED state, this is not always the case - for example, if a pending\nseek is in progress, or perhaps a buffer underrun is being simulated.\n\n@return {@code true} if the player is really playing or\n        {@code false} if the player is internally paused.\n@see #doStart\n@see #doStop\n"
    },
    "postEvent(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "e"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "postEvent(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent)"
    },
    "postEventDelayed(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "e",
        "delay"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "postEventDelayed(org.robolectric.shadows.ShadowMediaPlayer.MediaEvent,long)"
    },
    "prepare()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "prepare()",
      "documentation": "Simulates {@link MediaPlayer#prepareAsync()}. Sleeps for {@link MediaInfo#getPreparationDelay()\npreparationDelay} ms by calling {@link SystemClock#sleep(long)} before calling {@link\n#invokePreparedListener()}.\n\n\u003cp\u003eIf {@code preparationDelay} is not positive and non-zero, there is no sleep.\n\n@see MediaInfo#setPreparationDelay(int)\n@see #invokePreparedListener()\n"
    },
    "prepareAsync()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "prepareAsync()",
      "documentation": "Simulates {@link MediaPlayer#prepareAsync()}. Sets state to PREPARING and posts a callback to\n{@link #invokePreparedListener()} if the current preparation delay for the current media (see\n{@link #getMediaInfo()}) is \u0026gt;\u003d 0, otherwise the test suite is responsible for calling {@link\n#invokePreparedListener()} directly if required.\n\n@see MediaInfo#setPreparationDelay(int)\n@see #invokePreparedListener()\n"
    },
    "resetStaticState()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "resetStaticState()"
    },
    "scheduleNextPlaybackEvent()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "scheduleNextPlaybackEvent()"
    },
    "seekTo(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "seekTo"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "seekTo(int)",
      "documentation": "Simulates seeking to specified position. The seek will complete after {@link #seekDelay} ms\n(defaults to 0), or else if seekDelay is negative then the controlling test is expected to\nsimulate seek completion by manually invoking {@link #invokeSeekCompleteListener}.\n\n@param seekTo the offset (in ms) from the start of the track to seek to.\n"
    },
    "seekTo(long,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "seekTo",
        "mode"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 26,
      "name": "seekTo(long,int)"
    },
    "setAudioSessionId(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "sessionId"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setAudioSessionId(int)"
    },
    "setAudioStreamType(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "audioStreamType"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setAudioStreamType(int)"
    },
    "setCreateListener(org.robolectric.shadows.ShadowMediaPlayer.CreateListener)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "createListener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCreateListener(org.robolectric.shadows.ShadowMediaPlayer.CreateListener)",
      "documentation": "Sets a listener that is invoked whenever a new shadowed {@link MediaPlayer}\nobject is constructed.\n\nRegistering a listener gives you a chance to\ncustomize the shadowed object appropriately without needing to modify the\napplication-under-test to provide access to the instance at the appropriate\npoint in its life cycle. This is useful because normally a new\n{@link MediaPlayer} is created and {@link #setDataSource setDataSource()}\nis invoked soon after, without a break in the code. Using this callback\nmeans you don\u0027t have to change this common pattern just so that you can\ncustomize the shadow for testing.\n\n@param createListener\n         the listener to be invoked\n"
    },
    "setCurrentPosition(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "position"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCurrentPosition(int)",
      "documentation": "Sets the current position, bypassing the normal state checking. Use with\ncare.\n\n@param position\n         the new playback position.\n"
    },
    "setDataSource(android.content.Context,android.net.Uri)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "maxSdk": 25,
      "name": "setDataSource(android.content.Context,android.net.Uri)"
    },
    "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri",
        "headers"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 14,
      "maxSdk": 25,
      "name": "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)"
    },
    "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e,java.util.List\u003cjava.net.HttpCookie\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "uri",
        "headers",
        "cookies"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 26,
      "name": "setDataSource(android.content.Context,android.net.Uri,java.util.Map\u003cjava.lang.String,java.lang.String\u003e,java.util.List\u003cjava.net.HttpCookie\u003e)"
    },
    "setDataSource(android.media.MediaDataSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "mediaDataSource"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 23,
      "name": "setDataSource(android.media.MediaDataSource)"
    },
    "setDataSource(java.io.FileDescriptor,long,long)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "fd",
        "offset",
        "length"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.io.FileDescriptor,long,long)"
    },
    "setDataSource(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "path"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.lang.String)"
    },
    "setDataSource(java.lang.String,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "uri",
        "headers"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(java.lang.String,java.util.Map\u003cjava.lang.String,java.lang.String\u003e)"
    },
    "setDataSource(org.robolectric.shadows.util.DataSource)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "dataSource"
      ],
      "returnType": "void",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "setDataSource(org.robolectric.shadows.util.DataSource)",
      "documentation": "Common code path for all {@code setDataSource()} implementations.\n\n\u003cp\u003e* Checks for any specified exceptions for the specified data source and throws them. *\nChecks the current state and throws an exception if it is in an invalid state. * If no\nexception is thrown in either of the previous two steps, then {@link\n#doSetDataSource(DataSource)} is called to set the data source. * Sets the player state to\n{@code INITIALIZED}. Usually this method would not be called directly, but indirectly through\none of the other {@link #setDataSource(String)} implementations, which use {@link\nDataSource#toDataSource(String)} methods to convert their discrete parameters into a single\n{@link DataSource} instance.\n\n@param dataSource the data source that is being set.\n@throws IOException if the specified data source has been configured to throw an IO exception.\n@see #addException(DataSource, IOException)\n@see #addException(DataSource, RuntimeException)\n@see #doSetDataSource(DataSource)\n"
    },
    "setInvalidStateBehavior(org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "invalidStateBehavior"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setInvalidStateBehavior(org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior)",
      "documentation": "Specifies how the media player should behave when a method is invoked in an invalid state.\nThree modes are supported (as defined by the {@link InvalidStateBehavior} enum):\n\n\u003ch3\u003e{@link InvalidStateBehavior#SILENT SILENT}\u003c/h3\u003e\n\nNo invalid state checking is done at all. All methods can be invoked from any state without\nthrowing any exceptions or invoking the error listener.\n\n\u003cp\u003eThis mode is provided primarily for backwards compatibility, and for this reason it is the\ndefault. For proper testing one of the other two modes is probably preferable.\n\n\u003ch3\u003e{@link InvalidStateBehavior#EMULATE EMULATE}\u003c/h3\u003e\n\nThe shadow will attempt to emulate the behavior of the actual {@link MediaPlayer}\nimplementation. This is based on a reading of the documentation and on actual experiments done\non a Jelly Bean device. The official documentation is not all that clear, but basically methods\nfall into three categories:\n\n\u003cul\u003e\n  \u003cli\u003eThose that log an error when invoked in an invalid state but don\u0027t throw an exception or\n      invoke {@code onError()}. An example is {@link #getVideoHeight()}.\n  \u003cli\u003eSynchronous error handling: methods always throw an exception (usually {@link\n      IllegalStateException} but don\u0027t invoke {@code onError()}. Examples are {@link\n      #prepare()} and {@link #setDataSource(String)}.\n  \u003cli\u003eAsynchronous error handling: methods don\u0027t throw an exception but invoke {@code\n      onError()}.\n\u003c/ul\u003e\n\nAdditionally, all three methods behave synchronously (throwing {@link IllegalStateException}\nwhen invoked from the END state.\n\n\u003cp\u003eTo complicate matters slightly, the official documentation sometimes contradicts observed\nbehavior. For example, the documentation says it is illegal to call {@link #setDataSource} from\nthe ERROR state - however, in practice it works fine. Conversely, the documentation says that\nit is legal to invoke {@link #getCurrentPosition()} from the INITIALIZED state, however testing\nshowed that this caused an error. Wherever there is a discrepancy between documented and\nobserved behavior, this implementation has gone with the most conservative implementation (ie,\nit is illegal to invoke {@link #setDataSource} from the ERROR state and likewise illegal to\ninvoke {@link #getCurrentPosition()} from the INITIALIZED state.\n\n\u003ch3\u003e{@link InvalidStateBehavior#ASSERT ASSERT}\u003c/h3\u003e\n\nThe shadow will raise an assertion any time that a method is invoked in an invalid state. The\nphilosophy behind this mode is that to invoke a method in an invalid state is a programming\nerror - a bug, pure and simple. As such it should be discovered and eliminated at development\nand testing time, rather than anticipated and handled at runtime. Asserting is a way of testing\nfor these bugs during testing.\n\n@param invalidStateBehavior the behavior mode for this shadow to use during testing.\n@see #getInvalidStateBehavior()\n"
    },
    "setLooping(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "looping"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLooping(boolean)"
    },
    "setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)"
    },
    "setOnErrorListener(android.media.MediaPlayer.OnErrorListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnErrorListener(android.media.MediaPlayer.OnErrorListener)"
    },
    "setOnInfoListener(android.media.MediaPlayer.OnInfoListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnInfoListener(android.media.MediaPlayer.OnInfoListener)"
    },
    "setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)"
    },
    "setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)"
    },
    "setSeekDelay(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "seekDelay"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setSeekDelay(int)",
      "documentation": "Sets the length of time (ms) that seekTo() will delay before completing.\nDefault is 0. If set to -1, then seekTo() will not call the\nOnSeekCompleteListener automatically; you will need to call\ninvokeSeekCompleteListener() manually.\n\n@param seekDelay\n         length of time to delay (ms)\n"
    },
    "setState(org.robolectric.shadows.ShadowMediaPlayer.State)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "state"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setState(org.robolectric.shadows.ShadowMediaPlayer.State)",
      "documentation": "Forces the @link MediaPlayer} into the specified state. Uses the states as\ndefined in the {@link MediaPlayer} documentation.\n\nNote that by invoking this method directly you can get the player into an\ninconsistent state that a real player could not be put in (eg, in the END\nstate but with playback events still happening). Use with care.\n\n@param state\n         the new state of the {@link MediaPlayer}, as defined in the\n         MediaPlayer documentation.\n@see #getState\n@see MediaPlayer\n"
    },
    "setVolume(float,float)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "left",
        "right"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setVolume(float,float)"
    },
    "start()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "start()",
      "documentation": "Simulates private native method {@link MediaPlayer#_start()}. Sets state to STARTED and calls\n{@link #doStart()} to start scheduling playback callback events.\n\n\u003cp\u003eIf the current state is PLAYBACK_COMPLETED, the current position is reset to zero before\nstarting playback.\n\n@see #doStart()\n"
    }
  },
  "imports": [
    "android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH",
    "android.os.Build.VERSION_CODES.M",
    "android.os.Build.VERSION_CODES.N_MR1",
    "android.os.Build.VERSION_CODES.O",
    "org.robolectric.shadows.ShadowMediaPlayer.State.END",
    "org.robolectric.shadows.ShadowMediaPlayer.State.ERROR",
    "org.robolectric.shadows.ShadowMediaPlayer.State.IDLE",
    "org.robolectric.shadows.ShadowMediaPlayer.State.INITIALIZED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PAUSED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PLAYBACK_COMPLETED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PREPARED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.PREPARING",
    "org.robolectric.shadows.ShadowMediaPlayer.State.STARTED",
    "org.robolectric.shadows.ShadowMediaPlayer.State.STOPPED",
    "org.robolectric.shadows.util.DataSource.toDataSource",
    "android.content.Context",
    "android.media.MediaDataSource",
    "android.media.MediaPlayer",
    "android.net.Uri",
    "android.os.Handler",
    "android.os.Looper",
    "android.os.Message",
    "android.os.SystemClock",
    "java.io.FileDescriptor",
    "java.io.IOException",
    "java.net.HttpCookie",
    "java.util.ArrayList",
    "java.util.EnumSet",
    "java.util.HashMap",
    "java.util.Iterator",
    "java.util.List",
    "java.util.Map",
    "java.util.Map.Entry",
    "java.util.Random",
    "java.util.TreeMap",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.shadows.util.DataSource",
    "org.robolectric.shadows.ShadowMediaPlayer.State",
    "org.robolectric.shadows.ShadowMediaPlayer.InvalidStateBehavior",
    "org.robolectric.shadows.ShadowMediaPlayer.RunList",
    "org.robolectric.shadows.ShadowMediaPlayer.MediaEvent",
    "org.robolectric.shadows.ShadowMediaPlayer.MediaInfo",
    "org.robolectric.shadows.ShadowMediaPlayer.CreateListener",
    "org.robolectric.shadows.ShadowMediaPlayer.ErrorCallback"
  ],
  "name": "org.robolectric.shadows.ShadowMediaPlayer",
  "documentation": "Automated testing of media playback can be a difficult thing - especially testing that your code\nproperly handles asynchronous errors and events. This near impossible task is made quite\nstraightforward using this implementation of {@link MediaPlayer} with Robolectric.\n\n\u003cp\u003eThis shadow implementation provides much of the functionality needed to emulate {@link\nMediaPlayer} initialization and playback behavior without having to play actual media files. A\nsummary of the features included are:\n\n\u003cul\u003e\n  \u003cli\u003eConstruction-time callback hook {@link CreateListener} so that newly-created {@link\n      MediaPlayer} instances can have their shadows configured before they are used.\n  \u003cli\u003eEmulation of the {@link android.media.MediaPlayer.OnCompletionListener\n      OnCompletionListener}, {@link android.media.MediaPlayer.OnErrorListener OnErrorListener},\n      {@link android.media.MediaPlayer.OnInfoListener OnInfoListener}, {@link\n      android.media.MediaPlayer.OnPreparedListener OnPreparedListener} and {@link\n      android.media.MediaPlayer.OnSeekCompleteListener OnSeekCompleteListener}.\n  \u003cli\u003eFull support of the {@link MediaPlayer} internal states and their transition map.\n  \u003cli\u003eConfigure time parameters such as playback duration, preparation delay and {@link\n      #setSeekDelay(int)}.\n  \u003cli\u003eEmulation of asynchronous callback events during playback through Robolectric\u0027s scheduling\n      system using the {@link MediaInfo} inner class.\n  \u003cli\u003eEmulation of error behavior when methods are called from invalid states, or to throw\n      assertions when methods are invoked in invalid states (using {@link\n      #setInvalidStateBehavior}).\n  \u003cli\u003eEmulation of different playback behaviors based on the current data source, as passed in to\n      {@link #setDataSource(String) setDataSource()}, using {@link #addMediaInfo}.\n  \u003cli\u003eEmulation of exceptions when calling {@link #setDataSource} using {@link #addException}.\n\u003c/ul\u003e\n\n\u003cb\u003eNote\u003c/b\u003e: One gotcha with this shadow is that you need to either configure an exception or a\n{@link ShadowMediaPlayer.MediaInfo} instance for that data source (using {@link\n#addException(DataSource, IOException)} or {@link #addMediaInfo(DataSource, MediaInfo)}\nrespectively) \u003ci\u003ebefore\u003c/i\u003e calling {@link #setDataSource}, otherwise you\u0027ll get an {@link\nIllegalArgumentException}.\n\n\u003cp\u003eThe current features of {@code ShadowMediaPlayer} were focused on development for testing\nplayback of audio tracks. Thus support for emulating timed text and video events is incomplete.\nNone of these features would be particularly onerous to add/fix - contributions welcome, of\ncourse!\n\n@author Fr Jeremy Krieg, Holy Monastery of St Nectarios, Adelaide, Australia\n"
}