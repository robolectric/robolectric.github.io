{
  "methods": {
    "checkForBluetoothConnectPermission()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "checkForBluetoothConnectPermission()"
    },
    "checkPermission(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "static"
      ],
      "params": [
        "permission"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "checkPermission(java.lang.String)"
    },
    "connectGatt(android.bluetooth.BluetoothGattCallback)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "callback"
      ],
      "returnType": "android.bluetooth.BluetoothGatt",
      "exceptions": [],
      "name": "connectGatt(android.bluetooth.BluetoothGattCallback)"
    },
    "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "autoConnect",
        "callback"
      ],
      "returnType": "android.bluetooth.BluetoothGatt",
      "exceptions": [],
      "name": "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback)"
    },
    "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "autoConnect",
        "callback",
        "transport"
      ],
      "returnType": "android.bluetooth.BluetoothGatt",
      "exceptions": [],
      "minSdk": 23,
      "name": "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int)"
    },
    "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int,int,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "autoConnect",
        "callback",
        "transport",
        "phy",
        "handler"
      ],
      "returnType": "android.bluetooth.BluetoothGatt",
      "exceptions": [],
      "minSdk": 26,
      "name": "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int,int,android.os.Handler)"
    },
    "createBond()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "createBond()",
      "documentation": "Returns whether this device has been bonded with. "
    },
    "createInsecureL2capChannel(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "psm"
      ],
      "returnType": "android.bluetooth.BluetoothSocket",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 29,
      "name": "createInsecureL2capChannel(int)"
    },
    "createL2capChannel(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "psm"
      ],
      "returnType": "android.bluetooth.BluetoothSocket",
      "exceptions": [
        "java.io.IOException"
      ],
      "minSdk": 29,
      "name": "createL2capChannel(int)"
    },
    "createRfcommSocketToServiceRecord(java.util.UUID)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "uuid"
      ],
      "returnType": "android.bluetooth.BluetoothSocket",
      "exceptions": [
        "java.io.IOException"
      ],
      "name": "createRfcommSocketToServiceRecord(java.util.UUID)"
    },
    "fetchUuidsWithSdp()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "fetchUuidsWithSdp()",
      "documentation": "Overrides behavior of {@link BluetoothDevice#fetchUuidsWithSdp}. This method updates the\ncounter which counts the number of invocations of this method.\n\n@returns Value set by calling {@link ShadowBluetoothDevice#setFetchUuidsWithSdpResult}. If not\n    previously set, will return false by default.\n"
    },
    "getAlias()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getAlias()"
    },
    "getAliasName()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [
        "java.lang.ReflectiveOperationException"
      ],
      "maxSdk": 29,
      "name": "getAliasName()"
    },
    "getBatteryLevel()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "minSdk": 27,
      "name": "getBatteryLevel()"
    },
    "getBluetoothClass()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.bluetooth.BluetoothClass",
      "exceptions": [],
      "name": "getBluetoothClass()",
      "documentation": "Overrides behavior of {@link BluetoothDevice#getBluetoothClass} to return pre-set result.\n\n@return Value set by calling {@link ShadowBluetoothDevice#setBluetoothClass}. If setType has\n    not previously been called, will return null.\n"
    },
    "getBluetoothGatts()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.bluetooth.BluetoothGatt\u003e",
      "exceptions": [],
      "name": "getBluetoothGatts()",
      "documentation": "Returns all {@link BluetoothGatt} objects created by calling {@link\nShadowBluetoothDevice#connectGatt}.\n"
    },
    "getBondState()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getBondState()",
      "documentation": "Overrides behavior of {@link BluetoothDevice#getBondState} to return pre-set result.\n\n@returns Value set by calling {@link ShadowBluetoothDevice#setBondState}. If setBondState has\n    not previously been called, will return {@link BluetoothDevice#BOND_NONE} to indicate the\n    device is not bonded.\n"
    },
    "getFetchUuidsWithSdpCount()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getFetchUuidsWithSdpCount()",
      "documentation": "Returns the number of times fetchUuidsWithSdp has been called. "
    },
    "getMetadata(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "key"
      ],
      "returnType": "byte[]",
      "exceptions": [],
      "minSdk": 29,
      "name": "getMetadata(int)"
    },
    "getName()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getName()"
    },
    "getPairingConfirmation()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.lang.Boolean",
      "exceptions": [],
      "name": "getPairingConfirmation()",
      "documentation": "Get the confirmation value previously set with a call to {@link\nBluetoothDevice#setPairingConfirmation(boolean)}, or null if no value is set.\n"
    },
    "getPin()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "byte[]",
      "exceptions": [],
      "name": "getPin()",
      "documentation": "Get the PIN previously set with a call to {@link BluetoothDevice#setPin(byte[])}, or null if no\nPIN has been set.\n"
    },
    "getService()": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [],
      "returnType": "android.bluetooth.IBluetooth",
      "exceptions": [],
      "name": "getService()",
      "documentation": "Implements getService() in the same way the original method does, but ignores any Exceptions\nfrom invoking {@link android.bluetooth.BluetoothAdapter#getBluetoothService}.\n"
    },
    "getShadowInstrumentation()": {
      "isImplementation": false,
      "modifiers": [
        "static"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowInstrumentation",
      "exceptions": [],
      "name": "getShadowInstrumentation()"
    },
    "getType()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getType()",
      "documentation": "Overrides behavior of {@link BluetoothDevice#getType} to return pre-set result.\n\n@return Value set by calling {@link ShadowBluetoothDevice#setType}. If setType has not\n    previously been called, will return BluetoothDevice.DEVICE_TYPE_UNKNOWN.\n"
    },
    "getUuids()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "android.os.ParcelUuid[]",
      "exceptions": [],
      "name": "getUuids()",
      "documentation": "Overrides behavior of {@link BluetoothDevice#getUuids} to return pre-set result.\n\n@return Value set by calling {@link ShadowBluetoothDevice#setUuids}. If setUuids has not\n    previously been called, will return null.\n"
    },
    "isConnected()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 20,
      "name": "isConnected()"
    },
    "isInSilenceMode()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 29,
      "name": "isInSilenceMode()"
    },
    "newInstance(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "address"
      ],
      "returnType": "android.bluetooth.BluetoothDevice",
      "exceptions": [],
      "name": "newInstance(java.lang.String)"
    },
    "removeBond()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "removeBond()"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "setAlias(java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "alias"
      ],
      "returnType": "java.lang.Object",
      "exceptions": [],
      "name": "setAlias(java.lang.Object)",
      "documentation": "Sets the alias name of the device.\n\n\u003cp\u003eAlias is the locally modified name of a remote device.\n\n\u003cp\u003eAlias Name is not part of the supported SDK, and accessed via reflection.\n\n@param alias alias name.\n"
    },
    "setBatteryLevel(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "batteryLevel"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setBatteryLevel(int)"
    },
    "setBluetoothClass(android.bluetooth.BluetoothClass)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "bluetoothClass"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setBluetoothClass(android.bluetooth.BluetoothClass)",
      "documentation": "Sets the return value for {@link BluetoothDevice#getBluetoothClass}. "
    },
    "setBondState(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "bondState"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setBondState(int)",
      "documentation": "Sets value of bond state for {@link BluetoothDevice#getBondState}. "
    },
    "setConnected(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "isConnected"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setConnected(boolean)"
    },
    "setCreatedBond(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "createdBond"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCreatedBond(boolean)",
      "documentation": "Sets whether this device has been bonded with. "
    },
    "setFetchUuidsWithSdpResult(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "fetchUuidsWithSdpResult"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setFetchUuidsWithSdpResult(boolean)",
      "documentation": "Sets value of the return result for {@link BluetoothDevice#fetchUuidsWithSdp}. "
    },
    "setGattConnectionInterceptor(org.robolectric.shadows.ShadowBluetoothDevice.BluetoothGattConnectionInterceptor)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "interceptor"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setGattConnectionInterceptor(org.robolectric.shadows.ShadowBluetoothDevice.BluetoothGattConnectionInterceptor)",
      "documentation": "Allows tests to intercept the {@link BluetoothDevice.connectGatt} method and set state on both\nBluetoothDevice and BluetoothGatt objects. This is useful for e2e testing situations where the\nfine-grained execution of Bluetooth connection logic is onerous.\n"
    },
    "setMetadata(int,byte[])": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "key",
        "value"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 29,
      "name": "setMetadata(int,byte[])"
    },
    "setName(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "name"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setName(java.lang.String)"
    },
    "setPairingConfirmation(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "confirm"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "setPairingConfirmation(boolean)"
    },
    "setPin(byte[])": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "pin"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "setPin(byte[])"
    },
    "setShouldThrowSecurityExceptions(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "shouldThrow"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setShouldThrowSecurityExceptions(boolean)",
      "documentation": "Sets if a runtime exception is thrown when bluetooth methods with BLUETOOTH_CONNECT permission\npre-requisites are accessed.\n\n\u003cp\u003eIntended to replicate what may happen if user has not enabled nearby device permissions.\n\n@param shouldThrow if methods should throw SecurityExceptions without enabled permissions when\n    called.\n"
    },
    "setSilenceMode(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "isInSilenceMode"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 29,
      "name": "setSilenceMode(boolean)"
    },
    "setThrowOnGetAliasName(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "shouldThrow"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setThrowOnGetAliasName(boolean)",
      "documentation": "Sets if a runtime exception is thrown when the alias name of the device is accessed.\n\n\u003cp\u003eIntended to replicate what may happen if the unsupported SDK is changed.\n\n\u003cp\u003eAlias is the locally modified name of a remote device.\n\n\u003cp\u003eAlias Name is not part of the supported SDK, and accessed via reflection.\n\n@param shouldThrow if getAliasName() should throw when called.\n"
    },
    "setType(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "type"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setType(int)",
      "documentation": "Sets the return value for {@link BluetoothDevice#getType}. "
    },
    "setUuids(android.os.ParcelUuid[])": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "uuids"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setUuids(android.os.ParcelUuid[])",
      "documentation": "Sets the return value for {@link BluetoothDevice#getUuids}. "
    },
    "simulateGattConnectionChange(int,int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "status",
        "newState"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateGattConnectionChange(int,int)",
      "documentation": "Causes {@link BluetoothGattCallback#onConnectionStateChange to be called for every GATT client.\n@param status Status of the GATT operation\n@param newState The new state of the GATT profile\n"
    }
  },
  "imports": [
    "android.bluetooth.BluetoothDevice.BOND_NONE",
    "android.content.pm.PackageManager.PERMISSION_GRANTED",
    "android.os.Build.VERSION_CODES.KITKAT_WATCH",
    "android.os.Build.VERSION_CODES.M",
    "android.os.Build.VERSION_CODES.O",
    "android.os.Build.VERSION_CODES.O_MR1",
    "android.os.Build.VERSION_CODES.Q",
    "android.os.Build.VERSION_CODES.S",
    "org.robolectric.util.reflector.Reflector.reflector",
    "android.annotation.IntRange",
    "android.app.ActivityThread",
    "android.bluetooth.BluetoothClass",
    "android.bluetooth.BluetoothDevice",
    "android.bluetooth.BluetoothGatt",
    "android.bluetooth.BluetoothGattCallback",
    "android.bluetooth.BluetoothSocket",
    "android.bluetooth.BluetoothStatusCodes",
    "android.bluetooth.IBluetooth",
    "android.content.Context",
    "android.os.Build.VERSION",
    "android.os.Handler",
    "android.os.ParcelUuid",
    "java.io.IOException",
    "java.util.ArrayList",
    "java.util.HashMap",
    "java.util.List",
    "java.util.Map",
    "java.util.UUID",
    "javax.annotation.Nullable",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.util.ReflectionHelpers",
    "org.robolectric.util.reflector.Direct",
    "org.robolectric.util.reflector.ForType",
    "org.robolectric.util.reflector.Static",
    "org.robolectric.shadows.ShadowBluetoothDevice.BluetoothGattConnectionInterceptor",
    "org.robolectric.shadows.ShadowBluetoothDevice.BluetoothDeviceReflector"
  ],
  "name": "org.robolectric.shadows.ShadowBluetoothDevice",
  "documentation": "Shadow for {@link BluetoothDevice}. "
}