{
  "methods": {
    "__constructor__(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "quitAllowed"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "__constructor__(boolean)"
    },
    "doLoop()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "doLoop()"
    },
    "getLooperForThread(java.lang.Thread)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "thread"
      ],
      "returnType": "android.os.Looper",
      "exceptions": [],
      "name": "getLooperForThread(java.lang.Thread)"
    },
    "getMainLooper()": {
      "isImplementation": true,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "android.os.Looper",
      "exceptions": [],
      "name": "getMainLooper()"
    },
    "getScheduler()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.util.Scheduler",
      "exceptions": [],
      "name": "getScheduler()",
      "documentation": "Returns the {@link org.robolectric.util.Scheduler} that is being used to manage the enqueued tasks.\nThis scheduler is managed by the Looper\u0027s associated queue.\n\n@return the {@link org.robolectric.util.Scheduler} that is being used to manage the enqueued tasks.\n"
    },
    "getShadowMainLooper()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowLooper",
      "exceptions": [],
      "name": "getShadowMainLooper()"
    },
    "hasQuit()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "hasQuit()"
    },
    "idle()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "idle()",
      "documentation": "Causes {@link Runnable}s that have been scheduled to run immediately to actually run. Does not advance the\nscheduler\u0027s clock;\n"
    },
    "idle(long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intervalMillis"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idle(long)",
      "documentation": "Causes {@link Runnable}s that have been scheduled to run within the next {@code intervalMillis} milliseconds to\nrun while advancing the scheduler\u0027s clock.\n\n@deprecated Use {@link #idle(long, TimeUnit)}.\n"
    },
    "idle(long,java.util.concurrent.TimeUnit)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "amount",
        "unit"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idle(long,java.util.concurrent.TimeUnit)",
      "documentation": "Causes {@link Runnable}s that have been scheduled to run within the next specified amount of time to run while\nadvancing the scheduler\u0027s clock.\n"
    },
    "idleConstantly(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "shouldIdleConstantly"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idleConstantly(boolean)"
    },
    "idleMainLooper()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "idleMainLooper()"
    },
    "idleMainLooper(long)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "interval"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idleMainLooper(long)",
      "documentation": "@deprecated Use {@link #idleMainLooper(long, TimeUnit)}. "
    },
    "idleMainLooper(long,java.util.concurrent.TimeUnit)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "amount",
        "unit"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idleMainLooper(long,java.util.concurrent.TimeUnit)"
    },
    "idleMainLooperConstantly(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "shouldIdleConstantly"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "idleMainLooperConstantly(boolean)"
    },
    "isPaused()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isPaused()"
    },
    "loop()": {
      "isImplementation": true,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "loop()"
    },
    "myLooper()": {
      "isImplementation": true,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "android.os.Looper",
      "exceptions": [],
      "name": "myLooper()"
    },
    "pause()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "pause()"
    },
    "pauseLooper(android.os.Looper)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "pauseLooper(android.os.Looper)"
    },
    "pauseMainLooper()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "pauseMainLooper()"
    },
    "post(java.lang.Runnable,long)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "runnable",
        "delayMillis"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "post(java.lang.Runnable,long)",
      "documentation": "Enqueue a task to be run later.\n\n@param runnable    the task to be run\n@param delayMillis how many milliseconds into the (virtual) future to run it\n@return true if the runnable is enqueued\n@see android.os.Handler#postDelayed(Runnable,long)\n@deprecated Use a {@link android.os.Handler} instance to post to a looper.\n"
    },
    "postAtFrontOfQueue(java.lang.Runnable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "runnable"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "postAtFrontOfQueue(java.lang.Runnable)",
      "documentation": "Enqueue a task to be run ahead of all other delayed tasks.\n\n@param runnable    the task to be run\n@return true if the runnable is enqueued\n@see android.os.Handler#postAtFrontOfQueue(Runnable)\n@deprecated Use a {@link android.os.Handler} instance to post to a looper.\n"
    },
    "quit()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "quit()"
    },
    "quitSafely()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 18,
      "name": "quitSafely()"
    },
    "quitUnchecked()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "quitUnchecked()"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()",
      "documentation": "Causes all enqueued tasks to be discarded, and pause state to be reset\n"
    },
    "resetScheduler()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "resetScheduler()"
    },
    "resetThreadLoopers()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static",
        "synchronized"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "resetThreadLoopers()"
    },
    "runMainLooperOneTask()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runMainLooperOneTask()"
    },
    "runMainLooperToNextTask()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runMainLooperToNextTask()"
    },
    "runOneTask()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runOneTask()",
      "documentation": "Causes only one of the next {@link Runnable}s that have been scheduled to run while advancing the scheduler\u0027s\nclock to its start time. Only one {@link Runnable} will run even if more than one has ben scheduled to run at the\nsame time.\n"
    },
    "runPaused(java.lang.Runnable)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "r"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "runPaused(java.lang.Runnable)"
    },
    "runToEndOfTasks()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runToEndOfTasks()",
      "documentation": "Causes all of the {@link Runnable}s that have been scheduled to run while advancing the scheduler\u0027s clock to the\nstart time of the last scheduled {@link Runnable}.\n"
    },
    "runToNextTask()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runToNextTask()",
      "documentation": "Causes the next {@link Runnable}(s) that have been scheduled to run while advancing the scheduler\u0027s clock to its\nstart time. If more than one {@link Runnable} is scheduled to run at this time then they will all be run.\n"
    },
    "runUiThreadTasks()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runUiThreadTasks()",
      "documentation": "Runs any immediately runnable tasks previously queued on the UI thread,\ne.g. by {@link android.app.Activity#runOnUiThread(Runnable)} or {@link android.os.AsyncTask#onPostExecute(Object)}.\n\n**Note:** calling this method does not pause or un-pause the scheduler.\n\n@see #runUiThreadTasksIncludingDelayedTasks\n"
    },
    "runUiThreadTasksIncludingDelayedTasks()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "runUiThreadTasksIncludingDelayedTasks()",
      "documentation": "Runs all runnable tasks (pending and future) that have been queued on the UI thread. Such tasks may be queued by\ne.g. {@link android.app.Activity#runOnUiThread(Runnable)} or {@link android.os.AsyncTask#onPostExecute(Object)}.\n\n**Note:** calling this method does not pause or un-pause the scheduler, however the clock is advanced as\nfuture tasks are run.\n\n@see #runUiThreadTasks\n"
    },
    "setPaused(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "shouldPause"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "setPaused(boolean)"
    },
    "shadowOf(android.os.Looper)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "looper"
      ],
      "returnType": "org.robolectric.shadows.ShadowLooper",
      "exceptions": [],
      "name": "shadowOf(android.os.Looper)"
    },
    "shadowOf(android.os.MessageQueue)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "mq"
      ],
      "returnType": "org.robolectric.shadows.ShadowMessageQueue",
      "exceptions": [],
      "name": "shadowOf(android.os.MessageQueue)"
    },
    "unPause()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "unPause()"
    },
    "unPauseLooper(android.os.Looper)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "unPauseLooper(android.os.Looper)"
    },
    "unPauseMainLooper()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "unPauseMainLooper()"
    }
  },
  "imports": [
    "android.os.Build.VERSION_CODES.JELLY_BEAN_MR2",
    "org.robolectric.RuntimeEnvironment.isMainThread",
    "org.robolectric.shadow.api.Shadow.invokeConstructor",
    "org.robolectric.util.ReflectionHelpers.ClassParameter.from",
    "android.os.Looper",
    "android.os.MessageQueue",
    "java.util.Collections",
    "java.util.Map",
    "java.util.WeakHashMap",
    "java.util.concurrent.TimeUnit",
    "org.robolectric.RoboSettings",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.util.Scheduler"
  ],
  "name": "org.robolectric.shadows.ShadowLooper",
  "documentation": "Robolectric enqueues posted {@link Runnable}s to be run\n(on this thread) later. {@code Runnable}s that are scheduled to run immediately can be\ntriggered by calling {@link #idle()}.\n\n@see ShadowMessageQueue\n"
}