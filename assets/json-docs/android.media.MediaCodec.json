{
  "methods": {
    "__constructor__(java.lang.String,boolean,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "name",
        "nameIsType",
        "encoder"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "__constructor__(java.lang.String,boolean,boolean)"
    },
    "addDecoder(java.lang.String,org.robolectric.shadows.ShadowMediaCodec.CodecConfig)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "type",
        "config"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addDecoder(java.lang.String,org.robolectric.shadows.ShadowMediaCodec.CodecConfig)",
      "documentation": "Add a fake decoding codec to the Shadow. "
    },
    "addEncoder(java.lang.String,org.robolectric.shadows.ShadowMediaCodec.CodecConfig)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "type",
        "config"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addEncoder(java.lang.String,org.robolectric.shadows.ShadowMediaCodec.CodecConfig)",
      "documentation": "Add a fake encoding codec to the Shadow. "
    },
    "clearCodecs()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "clearCodecs()",
      "documentation": "Clears any previously added encoders and decoders. "
    },
    "codecOwnsInputBuffer(int)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "index"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "codecOwnsInputBuffer(int)"
    },
    "configure(java.lang.String[],java.lang.Object[])": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "keys",
        "values"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "configure(java.lang.String[],java.lang.Object[])"
    },
    "copyBufferInfo(android.media.MediaCodec.BufferInfo,android.media.MediaCodec.BufferInfo)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "from",
        "to"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "copyBufferInfo(android.media.MediaCodec.BufferInfo,android.media.MediaCodec.BufferInfo)"
    },
    "freeByteBuffer(java.nio.ByteBuffer)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffer"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "freeByteBuffer(java.nio.ByteBuffer)",
      "documentation": "Prevents attempting to free non-direct ByteBuffer objects. "
    },
    "getBuffer(boolean,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "input",
        "index"
      ],
      "returnType": "java.nio.ByteBuffer",
      "exceptions": [],
      "minSdk": 21,
      "name": "getBuffer(boolean,int)",
      "documentation": "Returns the input or output buffer corresponding to the given index, or null if invalid. "
    },
    "getBuffers(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "input"
      ],
      "returnType": "java.nio.ByteBuffer[]",
      "exceptions": [],
      "name": "getBuffers(boolean)",
      "documentation": "Returns the shadow buffers used for input or output. "
    },
    "getOutputFormat()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "android.media.MediaFormat",
      "exceptions": [],
      "name": "getOutputFormat()",
      "documentation": "Returns a default {@link MediaFormat} if not set via {@link #getOutputFormat()}. "
    },
    "invalidateByteBuffer(java.nio.ByteBuffer[],int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffers",
        "index"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "invalidateByteBuffer(java.nio.ByteBuffer[],int)",
      "documentation": "Prevents calling Android-only methods on basic ByteBuffer objects. "
    },
    "invalidateByteBuffers(java.nio.ByteBuffer[])": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffers"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "invalidateByteBuffers(java.nio.ByteBuffer[])",
      "documentation": "Prevents calling Android-only methods on basic ByteBuffer objects. "
    },
    "makeInputBufferAvailable(int)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "index"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "makeInputBufferAvailable(int)"
    },
    "makeOutputBufferAvailable(int,android.media.MediaCodec.BufferInfo)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "index",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "makeOutputBufferAvailable(int,android.media.MediaCodec.BufferInfo)"
    },
    "native_configure(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "keys",
        "values",
        "surface",
        "crypto",
        "descramblerBinder",
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 26,
      "name": "native_configure(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)"
    },
    "native_configure(java.lang.String[],java.lang.Object[],android.view.Surface,android.media.MediaCrypto,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "keys",
        "values",
        "surface",
        "crypto",
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "maxSdk": 25,
      "name": "native_configure(java.lang.String[],java.lang.Object[],android.view.Surface,android.media.MediaCrypto,int)"
    },
    "native_dequeueInputBuffer(long)": {
      "isImplementation": false,
      "modifiers": [
        "protected"
      ],
      "params": [
        "timeoutUs"
      ],
      "returnType": "int",
      "exceptions": [],
      "name": "native_dequeueInputBuffer(long)"
    },
    "native_dequeueOutputBuffer(android.media.MediaCodec.BufferInfo,long)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "info",
        "timeoutUs"
      ],
      "returnType": "int",
      "exceptions": [],
      "minSdk": 21,
      "name": "native_dequeueOutputBuffer(android.media.MediaCodec.BufferInfo,long)"
    },
    "native_flush()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "native_flush()",
      "documentation": "Flushes the available output buffers. "
    },
    "native_queueInputBuffer(int,int,int,long,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "index",
        "offset",
        "size",
        "presentationTimeUs",
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "native_queueInputBuffer(int,int,int,long,int)",
      "documentation": "Triggers presentation of the corresponding output buffer for the given input buffer, and passes\nthe given metadata as buffer info.\n"
    },
    "native_setCallback(android.media.MediaCodec.Callback)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "callback"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "native_setCallback(android.media.MediaCodec.Callback)",
      "documentation": "Saves the callback to allow use inside the shadow. "
    },
    "native_start()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "native_start()",
      "documentation": "Starts the async encoding process, by first reporting a format change event, and then\npresenting an input buffer to the callback.\n"
    },
    "postFakeNativeEvent(int,int,int,java.lang.Object)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "what",
        "arg1",
        "arg2",
        "obj"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "postFakeNativeEvent(int,int,int,java.lang.Object)"
    },
    "recreateMediaFormatFromKeysValues(java.lang.String[],java.lang.Object[])": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "keys",
        "values"
      ],
      "returnType": "android.media.MediaFormat",
      "exceptions": [],
      "name": "recreateMediaFormatFromKeysValues(java.lang.String[],java.lang.Object[])"
    },
    "revalidateByteBuffer(java.nio.ByteBuffer[],int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffers",
        "index"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "revalidateByteBuffer(java.nio.ByteBuffer[],int)",
      "documentation": "Prevents calling Android-only methods on basic ByteBuffer objects. "
    },
    "throwCodecException(int,int,java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "errorCode",
        "actionCode",
        "message"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "throwCodecException(int,int,java.lang.String)",
      "documentation": "Reflectively throws a {@link CodecException}. "
    },
    "validateInputByteBuffer(java.nio.ByteBuffer[],int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffers",
        "index"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "validateInputByteBuffer(java.nio.ByteBuffer[],int)",
      "documentation": "Prevents calling Android-only methods on basic ByteBuffer objects. "
    },
    "validateOutputByteBuffer(java.nio.ByteBuffer[],int,android.media.MediaCodec.BufferInfo)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "buffers",
        "index",
        "info"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "validateOutputByteBuffer(java.nio.ByteBuffer[],int,android.media.MediaCodec.BufferInfo)",
      "documentation": "Prevents calling Android-only methods on basic ByteBuffer objects. Replicates existing behavior\nadjusting buffer positions and limits.\n"
    }
  },
  "imports": [
    "android.os.Build.VERSION_CODES.JELLY_BEAN",
    "android.os.Build.VERSION_CODES.LOLLIPOP",
    "android.os.Build.VERSION_CODES.N_MR1",
    "android.os.Build.VERSION_CODES.O",
    "com.google.common.base.Preconditions.checkState",
    "org.robolectric.shadow.api.Shadow.invokeConstructor",
    "org.robolectric.util.ReflectionHelpers.callConstructor",
    "android.annotation.NonNull",
    "android.annotation.Nullable",
    "android.media.MediaCodec",
    "android.media.MediaCodec.BufferInfo",
    "android.media.MediaCodec.CodecException",
    "android.media.MediaCrypto",
    "android.media.MediaFormat",
    "android.view.Surface",
    "java.nio.Buffer",
    "java.nio.ByteBuffer",
    "java.nio.ByteOrder",
    "java.util.HashMap",
    "java.util.Map",
    "java.util.concurrent.BlockingQueue",
    "java.util.concurrent.LinkedBlockingDeque",
    "java.util.concurrent.TimeUnit",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.util.ReflectionHelpers",
    "org.robolectric.util.ReflectionHelpers.ClassParameter",
    "org.robolectric.shadows.ShadowMediaCodec.ShadowCodecBuffer",
    "org.robolectric.shadows.ShadowMediaCodec.CodecConfig"
  ],
  "name": "org.robolectric.shadows.ShadowMediaCodec",
  "documentation": "Implementation of {@link android.media.MediaCodec} which supports both asynchronous and\nsynchronous modes.\n\n\u003cp\u003eBy default for any encoded required, a 1 to 1 mapping will be used between the input and\noutput buffers. Data from a queued input buffer will be copied to the output buffer. In the case\nthat is it necessary so simulate some form of data compression, a custom encoder or decoder can\nbe added via {@link #addEncoder(String, CodecConfig)} and {@link #addDecoder(String,\nCodecConfig)} respectively.\n\n\u003cp\u003eAsynchronous mode: Once the codec is started, a format change will be reported, switching to\nan empty {@link android.media.MediaFormat} with fake codec-specific info. Following this, the\nimplementation will present an input buffer, which will be copied to an output buffer once\nqueued, which will be subsequently presented to the callback handler.\n"
}