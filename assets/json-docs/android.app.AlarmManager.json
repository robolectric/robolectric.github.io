{
  "methods": {
    "canScheduleExactAlarms()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "canScheduleExactAlarms()"
    },
    "cancel(android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "cancel(android.app.AlarmManager.OnAlarmListener)"
    },
    "cancel(android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "cancel(android.app.PendingIntent)"
    },
    "cancelAll()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 34,
      "name": "cancelAll()"
    },
    "fireAlarm(org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "alarm"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "fireAlarm(org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm)",
      "documentation": "Immediately removes the given alarm from the list of scheduled alarms (and then reschedules it\nin the case of a repeating alarm) and fires it. The given alarm must on the list of scheduled\nalarms prior to being fired.\n\n\u003cp\u003eGenerally prefer to use {@link ShadowAlarmManager#setAutoSchedule(boolean)} in combination\nwith advancing time on the main Looper in order to test alarms - however this method can be\nuseful to emulate rescheduled, reordered, or delayed alarms, as may happen on a real device.\n"
    },
    "getNextAlarmClock()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "android.app.AlarmManager.AlarmClockInfo",
      "exceptions": [],
      "minSdk": 21,
      "name": "getNextAlarmClock()"
    },
    "getNextScheduledAlarm()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm",
      "exceptions": [],
      "name": "getNextScheduledAlarm()",
      "documentation": "Returns the earliest scheduled alarm and removes it from the list of scheduled alarms.\n\n@deprecated Prefer to use {@link ShadowAlarmManager#setAutoSchedule(boolean)} in combination\n    with incrementing time to actually run alarms and test their side-effects.\n"
    },
    "getScheduledAlarms()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003corg.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm\u003e",
      "exceptions": [],
      "name": "getScheduledAlarms()",
      "documentation": "Returns a list of all scheduled alarms, ordered from earliest time to latest time. "
    },
    "peekNextScheduledAlarm()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm",
      "exceptions": [],
      "name": "peekNextScheduledAlarm()",
      "documentation": "Returns the earliest scheduled alarm. "
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "set(int,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "set(int,long,android.app.PendingIntent)"
    },
    "set(int,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "tag",
        "listener",
        "handler"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "set(int,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)"
    },
    "set(int,long,long,long,android.app.AlarmManager.OnAlarmListener,android.os.Handler,android.os.WorkSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "windowLengthMs",
        "intervalMs",
        "listener",
        "targetHandler",
        "workSource"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "set(int,long,long,long,android.app.AlarmManager.OnAlarmListener,android.os.Handler,android.os.WorkSource)"
    },
    "set(int,long,long,long,android.app.PendingIntent,android.os.WorkSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "windowLengthMs",
        "intervalMs",
        "operation",
        "workSource"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "set(int,long,long,long,android.app.PendingIntent,android.os.WorkSource)"
    },
    "set(int,long,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler,android.os.WorkSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "windowLengthMs",
        "intervalMs",
        "tag",
        "listener",
        "targetHandler",
        "workSource"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "set(int,long,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler,android.os.WorkSource)"
    },
    "setAlarmClock(android.app.AlarmManager.AlarmClockInfo,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "info",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 21,
      "name": "setAlarmClock(android.app.AlarmManager.AlarmClockInfo,android.app.PendingIntent)"
    },
    "setAndAllowWhileIdle(int,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 23,
      "name": "setAndAllowWhileIdle(int,long,android.app.PendingIntent)"
    },
    "setAutoSchedule(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "autoSchedule"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setAutoSchedule(boolean)",
      "documentation": "When set to true, automatically schedules alarms to fire at the appropriate time (with respect\nto the main Looper time) when they are set. This means that a test as below could be expected\nto pass:\n\n\u003cpre\u003e{@code\nshadowOf(alarmManager).setAutoSchedule(true);\nAlarmManager.OnAlarmListener listener \u003d mock(AlarmManager.OnAlarmListener.class);\nalarmManager.setExact(\n  ELAPSED_REALTIME_WAKEUP,\n  SystemClock.elapsedRealtime() + 10,\n  \"tag\",\n  listener,\n  new Handler(Looper.getMainLooper()));\nshadowOf(Looper.getMainLooper()).idleFor(Duration.ofMillis(10));\nverify(listener).onAlarm();\n}\u003c/pre\u003e\n\n\u003cp\u003eAlarms are always scheduled with respect to the trigger/window start time - there is no\nemulation of alarms being reordered, rescheduled, or delayed, as might happen on a real device.\nIf emulating this is necessary, see {@link #fireAlarm(ScheduledAlarm)}.\n\n\u003cp\u003e{@link AlarmManager.OnAlarmListener} alarms will be run on the correct Handler/Executor as\nspecified when the alarm is set.\n"
    },
    "setCanScheduleExactAlarms(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "scheduleExactAlarms"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCanScheduleExactAlarms(boolean)",
      "documentation": "Sets the schedule exact alarm state reported by {@link AlarmManager#canScheduleExactAlarms()},\nbut has no effect otherwise.\n"
    },
    "setExact(int,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setExact(int,long,android.app.PendingIntent)"
    },
    "setExact(int,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtTime",
        "tag",
        "listener",
        "targetHandler"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "setExact(int,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)"
    },
    "setExact(int,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "tag",
        "executor",
        "workSource",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "setExact(int,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)"
    },
    "setExactAndAllowWhileIdle(int,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 23,
      "name": "setExactAndAllowWhileIdle(int,long,android.app.PendingIntent)"
    },
    "setExactAndAllowWhileIdle(int,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "tag",
        "executor",
        "workSource",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 34,
      "name": "setExactAndAllowWhileIdle(int,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)"
    },
    "setImpl(int,long,long,long,android.app.PendingIntent,android.os.WorkSource,java.lang.Object,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "windowLengthMs",
        "intervalMs",
        "operation",
        "workSource",
        "alarmClockInfo",
        "allowWhileIdle"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setImpl(int,long,long,long,android.app.PendingIntent,android.os.WorkSource,java.lang.Object,boolean)"
    },
    "setImpl(int,long,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,java.util.concurrent.Executor,android.os.WorkSource,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "windowLengthMs",
        "intervalMs",
        "tag",
        "listener",
        "executor",
        "workSource",
        "allowWhileIdle"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setImpl(int,long,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,java.util.concurrent.Executor,android.os.WorkSource,boolean)"
    },
    "setInexactRepeating(int,long,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "intervalMillis",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setInexactRepeating(int,long,long,android.app.PendingIntent)"
    },
    "setPrioritized(int,long,long,java.lang.String,java.util.concurrent.Executor,android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "windowStartMs",
        "windowLengthMs",
        "tag",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 31,
      "name": "setPrioritized(int,long,long,java.lang.String,java.util.concurrent.Executor,android.app.AlarmManager.OnAlarmListener)"
    },
    "setRepeating(int,long,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "triggerAtMs",
        "intervalMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setRepeating(int,long,long,android.app.PendingIntent)"
    },
    "setTimeZone(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "timeZone"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setTimeZone(java.lang.String)"
    },
    "setWindow(int,long,long,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "windowStartMs",
        "windowLengthMs",
        "operation"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setWindow(int,long,long,android.app.PendingIntent)"
    },
    "setWindow(int,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "windowStartMs",
        "windowLengthMs",
        "tag",
        "listener",
        "handler"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 24,
      "name": "setWindow(int,long,long,java.lang.String,android.app.AlarmManager.OnAlarmListener,android.os.Handler)"
    },
    "setWindow(int,long,long,java.lang.String,java.util.concurrent.Executor,android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "windowStartMs",
        "windowLengthMs",
        "tag",
        "executor",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 34,
      "name": "setWindow(int,long,long,java.lang.String,java.util.concurrent.Executor,android.app.AlarmManager.OnAlarmListener)"
    },
    "setWindow(int,long,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "type",
        "windowStartMs",
        "windowLengthMs",
        "tag",
        "executor",
        "workSource",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 34,
      "name": "setWindow(int,long,long,java.lang.String,java.util.concurrent.Executor,android.os.WorkSource,android.app.AlarmManager.OnAlarmListener)"
    }
  },
  "imports": [
    "android.app.AlarmManager.RTC_WAKEUP",
    "org.robolectric.util.reflector.Reflector.reflector",
    "android.annotation.Nullable",
    "android.annotation.RequiresApi",
    "android.app.AlarmManager",
    "android.app.AlarmManager.AlarmClockInfo",
    "android.app.AlarmManager.OnAlarmListener",
    "android.app.PendingIntent",
    "android.app.PendingIntent.CanceledException",
    "android.os.Build.VERSION",
    "android.os.Build.VERSION_CODES",
    "android.os.Handler",
    "android.os.Looper",
    "android.os.SystemClock",
    "android.os.WorkSource",
    "com.android.internal.annotations.GuardedBy",
    "com.google.common.collect.Iterables",
    "java.util.ArrayList",
    "java.util.List",
    "java.util.Objects",
    "java.util.PriorityQueue",
    "java.util.TimeZone",
    "java.util.concurrent.Executor",
    "java.util.concurrent.RejectedExecutionException",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.util.reflector.Direct",
    "org.robolectric.util.reflector.ForType",
    "org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm",
    "org.robolectric.shadows.ShadowAlarmManager.InternalScheduledAlarm",
    "org.robolectric.shadows.ShadowAlarmManager.HandlerExecutor",
    "org.robolectric.shadows.ShadowAlarmManager.AlarmManagerReflector"
  ],
  "name": "org.robolectric.shadows.ShadowAlarmManager",
  "documentation": "Shadow for {@link android.app.AlarmManager}. "
}