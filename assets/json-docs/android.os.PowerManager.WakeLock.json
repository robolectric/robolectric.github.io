{
  "methods": {
    "acquire()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "acquire()"
    },
    "acquire(long)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "synchronized"
      ],
      "params": [
        "timeout"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "acquire(long)"
    },
    "acquireInternal(java.util.Optional\u003cjava.lang.Long\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "timeoutOptional"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "acquireInternal(java.util.Optional\u003cjava.lang.Long\u003e)"
    },
    "getTag()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "minSdk": 26,
      "name": "getTag()",
      "documentation": "Returns the tag. "
    },
    "getTimesHeld()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getTimesHeld()",
      "documentation": "Returns how many times the wakelock was held. "
    },
    "getWorkSource()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "synchronized"
      ],
      "params": [],
      "returnType": "android.os.WorkSource",
      "exceptions": [],
      "name": "getWorkSource()"
    },
    "isHeld()": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "synchronized"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isHeld()"
    },
    "isReferenceCounted()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isReferenceCounted()",
      "documentation": "Retrieves if the wake lock is reference counted or not\n\n@return Is the wake lock reference counted?\n"
    },
    "refreshTimeoutTimestampList()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "refreshTimeoutTimestampList()",
      "documentation": "Iterate all the wake lock and remove those timeouted ones. "
    },
    "release(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "synchronized"
      ],
      "params": [
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "release(int)",
      "documentation": "Releases the wake lock. The {@code flags} are ignored. "
    },
    "setReferenceCounted(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "value"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setReferenceCounted(boolean)"
    },
    "setTag(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "tag"
      ],
      "returnType": "void",
      "exceptions": [],
      "minSdk": 22,
      "name": "setTag(java.lang.String)",
      "documentation": "Sets the tag. "
    },
    "setWorkSource(android.os.WorkSource)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "synchronized"
      ],
      "params": [
        "ws"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setWorkSource(android.os.WorkSource)"
    }
  },
  "imports": [
    "android.content.Intent.ACTION_SCREEN_OFF",
    "android.content.Intent.ACTION_SCREEN_ON",
    "android.os.Build.VERSION_CODES.LOLLIPOP",
    "android.os.Build.VERSION_CODES.LOLLIPOP_MR1",
    "android.os.Build.VERSION_CODES.M",
    "android.os.Build.VERSION_CODES.N",
    "android.os.Build.VERSION_CODES.O",
    "android.os.Build.VERSION_CODES.P",
    "android.os.Build.VERSION_CODES.Q",
    "android.os.Build.VERSION_CODES.R",
    "android.os.Build.VERSION_CODES.S",
    "android.os.Build.VERSION_CODES.TIRAMISU",
    "android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE",
    "com.google.common.base.Preconditions.checkState",
    "java.util.Comparator.comparing",
    "java.util.stream.Collectors.toCollection",
    "org.robolectric.util.reflector.Reflector.reflector",
    "android.annotation.NonNull",
    "android.annotation.Nullable",
    "android.annotation.RequiresPermission",
    "android.annotation.SystemApi",
    "android.annotation.TargetApi",
    "android.content.Context",
    "android.content.Intent",
    "android.os.Binder",
    "android.os.Build.VERSION_CODES",
    "android.os.PowerManager",
    "android.os.PowerManager.LowPowerStandbyPortDescription",
    "android.os.PowerManager.LowPowerStandbyPortsLock",
    "android.os.PowerManager.WakeLock",
    "android.os.SystemClock",
    "android.os.WorkSource",
    "com.google.common.collect.ImmutableSet",
    "java.time.Duration",
    "java.util.ArrayList",
    "java.util.Collections",
    "java.util.HashMap",
    "java.util.HashSet",
    "java.util.List",
    "java.util.Map",
    "java.util.Optional",
    "java.util.Set",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.HiddenApi",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.util.reflector.Accessor",
    "org.robolectric.util.reflector.ForType"
  ],
  "name": "org.robolectric.shadows.ShadowPowerManager.ShadowWakeLock"
}