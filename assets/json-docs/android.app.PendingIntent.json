{
  "methods": {
    "__staticInitializer__()": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "__staticInitializer__()"
    },
    "callLastOnFinished(android.content.Intent,int,java.lang.String,android.os.Bundle)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "intent",
        "resultCode",
        "resultData",
        "resultExtras"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "callLastOnFinished(android.content.Intent,int,java.lang.String,android.os.Bundle)",
      "documentation": "Calls {@link PendingIntent.OnFinished#onSendFinished} on the last {@link\nPendingIntent.OnFinished} passed with {@link #send()}.\n\n\u003cp\u003e{@link PendingIntent.OnFinished#onSendFinished} is called on the {@link Handler} passed with\n{@link #send()} (if any). If no {@link Handler} was provided it\u0027s invoked on the calling\nthread.\n\n@return false if no {@link PendingIntent.OnFinished} callback was passed with the last {@link\n    #send()} call, true otherwise.\n"
    },
    "cancel()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "cancel()"
    },
    "create(android.content.Context,android.content.Intent[],org.robolectric.shadows.ShadowPendingIntent.Type,int,int,android.os.Bundle)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "context",
        "intents",
        "type",
        "requestCode",
        "flags",
        "options"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "create(android.content.Context,android.content.Intent[],org.robolectric.shadows.ShadowPendingIntent.Type,int,int,android.os.Bundle)"
    },
    "equals(java.lang.Object)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "o"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "equals(java.lang.Object)"
    },
    "getActivities(android.content.Context,int,android.content.Intent[],int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intents",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getActivities(android.content.Context,int,android.content.Intent[],int)"
    },
    "getActivities(android.content.Context,int,android.content.Intent[],int,android.os.Bundle)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intents",
        "flags",
        "options"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getActivities(android.content.Context,int,android.content.Intent[],int,android.os.Bundle)"
    },
    "getActivity(android.content.Context,int,android.content.Intent,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intent",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getActivity(android.content.Context,int,android.content.Intent,int)"
    },
    "getActivity(android.content.Context,int,android.content.Intent,int,android.os.Bundle)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intent",
        "flags",
        "options"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getActivity(android.content.Context,int,android.content.Intent,int,android.os.Bundle)"
    },
    "getBroadcast(android.content.Context,int,android.content.Intent,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intent",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getBroadcast(android.content.Context,int,android.content.Intent,int)"
    },
    "getCreatedIntentFor(org.robolectric.shadows.ShadowPendingIntent.Type,android.content.Intent[],int,int)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "type",
        "intents",
        "requestCode",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getCreatedIntentFor(org.robolectric.shadows.ShadowPendingIntent.Type,android.content.Intent[],int,int)"
    },
    "getCreatorPackage()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "minSdk": 17,
      "name": "getCreatorPackage()"
    },
    "getCreatorUid()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "minSdk": 17,
      "name": "getCreatorUid()"
    },
    "getFlags()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getFlags()",
      "documentation": "@return the flags with which this PendingIntent was created\n"
    },
    "getForegroundService(android.content.Context,int,android.content.Intent,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intent",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "minSdk": 26,
      "name": "getForegroundService(android.content.Context,int,android.content.Intent,int)"
    },
    "getIntentSender()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "android.content.IntentSender",
      "exceptions": [],
      "name": "getIntentSender()"
    },
    "getOptions()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.os.Bundle",
      "exceptions": [],
      "name": "getOptions()",
      "documentation": "@return the flags with which this PendingIntent was created\n"
    },
    "getRequestCode()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "getRequestCode()",
      "documentation": "@return the request code with which this PendingIntent was created\n"
    },
    "getSavedContext()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.content.Context",
      "exceptions": [],
      "name": "getSavedContext()",
      "documentation": "@return the context in which this PendingIntent was created\n"
    },
    "getSavedIntent()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.content.Intent",
      "exceptions": [],
      "name": "getSavedIntent()",
      "documentation": "This returns the last Intent in the Intent[] to be delivered when the PendingIntent is sent.\nThis method is particularly useful for PendingIntents created with a single Intent:\n\n\u003cul\u003e\n  \u003cli\u003e{@link #getActivity(Context, int, Intent, int)}\n  \u003cli\u003e{@link #getActivity(Context, int, Intent, int, Bundle)}\n  \u003cli\u003e{@link #getBroadcast(Context, int, Intent, int)}\n  \u003cli\u003e{@link #getService(Context, int, Intent, int)}\n\u003c/ul\u003e\n\n@return the final Intent to be delivered when the PendingIntent is sent\n"
    },
    "getSavedIntents()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.content.Intent[]",
      "exceptions": [],
      "name": "getSavedIntents()",
      "documentation": "This method is particularly useful for PendingIntents created with multiple Intents:\n\n\u003cul\u003e\n  \u003cli\u003e{@link #getActivities(Context, int, Intent[], int)}\n  \u003cli\u003e{@link #getActivities(Context, int, Intent[], int, Bundle)}\n\u003c/ul\u003e\n\n@return all Intents to be delivered when the PendingIntent is sent\n"
    },
    "getService(android.content.Context,int,android.content.Intent,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected",
        "static"
      ],
      "params": [
        "context",
        "requestCode",
        "intent",
        "flags"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "getService(android.content.Context,int,android.content.Intent,int)"
    },
    "getTargetPackage()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getTargetPackage()"
    },
    "hashCode()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "int",
      "exceptions": [],
      "name": "hashCode()"
    },
    "isActivity()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "isActivity()",
      "documentation": "Returns {@code true} if this {@code PendingIntent} was created with {@link #getActivity} or\n{@link #getActivities}.\n\n\u003cp\u003eThis method is intentionally left {@code public} rather than {@code protected} because it\nserves a secondary purpose as a utility shadow method for API levels \u003c 31.\n"
    },
    "isActivityIntent()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isActivityIntent()",
      "documentation": "@return {@code true} iff sending this PendingIntent will start an activity\n@deprecated prefer {@link #isActivity} which was added to {@link PendingIntent} in API 31\n    (Android S).\n"
    },
    "isBroadcast()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "isBroadcast()",
      "documentation": "Returns {@code true} if this {@code PendingIntent} was created with {@link #getBroadcast}.\n\n\u003cp\u003eThis method is intentionally left {@code public} rather than {@code protected} because it\nserves a secondary purpose as a utility shadow method for API levels \u003c 31.\n"
    },
    "isBroadcastIntent()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isBroadcastIntent()",
      "documentation": "@return {@code true} iff sending this PendingIntent will broadcast an Intent\n@deprecated prefer {@link #isBroadcast} which was added to {@link PendingIntent} in API 31\n    (Android S).\n"
    },
    "isCanceled()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isCanceled()",
      "documentation": "@return {@true} iff this PendingIntent has been canceled\n"
    },
    "isForegroundService()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "isForegroundService()",
      "documentation": "Returns {@code true} if this {@code PendingIntent} was created with {@link\n#getForegroundService}.\n\n\u003cp\u003eThis method is intentionally left {@code public} rather than {@code protected} because it\nserves a secondary purpose as a utility shadow method for API levels \u003c 31.\n"
    },
    "isForegroundServiceIntent()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isForegroundServiceIntent()",
      "documentation": "@return {@code true} iff sending this PendingIntent will start a foreground service\n@deprecated prefer {@link #isForegroundService} which was added to {@link PendingIntent} in API\n    31 (Android S).\n"
    },
    "isImmutable()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "isImmutable()",
      "documentation": "Returns {@code true} if this {@code PendingIntent} is marked with {@link\nPendingIntent#FLAG_IMMUTABLE}.\n\n\u003cp\u003eThis method is intentionally left {@code public} rather than {@code protected} because it\nserves a secondary purpose as a utility shadow method for API levels \u003c 31.\n"
    },
    "isMutable(int)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "flags"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isMutable(int)"
    },
    "isOneShot(int)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "flags"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isOneShot(int)"
    },
    "isService()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "minSdk": 31,
      "name": "isService()",
      "documentation": "Returns {@code true} if this {@code PendingIntent} was created with {@link #getService}.\n\n\u003cp\u003eThis method is intentionally left {@code public} rather than {@code protected} because it\nserves a secondary purpose as a utility shadow method for API levels \u003c 31.\n"
    },
    "isServiceIntent()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isServiceIntent()",
      "documentation": "@return {@code true} iff sending this PendingIntent will start a service\n@deprecated prefer {@link #isService} which was added to {@link PendingIntent} in API 31\n    (Android S).\n"
    },
    "readPendingIntentOrNullFromParcel(android.os.Parcel)": {
      "isImplementation": true,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "in"
      ],
      "returnType": "android.app.PendingIntent",
      "exceptions": [],
      "name": "readPendingIntentOrNullFromParcel(android.os.Parcel)"
    },
    "reset()": {
      "isImplementation": false,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "reset()"
    },
    "send()": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send()"
    },
    "send(android.content.Context,int,android.content.Intent)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "code",
        "intent"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(android.content.Context,int,android.content.Intent)"
    },
    "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "code",
        "intent",
        "onFinished",
        "handler"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler)"
    },
    "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "code",
        "intent",
        "onFinished",
        "handler",
        "requiredPermission"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String)"
    },
    "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String,android.os.Bundle)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "context",
        "code",
        "intent",
        "onFinished",
        "handler",
        "requiredPermission",
        "options"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "minSdk": 23,
      "name": "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String,android.os.Bundle)"
    },
    "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String,android.os.Bundle,int)": {
      "isImplementation": false,
      "modifiers": [],
      "params": [
        "context",
        "code",
        "intent",
        "onFinished",
        "handler",
        "requiredPermission",
        "options",
        "requestCode"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String,android.os.Bundle,int)"
    },
    "send(int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "code"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(int)"
    },
    "send(int,android.app.PendingIntent.OnFinished,android.os.Handler)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "code",
        "onFinished",
        "handler"
      ],
      "returnType": "void",
      "exceptions": [
        "android.app.PendingIntent.CanceledException"
      ],
      "name": "send(int,android.app.PendingIntent.OnFinished,android.os.Handler)"
    },
    "setCreatorPackage(java.lang.String)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "creatorPackage"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCreatorPackage(java.lang.String)"
    },
    "setCreatorUid(int)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "uid"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setCreatorUid(int)"
    },
    "writePendingIntentOrNullToParcel(android.app.PendingIntent,android.os.Parcel)": {
      "isImplementation": true,
      "modifiers": [
        "public",
        "static"
      ],
      "params": [
        "sender",
        "out"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "writePendingIntentOrNullToParcel(android.app.PendingIntent,android.os.Parcel)"
    },
    "writeToParcel(android.os.Parcel,int)": {
      "isImplementation": true,
      "modifiers": [
        "protected"
      ],
      "params": [
        "out",
        "flags"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "writeToParcel(android.os.Parcel,int)"
    }
  },
  "imports": [
    "android.app.PendingIntent.FLAG_CANCEL_CURRENT",
    "android.app.PendingIntent.FLAG_IMMUTABLE",
    "android.app.PendingIntent.FLAG_NO_CREATE",
    "android.app.PendingIntent.FLAG_ONE_SHOT",
    "android.app.PendingIntent.FLAG_UPDATE_CURRENT",
    "android.os.Build.VERSION_CODES.JELLY_BEAN_MR1",
    "android.os.Build.VERSION_CODES.M",
    "android.os.Build.VERSION_CODES.N",
    "android.os.Build.VERSION_CODES.O",
    "android.os.Build.VERSION_CODES.S",
    "org.robolectric.util.reflector.Reflector.reflector",
    "android.annotation.NonNull",
    "android.annotation.SuppressLint",
    "android.app.Activity",
    "android.app.ActivityThread",
    "android.app.PendingIntent",
    "android.app.PendingIntent.CanceledException",
    "android.app.PendingIntent.OnMarshaledListener",
    "android.content.Context",
    "android.content.IIntentSender",
    "android.content.Intent",
    "android.content.IntentSender",
    "android.os.Bundle",
    "android.os.Handler",
    "android.os.IBinder",
    "android.os.Parcel",
    "android.os.Parcelable.Creator",
    "java.util.ArrayList",
    "java.util.Arrays",
    "java.util.Iterator",
    "java.util.List",
    "java.util.Objects",
    "javax.annotation.Nullable",
    "javax.annotation.concurrent.GuardedBy",
    "org.robolectric.RuntimeEnvironment",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.annotation.RealObject",
    "org.robolectric.annotation.Resetter",
    "org.robolectric.fakes.RoboIntentSender",
    "org.robolectric.shadow.api.Shadow",
    "org.robolectric.util.ReflectionHelpers",
    "org.robolectric.util.reflector.Accessor",
    "org.robolectric.util.reflector.ForType",
    "org.robolectric.shadows.ShadowPendingIntent.Type",
    "org.robolectric.shadows.ShadowPendingIntent.PendingIntentReflector"
  ],
  "name": "org.robolectric.shadows.ShadowPendingIntent"
}