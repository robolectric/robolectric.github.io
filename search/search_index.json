{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"test-drive your Android code <p>Running tests on an Android emulator or device is slow! Building, deploying, and running the tests often take minutes. That's no way to do TDD. There must be a better way. Robolectric is a framework that brings fast and reliable unit tests to Android. Tests run inside the JVM in seconds. With Robolectric you can write tests like this:</p> JavaKotlin <pre><code>@RunWith(AndroidJUnit4.class)\npublic class MyActivityTest {\n  @Test\n  public void clickingButton_shouldChangeMessage() {\n    try (ActivityController&lt;MyActivity&gt; controller = Robolectric.buildActivity(MyActivity.class)) {\n      controller.setup(); // Moves the Activity to the RESUMED state\n      MyActivity activity = controller.get();\n\n      activity.findViewById(R.id.button).performClick();\n      assertEquals(((TextView) activity.findViewById(R.id.text)).getText(), \"Robolectric Rocks!\");\n    }\n  }\n}\n</code></pre> <pre><code>@RunWith(AndroidJUnit4::class)\nclass MyActivityTest {\n  @Test\n  fun clickingButton_shouldChangeMessage() {\n    Robolectric.buildActivity(MyActivity::class.java).use { controller -&gt;\n      controller.setup() // Moves the Activity to the RESUMED state\n      val activity = controller.get()\n\n      activity.findViewById(R.id.button).performClick()\n      assertEquals(activity.findViewById&lt;TextView&gt;(R.id.text).text, \"Robolectric Rocks!\")\n    }\n  }\n}\n</code></pre> <p>Get started</p> <ul> <li> <p>Test APIs &amp; Isolation</p> <p>Unlike traditional emulator-based Android tests, Robolectric tests run inside a sandbox which allows the Android environment to be precisely configured to the desired conditions for each test, isolates each test from its neighbors, and extends the Android framework with test APIs which provide minute control over the Android framework's behavior and visibility of state for assertions.</p> <p>While much of the Android framework will work as expected inside a Robolectric test, some Android components' regular behavior doesn't translate well to unit tests: hardware sensors need to be simulated, system services need to be loaded with test fixture data. In those cases, Robolectric provides a test double that's suitable for most unit testing scenarios.</p> </li> <li> <p>No Mocking Frameworks Required</p> <p>An alternate approach to Robolectric is to use mock frameworks such as Mockito or to mock out the Android SDK. While this is a valid approach, it often yields tests that are essentially reverse implementations of the application code.</p> <p>Robolectric allows a test style that is closer to black box testing, making the tests more effective for refactoring and allowing the tests to focus on the behavior of the application instead of the implementation of Android. You can still use a mocking framework along with Robolectric if you like.</p> </li> <li> <p>Run Tests Outside the Emulator</p> <p>Robolectric lets you run your tests on your workstation, or on your continuous integration environment, in a regular JVM, without an emulator. Because of this, the dexing, packaging, and installing steps aren't necessary, reducing test cycles from minutes to seconds so you can iterate quickly and refactor your code with confidence.</p> </li> <li> <p>SDK, Resources, &amp; Native Method Simulation</p> <p>Robolectric handles inflation of <code>View</code>s, resource loading, and lots of other stuff that's implemented in native C code on Android devices. This allows tests to do most things you could do on a real device. You can provide your own implementation for specific SDK methods too, so you could simulate error conditions or real-world sensor behavior, for example.</p> </li> </ul>"},{"location":"androidx_test/","title":"AndroidX Test","text":"<p>Robolectric is intended to be fully compatible with Android's official testing libraries since version 4.0. As such, we encourage you to try these new APIs and provide feedback. At some point, the Robolectric equivalents will be deprecated and removed. Using the AndroidX Test APIs reduces the cognitive load for you as a developer, with just one set of APIs to learn for the same Android concept, no matter if you are writing an Robolectric test or an instrumentation test. Furthermore, it will make your tests more portable and compatible with our future plans.</p>"},{"location":"androidx_test/#testrunner","title":"TestRunner","text":"<p>It is now possible to use the AndroidX test runner in Robolectric tests. If you require a custom test runner, please check out the configuration and plugin API, and let us know if there are any extension points missing that you require.</p> <p>Robolectric</p> JavaKotlin <pre><code>import org.robolectric.RobolectricTestRunner;\n\n@RunWith(RobolectricTestRunner.class)\npublic class SandwichTest {\n}\n</code></pre> <pre><code>import org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass SandwichTest\n</code></pre> <p>AndroidX Test</p> JavaKotlin <pre><code>import androidx.test.ext.junit.runners.AndroidJUnit4;\n\n@RunWith(AndroidJUnit4.class)\npublic class SandwichTest {\n}\n</code></pre> <pre><code>import androidx.test.ext.junit.runners.AndroidJUnit4\n\n@RunWith(AndroidJUnit4::class)\nclass SandwichTest\n</code></pre>"},{"location":"androidx_test/#application","title":"Application","text":"<p>Since most Android code is centric around a <code>Context</code>, getting hold of your application\u2019s context is a typical task for most tests.</p> <p>Robolectric</p> JavaKotlin <pre><code>import org.robolectric.RuntimeEnvironment;\n\n@Before\nvoid setUp() {\n  ExampleApplication app = (ExampleApplication) RuntimeEnvironment.application;\n  app.setLocationProvider(mockLocationProvider);\n}\n</code></pre> <pre><code>import org.robolectric.RuntimeEnvironment\n\n@Before\nfun setUp() {\n  val app = RuntimeEnvironment.application as ExampleApplication\n  app.setLocationProvider(mockLocationProvider)\n}\n</code></pre> <p>AndroidX Test</p> JavaKotlin <pre><code>import androidx.test.core.app.ApplicationProvider;\n\n@Before\nvoid setUp() {\n  ExampleApplication app = ApplicationProvider.getApplicationContext&lt;ExampleApplication&gt;();\n  app.setLocationProvider(mockLocationProvider);\n}\n</code></pre> <pre><code>import androidx.test.core.app.ApplicationProvider\n\n@Before\nfun setUp() {\n  val app = ApplicationProvider.getApplicationContext&lt;ExampleApplication&gt;()\n  app.setLocationProvider(mockLocationProvider)\n}\n</code></pre>"},{"location":"androidx_test/#activities","title":"Activities","text":"<p>Robolectric provides <code>Robolectric.setupActivity()</code> for the coarse-grained use case where you require a launched activity in the resumed state and visible for the user to interact with.</p> <p>Robolectric also provides <code>Robolectric.buildActivity()</code>, which returns an <code>ActivityController</code> that allows the developer to step through the <code>Activity</code> lifecycle. This has proved problematic as it requires developers to fully understand valid lifecycle transitions and possible valid states. Using an <code>Activity</code> in an invalid state has undefined behavior and can cause compatibility issues when running on different Android test runtimes or when upgrading to newer versions of Robolectric.</p> <p><code>ActivityScenario</code> provides a replacement for both of these use cases, but places tighter restrictions around lifecycle transitions, namely that invalid or incomplete transitions are not possible. If you'd like a <code>Rule</code>-based equivalent please use <code>ActivityScenarioRule</code> instead.</p> <p>Robolectric</p> JavaKotlin <pre><code>import org.robolectric.Robolectric;\nimport org.robolectric.android.controller.ActivityController;\n\npublic class LocationTrackerActivityTest {\n    @Test\n    public void locationListenerShouldBeUnregisteredInCreatedState() {\n        // GIVEN\n        ActivityController&lt;LocationTrackerActivity&gt; controller = Robolectric.buildActivity&lt;LocationTrackerActivity&gt;().setup();\n\n        // WHEN\n        controller.pause().stop();\n\n        // THEN\n        assertThat(controller.get().getLocationListener()).isNull();\n     }\n}\n</code></pre> <pre><code>import org.robolectric.Robolectric\n\nclass LocationTrackerActivityTest {\n    @Test\n    fun locationListenerShouldBeUnregisteredInCreatedState() {\n        // GIVEN\n        val controller = Robolectric.buildActivity&lt;LocationTrackerActivity&gt;().setup()\n\n        // WHEN\n        controller.pause().stop()\n\n        // THEN\n        assertThat(controller.get().locationListener).isNull()\n     }\n}\n</code></pre> <p>AndroidX Test</p> JavaKotlin <pre><code>import androidx.lifecycle.Lifecycle;\nimport androidx.test.core.app.ActivityScenario;\n\npublic class LocationTrackerActivityTest {\n    @Test\n    public void locationListenerShouldBeUnregisteredInCreatedState() {\n        // GIVEN\n        ActivityScenario&lt;LocationTrackerActivity&gt; scenario = ActivityScenario.launchActivity&lt;LocationTrackerActivity&gt;();\n\n        // WHEN\n        scenario.moveToState(Lifecycle.State.CREATED);\n\n        // THEN\n        scenario.onActivity(activity -&gt; assertThat(activity.getLocationListener()).isNull());\n    }\n}\n</code></pre> <pre><code>import androidx.lifecycle.Lifecycle\nimport androidx.test.core.app.ActivityScenario\n\nclass LocationTrackerActivityTest {\n    @Test\n    fun locationListenerShouldBeUnregisteredInCreatedState() {\n        // GIVEN\n        val scenario = ActivityScenario.launchActivity&lt;LocationTrackerActivity&gt;()\n\n        // WHEN\n        scenario.moveToState(Lifecycle.State.CREATED)\n\n        // THEN\n        scenario.onActivity { activity -&gt;\n            assertThat(activity.locationListener).isNull()\n        }\n    }\n}\n</code></pre> <p>Note that in Robolectric since both the test and UI event loop run on the same thread, synchronization is not an issue. <code>ActivityScenario.onActivity</code> provides a safe way of accessing the <code>Activity</code>, should you need to, that will be guaranteed to be compatible with our future plans.</p>"},{"location":"androidx_test/#views","title":"Views","text":"<p>Robolectric has very limited APIs for <code>View</code> interaction. In most cases, test writers can just use Android APIs, such as <code>Activity.findViewById()</code> which was safe since Robolectric tests do not have to worry about synchronization between test and UI threads.</p> <p>Espresso is the <code>View</code> matching and interaction library of choice for instrumentation tests. Since Robolectric 4.0, Espresso APIs are now supported in Robolectric tests.</p> JavaKotlin <pre><code>import static androidx.test.espresso.Espresso.onView;\n\n@RunWith(AndroidJUnit4.class)\npublic class AddContactActivityTest {\n    @Test\n    public void inputTextShouldBeRetainedAfterActivityRecreation() {\n        // GIVEN\n        String contactName = \"Test User\";\n        ActivityScenario&lt;AddContactActivity&gt; scenario = ActivityScenario.launchActivity&lt;AddContactActivity&gt;();\n\n        // WHEN\n        // Enter contact name\n        onView(withId(R.id.contact_name_text)).perform(typeText(contactName));\n        // Destroy and recreate Activity\n        scenario.recreate();\n\n        // THEN\n        // Check contact name was preserved.\n        onView(withId(R.id.contact_name_text)).check(matches(withText(contactName)));\n     }\n}\n</code></pre> <pre><code>import androidx.test.espresso.Espresso.onView\n\n@RunWith(AndroidJUnit4::class)\nclass AddContactActivityTest {\n    @Test\n    fun inputTextShouldBeRetainedAfterActivityRecreation() {\n        // GIVEN\n        val contactName = \"Test User\"\n        val scenario = ActivityScenario.launchActivity&lt;AddContactActivity&gt;()\n\n        // WHEN\n        // Enter contact name\n        onView(withId(R.id.contact_name_text)).perform(typeText(contactName))\n        // Destroy and recreate Activity\n        scenario.recreate()\n\n        // THEN\n        // Check contact name was preserved.\n        onView(withId(R.id.contact_name_text)).check(matches(withText(contactName)))\n     }\n}\n</code></pre>"},{"location":"androidx_test/#fragments","title":"Fragments","text":"<p>AndroidX Test provides <code>FragmentScenario</code>, which offers APIs to safely create your <code>Fragment</code> under test and drive it through valid transitions.</p> JavaKotlin <pre><code>import androidx.fragment.app.testing.FragmentScenario;\n\n@RunWith(AndroidJUnit4.class)\npublic class FragmentTest {\n    @Test\n    public void testEventFragment() {\n        Bundle arguments = Bundle();\n        MyFragmentFactory factory = MyFragmentFactory();\n        FragmentScenario&lt;MyFragment&gt; scenario = FragmentScenario.launchFragmentInContainer&lt;MyFragment&gt;(arguments, factory);\n        onView(withId(R.id.text)).check(matches(withText(\"Hello World!\")));\n    }\n}\n</code></pre> <pre><code>import androidx.fragment.app.testing.FragmentScenario\n\n@RunWith(AndroidJUnit4::class)\nclass FragmentTest {\n    @Test\n    fun testEventFragment() {\n        val arguments = Bundle()\n        val factory = MyFragmentFactory()\n        val scenario = FragmentScenario.launchFragmentInContainer&lt;MyFragment&gt;(arguments, factory)\n        onView(withId(R.id.text)).check(matches(withText(\"Hello World!\")))\n    }\n}\n</code></pre> <p>Read more about testing Fragments here.</p>"},{"location":"architecture/","title":"Robolectric architecture","text":"<p>Robolectric is a unit testing framework that allows Android code to be tested on the JVM without the need for an emulator or device. This allows tests to run very quickly in a more hermetic environment. Robolectric has a complex architecture and makes use of many advanced features of the JVM, such as bytecode instrumentation and custom <code>ClassLoader</code>s. This document provides a high level overview of Robolectric's architecture.</p>"},{"location":"architecture/#android-framework-jars-and-instrumentation","title":"Android framework Jars and instrumentation","text":"<p>At the heart of Robolectric are the Android framework Jars and the bytecode instrumentation. The Android framework Jars are a collection of Jar files that are built directly from Android platform sources. There is a single Jar file for each version of Android. These Jar files can be built by checking out an AOSP repo and building the robolectric-host-android_all target. Unlike the <code>android.jar</code> (stubs jar) files managed by Android Studio, which only contain public method signatures, the Robolectric android-all Jars contain the implementation of the Android Java framework. This gives Robolectric the ability to use as much real Android code as possible. A new android-all jar is uploaded to MavenCentral for each Android release. You can see the current android-all jars here.</p> <p>However, the pristine android-all jars are not the ones used during tests. Instead, Robolectric modifies the pristine android-all jars using bytecode instrumentation (see <code>ClassInstrumentor</code>). It performs several modifications:</p> <ol> <li> <p>All Android methods, including constructors and static initializers, are modified to support    <code>shadowing</code>. This allows any method call to the Android framework to be intercepted by    Robolectric and delegated to a shadow method. At a high level, this is done by iterating over    each Android method and converting it into two methods: the original method (but renamed), and    the <code>invokedynamic delegator</code> which can optionally invoke shadow methods if they are available.</p> </li> <li> <p>Android constructors are specially modified to create shadow objects if a shadow class is bound    to the Android class being instantiated.</p> </li> <li> <p>Because the Android version of Java core classes (libcore) contains subtle differences to the    JDKs, certain problematic method calls have to be intercepted and rewritten. See    <code>AndroidInterceptors</code>.</p> </li> <li> <p>Native methods undergo special instrumentation. Currently, native methods are converted to no-op    non-native methods that are shadowable by default. However, there is now a native variant of each    method also created. There are more details about native code in a section below.</p> </li> <li> <p>The <code>final</code> keyword is stripped from classes and methods.</p> </li> <li> <p>Some bespoke pieces of instrumentation, such as supporting    <code>SparseArray.set()</code>.</p> </li> </ol> <p>This instrumentation is typically performed when a new release of Robolectric is made. These pre-instrumented Android-all jars are published on MavenCentral. See the android-all-instrumented path. They are lazily downloaded and during tests runtime using <code>MavenArtifactFetcher</code>.</p> <p>Although Robolectric supports shadowing for Android framework classes, it is also possible for users to perform Robolectric instrumentation for any package (except built-in Java packages). This enables shadowing of arbitrary third-party code.</p>"},{"location":"architecture/#shadows","title":"Shadows","text":"<p>By default, when an Android method is invoked during a Robolectric test, the real Android framework code is invoked. This is because a lot of Android framework classes are pure Java code (e.g., the <code>Intent</code> class or the <code>org.json</code> package) and that code can run on the JVM without any modifications needed.</p> <p>However, there are cases where Robolectric needs to intercept and replace Android method calls. This most commonly occurs when Android system service or native methods are invoked. To do this, Robolectric uses a system called Shadow classes.</p> <p>Shadow classes are Java classes that contain the replacement code of Android methods when they are invoked. Each shadow class is bound to specific Android classes and methods through annotations. There are currently hundreds of shadow classes that can be found here.</p> <p>Shadow classes may optionally contain public APIs that can customize the behavior of the methods they are shadowing.</p> <p>Robolectric allows tests to specify custom shadows as well to provide user defined implementation for Android classes.</p>"},{"location":"architecture/#shadow-packages-and-the-robolectric-annotation-processor","title":"Shadow Packages and the Robolectric Annotation Processor","text":"<p>There are two categories of shadows: Robolectric\u2019s built-in shadows that are aggregated using the Robolectric Annotation Processor (RAP), and custom shadows that are commonly specified using <code>@Config(shadows = \u2026)</code>. RAP is configured to process all the shadow files that exist in Robolectric\u2019s code. The main shadow package is framework shadows, which contain shadows for the Android framework. There are other shadow packages in Robolectric's code, such as httpclient shadows, but all of them outside of framework shadows are deprecated. When Robolectric is built, each shadow package is processed by RAP and a ShadowProvider file is generated. For example, to see the <code>ShadowProvider</code> for the framework shadows, you can run:</p> <pre><code>./gradlew :shadows:framework:assemble\ncat ./shadows/framework/build/generated/src/apt/main/org/robolectric/Shadows.java\n</code></pre> <p>In this file you will see the class <code>public class Shadows implements ShadowProvider</code>.</p> <p>During runtime, Robolectric will use <code>ServiceLoader</code> to detect all shadow packages that implement <code>ShadowProvider</code> and the shadow classes contained in them.</p>"},{"location":"architecture/#sandbox-and-classloader","title":"<code>Sandbox</code> and <code>ClassLoader</code>","text":"<p>Before a Robolectric test is executed, a <code>Sandbox</code> must be initialized. A <code>Sandbox</code> consists of some high-level structures that are necessary to run a Robolectric test. It primarily contains a <code>SandboxClassLoader</code>, which is a custom <code>ClassLoader</code> that is bound to a specific instrumented Android-all jar. Sandboxes also contain the <code>ExecutorService</code> that serves as the main thread (UI thread) as well as high-level instrumentation configuration. The <code>SandboxClassLoader</code> is installed as the default <code>ClassLoader</code> for the test method. When any Android class is requested, <code>SandboxClassLoader</code> will attempt to load the Android class from the instrumented Android-all Jar first. The primary goal of <code>SandboxClassLoader</code> is to ensure that classes from the <code>android.jar</code> stubs jar are not inadvertently loaded. When classes from the <code>android.jar</code> stubs jar are loaded, attempting to invoke any method on them will result in a <code>RuntimeException(\"Stub!\")</code> error. Typically, the Android stubs jar is on the classpath during a Robolectric test, but it is important not to load classes from the stubs jar.</p>"},{"location":"architecture/#invokedynamic-delegators-and-shadowwrangler","title":"Invokedynamic Delegators and <code>ShadowWrangler</code>","text":"<p>This section provides more detail for <code>invokedynamic delegators</code> that were referenced in the instrumentation section. For an overview of the <code>invokedynamic</code> JVM instructions, you can search for articles or watch YouTube videos such as this.</p> <p>To reiterate, for any Android method, Robolectric\u2019s instrumentation adds an <code>invokedynamic delegator</code> that is responsible for determining at runtime to either invoke the real Android framework code or a shadow method. The first time an Android method is invoked in a <code>Sandbox</code>, it will result in a call to one of the bootstrap methods in <code>InvokeDynamicSupport</code>. This will subsequently invoke the <code>ShadowWrangler.findShadowMethodHandle()</code> to determine if a shadow method exists for the method that is being invoked. If a shadow method is available, a <code>MethodHandle</code> to it will be returned. Otherwise, a <code>MethodHandle</code> for the original framework code will be returned.</p>"},{"location":"architecture/#test-lifecycle","title":"Test lifecycle","text":"<p>There is a lot of work done by Robolectric before and after a test is run. Besides the <code>Sandbox</code> and <code>ClassLoader</code> initialization mentioned above, there is also extensive Android environment initialization that occurs before each test. The high-level class for this is <code>AndroidTestEnvironment</code>. This involves:</p> <ul> <li>Initializing up the <code>Looper</code> mode (i.e., the scheduler)</li> <li>Initializing system and app resources</li> <li>Initializing the application context and system context</li> <li>Loading the Android manifest for the test</li> <li>Creating the <code>Application</code> object used for the test</li> <li>Initializing the display configuration</li> <li>Setting up the <code>ActivityThread</code></li> <li>Creating app directories</li> </ul> <p>It is possible for users to extend the test environment setup using <code>TestEnvironmentLifecyclePlugin</code>.</p> <p>Similarly, after each test, many Android classes are reset during <code>RobolectricTestRunner.finallyAfterTest()</code>. This will iterate over all shadows and invoke their static <code>@Resetter</code> methods.</p>"},{"location":"architecture/#plugin-system","title":"Plugin system","text":"<p>Many parts of Robolectric can be customized using a plugin system based on Java\u2019s <code>ServiceLoader</code>. This extensibility is useful when running Robolectric in more constrained environments. For example, by default, most of the Robolectric classes are designed to work in a Gradle/Android Studio environment. However, there are companies (such as Google) that use alternate build systems (such as Bazel), and it can be helpful to be able to customize the behavior of some core modules.</p> <p>The <code>pluginapi</code> subproject contains many extension points of Robolectric. However, virtually any class that is loaded by Robolectric\u2019s <code>Injector</code> has the ability to use <code>PluginFinder</code>, which means it can be extended at runtime.</p> <p>Typically, <code>ServiceLoaders</code> plugins can be easily written using the <code>AutoService</code> project.</p>"},{"location":"automated-migration/","title":"Automated Migration","text":""},{"location":"automated-migration/#automated-migration","title":"Automated Migration","text":"<p>Robolectric provides an automated migration tool to help keep your test suite up to date with Robolectric API changes. It's based on Error Prone's refactoring tools.</p> <p>The migration tool will make changes directly to source files in your codebase, which you can review and commit to your source control system.</p> <p>Before updating your dependencies to the new version of Robolectric:</p> <ol> <li> <p>Make sure you're using a recent version of Gradle (4.10 or newer).</p> </li> <li> <p>Configure your project to integrate Error Prone. Quick config for Gradle (    usually in your module's <code>build.gradle</code>/<code>build.gradle.kts</code> file):</p> </li> </ol> GroovyKotlin <pre><code>plugins {\n   id \"net.ltgt.errorprone\" version \"&lt;error_prone_plugin_version&gt;\" apply false\n}\n\nString robolectricMigrations = System.getenv(\"ROBOLECTRIC_MIGRATIONS\")\nif (robolectricMigrations) {\n   apply plugin: \"net.ltgt.errorprone\"\n\n   dependencies {\n      errorprone \"com.google.errorprone:error_prone_core:&lt;error_prone_version&gt;\"\n      errorprone \"org.robolectric:errorprone:4.16\"\n   }\n\n   tasks.withType(JavaCompile).configureEach {\n      options.errorprone.errorproneArgs = [\n              '-XepPatchChecks:' + robolectricMigrations,\n              '-XepPatchLocation:IN_PLACE',\n      ]\n   }\n}\n</code></pre> <pre><code>plugins {\n   id(\"net.ltgt.errorprone\") version \"&lt;error_prone_plugin_version&gt;\" apply false\n}\n\nval robolectricMigrations = System.getenv(\"ROBOLECTRIC_MIGRATIONS\")\nif (!robolectricMigrations.isNullOrEmpty()) {\n   pluginManager.apply(\"net.ltgt.errorprone\")\n\n   dependencies {\n      errorprone(\"com.google.errorprone:error_prone_core:&lt;error_prone_version&gt;\")\n      errorprone(\"org.robolectric:errorprone:4.16\")\n   }\n\n   tasks.withType&lt;JavaCompile&gt;().configureEach {\n      options.errorprone.errorproneArgs = listOf(\n         \"-XepPatchChecks:$robolectricMigrations\",\n         \"-XepPatchLocation:IN_PLACE\",\n      )\n   }\n}\n</code></pre> <pre><code>You don't need to commit this change.\n</code></pre> <ol> <li> <p>Run the migrations:</p> <pre><code>ROBOLECTRIC_MIGRATION=DeprecatedMethods,ShadowUsageCheck ./gradlew clean :compileDebugUnitTestJava\n</code></pre> </li> <li> <p>Make sure your code still compiles and commit changes.</p> </li> <li>Update your project to the new version of Robolectric.</li> </ol> <p>The migration tool will make a best effort attempt to adjust the source code, but there might be more complicated situations that it cannot handle and that need to be converted manually.</p>"},{"location":"best-practices/","title":"Best Practices &amp; Limitations","text":""},{"location":"best-practices/#best-practices","title":"Best Practices","text":"<p>DO test layout inflation in your Robolectric test and ensure that click listeners are set up correctly by testing the <code>Activity</code> and layout interaction directly, rather than mocking the <code>LayoutInflater</code> or providing an abstraction over the <code>View</code>.</p> <p>DO use public lifecycle APIs (e.g., via <code>Robolectric.buildActivity()</code>), rather than exposing <code>@VisibleForTesting</code> methods when testing Android components such as <code>Activity</code>s and <code>Service</code>s. Calling those methods directly makes it difficult to refactor the code under test later.</p> <p>DO limit the number of threads that are running during each test. Rogue threads often cause test pollution because they are not automatically cleaned up between tests. Oftentimes threads are inadvertently spawned when using third-party libraries (e.g., for networking) or background processing components. One of the main sources of additional threads during tests are <code>ExecutorService</code>s that maintain thread pools. If possible, mock dependent components that spawn threads, or use <code>MoreExecutors.directExecutor()</code>. If it's necessary to run multiple threads during a test, make sure to explicitly stop all threads and <code>ExecutorService</code>s to avoid test pollution.</p> <p>DON'T mock or spy on Android classes that will be acted on by other Android code (e.g. <code>Context</code>, <code>SharedPreferences</code>, and many others). Stubbing is very brittle and can lead to breakages on Robolectric or Android Platform upgrades. The small exceptions to this rule are classes with very narrow responsibilities, such as event listeners.</p>"},{"location":"best-practices/#limitations","title":"Limitations","text":"<p>Robolectric aims to accelerate Android unit testing by simulating the Android environment in the JVM, eliminating the need for emulators or physical devices.</p> <p>However, it is important to be aware that Robolectric has certain limitations in replicating the complete Android environment. These limitations, as well as potential workarounds, are outlined in this document.</p>"},{"location":"best-practices/#android-libcore-and-openjdk-have-different-implementations","title":"Android libcore and OpenJDK have different implementations","text":"<p>Android libcore is a collection of Java libraries specifically designed for the Android platform. It provides essential functionalities for Android apps like networking, security, and file I/O. While libcore shares similarities with OpenJDK, it has its own implementation for some components, optimised for Android's resource constraints and security considerations.</p> <p>Because of that, you may notice different behaviours when running your app on a device or emulator, and running your tests on the JVM with Robolectric.</p> <p>Below is an incomplete list of differences you may encounter:</p>"},{"location":"best-practices/#timezone-handling","title":"Timezone handling","text":"<p>When using <code>SimpleDateFormat#parse()</code> to parse a timezone using the <code>Z</code> marker, Android supports time zones with a colon (i.e. <code>08:00</code>), while OpenJDK doesn't (i.e. <code>0800</code>).</p> <p>To work around this:</p> <ul> <li>If your min SDK version is 24 or higher, you can use the <code>X</code> marker instead.</li> <li>Use the <code>java.time</code> API, with library desugaring enabled.</li> <li>Run the corresponding tests using regular Android tests.</li> </ul> <p>Related issues: #1030, #1257, #5220.</p>"},{"location":"best-practices/#month-names","title":"Month names","text":"<p>When using <code>DateTimeFormatter.ofPattern(String)</code> to create a formatter displaying a short month name (using the <code>MMM</code> pattern), Android will use three-characters names (i.e. <code>Jan</code>), while OpenJDK will use three-characters names followed by a period (i.e. <code>Jan.</code>).</p> <p>In this case, we recommend running the corresponding tests as regular Android tests.</p> <p>Related issues: #7910.</p>"},{"location":"build-system-integration/","title":"Build System Integration","text":"<p>Starting with Robolectric 3.3, the test runner will look for a file named <code>/com/android/tools/test_config.properties</code> on the classpath. If it is found, it will be used to provide the default manifest, resource, and asset locations for tests, without the need to specify <code>@Config(manifest = \"...\", resourceDir = \"...\", assetDir = \"...\")</code> in your tests.</p> <p>This gives build system implementors the ability to perform manifest, asset and resource preprocessing and merging for tests using the same strategy it would when building the APK, rather than leaving it up to Robolectric.</p> <p>This supersedes Robolectric's support for merging multiple libraries specified via <code>@Config(libraries = {\"lib1\", \"lib2\"})</code>.</p>"},{"location":"build-system-integration/#supported-keys","title":"Supported keys","text":"<ul> <li><code>android_merged_manifest</code>: full path to the project's merged <code>AndroidManifest.xml</code> file.</li> <li><code>android_merged_resources</code>: full path to the project's merged resources.</li> <li><code>android_merged_assets</code>: full path to the project's merged assets.</li> <li><code>android_custom_package</code>: Java package name for the applications <code>R</code> class.</li> <li><code>android_resource_apk</code>: path to a <code>resources.ap_</code> file that contains binary resources and XML   files produced by the <code>aapt</code> tool, as well as merged assets.</li> </ul> <p>Note</p> <p>Robolectric expects that build systems have generated the final <code>R.class</code> file by the time unit tests are run.</p> <p>For merged raw resources support:</p> <pre><code>android_merged_assets=/some/path/to/app/build/intermediates/assets/debug\nandroid_merged_resources=/some/path/to/app/build/intermediates/merged_res/debug\nandroid_merged_manifest=/some/path/to/app/build/intermediates/merged_manifests/debug/processDebugManifest/AndroidManifest.xml\nandroid_custom_package=com.example.app\n</code></pre> <p>For binary resources support:</p> <pre><code>android_resource_apk=/some/path/to/app/resources.ap_\n</code></pre>"},{"location":"building-robolectric/","title":"Building Robolectric","text":"<p>This page describes how to set up a development environment to build and test Robolectric on the supported OSs (Linux, Mac, Windows).</p>"},{"location":"building-robolectric/#installing-android-sdk-tools","title":"Installing Android SDK Tools","text":"<p>This can be achieved by either installing Android Studio (recommended), or Android's command line tools. We recommend using the latest stable release of Android Studio, because Robolectric uses the latest stable version of the Android Gradle Plugin.</p> <p>Robolectric's integration tests require Android Build Tools to be installed and specific SDK versions to be installed. Please check the relevant modules to know which versions to install.</p>"},{"location":"building-robolectric/#configure-necessary-environments","title":"Configure necessary environments","text":""},{"location":"building-robolectric/#system-environment-android_home","title":"System environment <code>ANDROID_HOME</code>","text":"<p>Current Robolectric repository requires system environment <code>ANDROID_HOME</code> to retrieve the official <code>android.jar</code> for internal validation.</p> <p>For macOS, there are some potential configuration files that Android Studio might recognize:</p> <ol> <li><code>~/.bash_profile</code>.</li> <li><code>~/.zprofile</code>.</li> </ol>"},{"location":"building-robolectric/#install-required-androidjar","title":"Install required <code>android.jar</code>","text":"<p>Current Robolectric repository requires <code>android-34.jar</code> installed in <code>$ANDROID_HOME/platforms/android-34/android.jar</code>.</p> <p>The simplest way is to use Android Studio's <code>SDK Manager</code> to install it.</p>"},{"location":"building-robolectric/#install-git-and-openjdk-17","title":"Install Git and OpenJDK 17","text":"<p>JDK 17 is currently required to build Robolectric. Newer versions of the JDK (e.g. 21) will likely work, but may contain some rough edges.</p> <ol> <li>Install Git to download Robolectric source code.</li> <li>Install OpenJDK 17 to build and test Robolectric. See    GitHub Action setup-java to get the recommended OpenJDK distribution    list. Any distribution that supports JDK 17 is recommended. Different operating systems have    different OpenJDK installation and configuration tutorials, please search the internet to learn    how to do it.</li> </ol>"},{"location":"building-robolectric/#download-source-code","title":"Download source code","text":"<p>Robolectric's source code is available on GitHub. You can get by running the following command:</p> <pre><code>git clone git@github.com:robolectric/robolectric.git\n</code></pre>"},{"location":"building-robolectric/#building-and-testing","title":"Building and testing","text":""},{"location":"building-robolectric/#build-robolectric","title":"Build Robolectric","text":"<p>Robolectric supports running tests against multiple Android API levels. To build Robolectric, run:</p> <pre><code>./gradlew clean assemble testClasses --parallel\n</code></pre>"},{"location":"building-robolectric/#run-unit-tests","title":"Run unit tests","text":"<pre><code>./gradlew test --parallel\n</code></pre> <p>You can use the <code>robolectric.enabledSdks</code> argument to specify a subset of comma-separated supported API levels to test:</p> <pre><code># Replace 32,33,34 with the API levels you want to test\n./gradlew test --parallel -\"Drobolectric.enabledSdks=32,33,34\"\n</code></pre>"},{"location":"building-robolectric/#run-instrumentation-tests","title":"Run instrumentation tests","text":"<p>You can run the compatibility test suites on your connected devices (either a physical device or an emulator) by running:</p> <pre><code>./gradlew connectedAndroidTest\n</code></pre> <p>If you're using Windows, it's recommended to use PowerShell in Windows Terminal.</p>"},{"location":"building-robolectric/#next-step","title":"Next step","text":"<p>Once you're up and running, you can have a look at the architecture documentation to learn more about Robolectric's components.</p>"},{"location":"configuring/","title":"Configuring Robolectric","text":"<p>Several aspects of Robolectric's behavior can be configured at runtime, using either <code>@Config</code> annotations for class- or method-level configuration, or <code>robolectric.properties</code> files for package-level configuration.</p>"},{"location":"configuring/#configuration-methods","title":"Configuration methods","text":""},{"location":"configuring/#config-annotation","title":"<code>@Config</code> annotation","text":"<p>To configure Robolectric for a single test class or method, use the <code>@Config</code> annotation on the desired class or method. Annotations applied on methods take precedence over the ones at the class level.</p> <p>Base classes are also searched for annotations. So if you find yourself specifying the same values on a large number of tests, you can create a base class and move your <code>@Config</code> annotation to that class.</p> JavaKotlin <pre><code>@Config(\n  sdk = Build.VERSION_CODES.TIRAMISU,\n  shadows = {ShadowFoo.class, ShadowBar.class}\n)\npublic class SandwichTest {\n}\n</code></pre> <pre><code>@Config(\n  sdk = Build.VERSION_CODES.TIRAMISU,\n  shadows = [ShadowFoo::class, ShadowBar::class]\n)\nclass SandwichTest\n</code></pre>"},{"location":"configuring/#robolectricproperties-file","title":"<code>robolectric.properties</code> file","text":"<p>To configure all Robolectric tests within a package or group of packages, create a file named <code>robolectric.properties</code> in the appropriate package. Generally, this file would be placed within the appropriate package directory under <code>src/test/resources</code> in your project tree. Robolectric will search for properties files up the hierarchy of packages (including the unnamed default package at the top level), with values in deeper packages overriding values in more shallow packages. When test classes or methods have <code>@Config</code> annotations, those override any config from properties files.</p> <p>Below is an example:</p> src/test/resources/com/mycompany/app/robolectric.properties<pre><code>sdk=33\nshadows=com.mycompany.ShadowFoo,com.mycompany.ShadowBar\n</code></pre> <p>Note</p> <p>Prior to Robolectric 3.1.3, only a top-level <code>robolectric.properties</code> file may be specified.</p>"},{"location":"configuring/#global-configuration","title":"Global Configuration","text":"<p>If you wish to change the default for any configurable value for all your tests, you can provide a <code>GlobalConfigProvider</code> service implementation.</p>"},{"location":"configuring/#configurables","title":"Configurables","text":"<p>The following examples show how to handle common configuration tasks. For clarity, <code>@Config</code> annotations are used, but any of these values may also be configured using properties files.</p>"},{"location":"configuring/#configure-sdk-level","title":"Configure SDK Level","text":"<p>By default, Robolectric will run your code against the <code>targetSdk</code> specified in your module's <code>build.gradle</code>/<code>build.gradle.kts</code> or <code>AndroidManifest.xml</code> file. If you want to test your code under a different SDK, you can specify the desired SDK(s) using the <code>sdk</code>, <code>minSdk</code> and <code>maxSdk</code> config properties:</p> JavaKotlin <pre><code>@Config(sdk = {TIRAMISU, UPSIDE_DOWN_CAKE})\npublic class SandwichTest {\n  @Test\n  public void getSandwich_shouldReturnHamSandwich() {\n    // will run on TIRAMISU and UPSIDE_DOWN_CAKE\n  }\n\n  @Test\n  @Config(sdk = TIRAMISU)\n  public void onTiramisu_getSandwich_shouldReturnChocolateWaferSandwich() {\n    // will run on TIRAMISU\n  }\n\n  @Test\n  @Config(minSdk = UPSIDE_DOWN_CAKE)\n  public void fromUpsideDownCakeOn_getSandwich_shouldReturnTunaSandwich() {\n    // will run on UPSIDE_DOWN_CAKE, VANILLA_ICE_CREAM, etc.\n  }\n}\n</code></pre> <pre><code>@Config(sdk = [TIRAMISU, UPSIDE_DOWN_CAKE])\nclass SandwichTest {\n  @Test\n  fun getSandwich_shouldReturnHamSandwich() {\n    // will run on TIRAMISU and UPSIDE_DOWN_CAKE\n  }\n\n  @Test\n  @Config(sdk = TIRAMISU)\n  fun onTiramisu_getSandwich_shouldReturnChocolateWaferSandwich() {\n    // will run on TIRAMISU\n  }\n\n  @Test\n  @Config(minSdk = UPSIDE_DOWN_CAKE)\n  fun fromUpsideDownCakeOn_getSandwich_shouldReturnTunaSandwich() {\n    // will run on UPSIDE_DOWN_CAKE, VANILLA_ICE_CREAM, etc.\n  }\n}\n</code></pre> <p>Note that <code>sdk</code> and <code>minSdk</code>/<code>maxSdk</code> may not be specified in the same <code>@Config</code> annotation or file; however, <code>minSdk</code> and <code>maxSdk</code> may be specified together. If any of them is present, they override any SDK specification from a less-specific configuration location.</p> <p>Note</p> <p>Prior to Robolectric 3.2, <code>minSdk</code> and <code>maxSdk</code> are ignored, and <code>NEWEST_SDK</code>, <code>OLDEST_SDK</code>, and <code>TARGET_SDK</code> are not supported. Also, only integers corresponding to API levels may be specified in a properties file.</p>"},{"location":"configuring/#configure-application-class","title":"Configure <code>Application</code> class","text":"<p>Robolectric will attempt to create an instance of your <code>Application</code> class as specified in the <code>AndroidManifest</code>. If you want to provide a custom implementation, you can specify it by setting:</p> JavaKotlin <pre><code>@Config(application = CustomApplication.class)\npublic class SandwichTest {\n  @Test\n  @Config(application = CustomApplicationOverride.class)\n  public void getSandwich_shouldReturnHamSandwich() {\n  }\n}\n</code></pre> <pre><code>@Config(application = CustomApplication::class)\nclass SandwichTest {\n  @Test\n  @Config(application = CustomApplicationOverride::class)\n  fun getSandwich_shouldReturnHamSandwich() {\n  }\n}\n</code></pre>"},{"location":"configuring/#configure-qualifiers","title":"Configure qualifiers","text":"<p>You can explicitly configure the set of resource qualifiers in effect for a test:</p> JavaKotlin <pre><code>public class SandwichTest {\n  @Test\n  @Config(qualifiers = \"fr-xlarge\")\n  public void getSandwichName() {\n    assertThat(sandwich.getName()).isEqualTo(\"Grande Croque Mon\u00e9gasque\");\n  }\n}\n</code></pre> <pre><code>class SandwichTest {\n  @Test\n  @Config(qualifiers = \"fr-xlarge\")\n  fun getSandwichName() {\n    assertThat(sandwich.name).isEqualTo(\"Grande Croque Mon\u00e9gasque\")\n  }\n}\n</code></pre> <p>See Using Qualified Resources for more details.</p>"},{"location":"configuring/#system-properties","title":"System properties","text":"<p>Some additional options can be configured globally by setting these system properties:</p> Property name Description Default value <code>robolectric.enabledSdks</code> Comma-separated list of SDK levels or names (e.g. <code>33, 34</code> or <code>TIRAMISU, UPSIDE_DOWN_CAKE</code>) which are enabled for this process. Only tests targeting a listed SDKs will be run. All SDKs <code>robolectric.offline</code> Set to <code>true</code> to disable runtime fetching of jars. <code>false</code> <code>robolectric.usePreinstrumentedJars</code> If <code>true</code>, Robolectric will use instrumented jars to reduce instrumentation overhead. If changes are made to instrumentation, this can be set to <code>false</code> to ensure the changes are included when building Robolectric. <code>true</code> <code>robolectric.dependency.dir</code> When in offline mode, specifies a folder containing runtime dependencies. <code>null</code> <code>robolectric.dependency.repo.id</code> Set the ID of the Maven repository to use for the runtime dependencies. <code>mavenCentral</code> <code>robolectric.dependency.repo.url</code> Set the URL of the Maven repository to use for the runtime dependencies. <code>https://repo1.maven.org/maven2</code> <code>robolectric.dependency.repo.username</code> Username of the repository that you defined in <code>robolectric.dependency.repo.url</code>. <code>null</code> <code>robolectric.dependency.repo.password</code> Password of the repository that you defined in <code>robolectric.dependency.repo.url</code>. <code>null</code> <code>robolectric.logging.enabled</code> Set to <code>true</code> to enable debug logging. <code>false</code> <p>Since Robolectric 4.9.1, you can now add these parameters:</p> Property name Description Default value <code>robolectric.dependency.proxy.host</code> Set the host of the proxy to use for the runtime dependencies. <code>null</code> <code>robolectric.dependency.proxy.port</code> Set the port number of the proxy to use for the runtime dependencies. <code>0</code> <p>When using Gradle, you can configure the System Properties for unit tests with the <code>android.testOptions.unitTests.all</code> block (see here). For example, to override the Maven repository URL and ID to download the runtime dependencies from a repository other than Maven Central:</p> GroovyKotlin <pre><code>android {\n  testOptions {\n    unitTests.all {\n      systemProperty \"robolectric.dependency.repo.url\", \"https://local-mirror/repo\"\n      systemProperty \"robolectric.dependency.repo.id\", \"local\"\n\n      // Username and password only needed when the local repository needs account information.\n      systemProperty \"robolectric.dependency.repo.username\", \"username\"\n      systemProperty \"robolectric.dependency.repo.password\", \"password\"\n\n      // Since Robolectric 4.9.1, these are available\n      systemProperty \"robolectric.dependency.proxy.host\", project.findProperty(\"systemProp.https.proxyHost\") ?: System.getenv(\"ROBOLECTRIC_PROXY_HOST\")\n      systemProperty \"robolectric.dependency.proxy.port\", project.findProperty(\"systemProp.https.proxyPort\") ?: System.getenv(\"ROBOLECTRIC_PROXY_PORT\")\n    }\n  }\n}\n</code></pre> <pre><code>android {\n  testOptions {\n    unitTests.all {\n      it.systemProperty(\"robolectric.dependency.repo.url\", \"https://local-mirror/repo\")\n      it.systemProperty(\"robolectric.dependency.repo.id\", \"local\")\n\n      // Username and password only needed when the local repository needs account information.\n      it.systemProperty(\"robolectric.dependency.repo.username\", \"username\")\n      it.systemProperty(\"robolectric.dependency.repo.password\", \"password\")\n\n      // Since Robolectric 4.9.1, these are available\n      it.systemProperty(\"robolectric.dependency.proxy.host\", project.findProperty(\"systemProp.https.proxyHost\") ?: System.getenv(\"ROBOLECTRIC_PROXY_HOST\"))\n      it.systemProperty(\"robolectric.dependency.proxy.port\", project.findProperty(\"systemProp.https.proxyPort\") ?: System.getenv(\"ROBOLECTRIC_PROXY_PORT\"))\n    }\n  }\n}\n</code></pre>"},{"location":"configuring/#conscryptmode","title":"<code>ConscryptMode</code>","text":"<p>Starting with Robolectric 4.9, Robolectric can either use Conscrypt and BouncyCastle or just BouncyCastle as the security provider. In order to migrate tests over time, there is a <code>ConscryptMode</code> annotation that controls whether Conscrypt is loaded as the default security provider with BouncyCastle as backup.</p> <ul> <li>If <code>ConscryptMode.Mode</code> is <code>ON</code>, it will install   Conscrypt and BouncyCastle.</li> <li>If <code>ConscryptMode.Mode</code> is <code>OFF</code>, it will only   install BouncyCastle.</li> </ul> <p>This is closer to the way that it works on real android. Robolectric will search for a requested security primitive from Conscrypt first. If it does not support it, Robolectric will try BouncyCastle second.</p>"},{"location":"contributing/","title":"Contributor Guidelines","text":""},{"location":"contributing/#contributor-guidelines","title":"Contributor Guidelines","text":""},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>The first step to contributing is to ensure that you are able to build Robolectric. Please visit building Robolectric for more details and instructions on setting up an environment to build Robolectric.</p> <p>Once you are able to build Robolectric, create a feature branch to make your changes:</p> <pre><code>git checkout -b my-feature-name\n</code></pre> <p>Robolectric is built using Gradle. It is recommended to use Android Studio or IntelliJ to import the top-level <code>build.gradle.kts</code> file, which will automatically generate their project files from it.</p>"},{"location":"contributing/#contribution-requirements","title":"Contribution Requirements","text":""},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#java-code-style","title":"Java code style","text":"<p>Essentially the Android Studio/IntelliJ default Java style, but with two-space indents and Google-style imports.</p> <ol> <li>Spaces, not tabs.</li> <li>Two spaces indent.</li> <li>Curly braces for everything: <code>if</code>, <code>else</code>, etc.</li> <li>One line of white space between methods.</li> <li>No <code>'m'</code> or <code>'s'</code> prefixes before instance or static variables.</li> <li>Import Google's Java imports style (IntelliJ style file here).</li> </ol> <p>If your changes break the code style, the CI will fail, and your PR will be blocked. You can use <code>google-java-format</code> to format your code locally before you push your changes for reviewing. The wiki's <code>Running Google java format</code> section is a tutorial for it.</p>"},{"location":"contributing/#kotlin-code-style","title":"Kotlin code style","text":"<p>Robolectric uses Spotless + ktfmt to apply Google's code style for Kotlin. Please follow wiki's <code>Robolectric's code style</code> section to apply Kotlin format for Kotlin modules and code.</p>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<p>Robolectric is a unit testing framework, and it is important that Robolectric itself is very well tested. All classes should have unit test classes. All public methods should have unit tests. Those classes and methods should have their possible states well tested. Pull Requests without tests will be sent back to the submitter.</p> <p>If the change is related to third-party tool, e.g., Mockito and Mockk, please consider creating a dedicated module in Robolectric's <code>integration_tests</code> module to test third-party tool's regression.</p> <p>If tests need to check that an exception is thrown, use jUnit's <code>assertThrows</code> instead of <code>@Test(expected = SomeException.class)</code>. Using <code>assertThrows</code> allows more precision to check exactly which line throws a particular exception.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Robolectric uses javadoc to document API's behavior. There are special rules for javadoc on shadow classes:</p> <ul> <li>All <code>@Implementation</code> methods whose behavior varies from the standard Android behavior MUST have Javadoc describing the difference. Use <code>@see</code> or <code>{@link}</code> to indicate if the method's behavior can be changed or inspected by calling testing API methods. If the method's behavior is identical to the normal framework behavior, no javadoc is necessary.</li> <li>All visible non-<code>@Implementation</code> methods SHOULD have descriptive Javadoc.</li> <li>Don't write javadoc comments like \"Shadow for (whatever).\". The javadoc will appear in a section clearly related to testing, so make it make sense in context.</li> </ul> <p>Robolectric will release javadoc at https://robolectric.org/ after every main version released. For example, Robolectric's 4.13 javadoc is released at https://robolectric.org/javadoc/4.13/.</p>"},{"location":"contributing/#deprecations-and-backwards-compatibility","title":"Deprecations and Backwards Compatibility","text":"<p>To provide an easy upgrade path, we aim to always mark methods or classes <code>@Deprecated</code> in at least a patch release before removing them in the next minor release. We realize that's not quite how Semantic Versioning is supposed to work, sorry. Be sure to include migration notes in the <code>/** @deprecated */</code> javadoc!</p>"},{"location":"contributing/#pull-request-requirements","title":"Pull Request Requirements","text":"<p>Once your changes are ready, tested, and documented, you can submit them in a Pull Request targeting the <code>master</code> branch. Some automated checks will be executed against your PR to ensure that it adheres to Robolectric's quality requirements:</p> <ul> <li>Your PR should contain only one commit. If you need to push additional changes, please squash all commits into one.</li> <li>That commit should have a short title and a body describing your changes.</li> <li>Each line of the commit message should be less than 120 characters (unless that line contains a link).</li> <li>The code style, for both Java and Kotlin, is checked using the rules described above.</li> <li>Both unit and instrumented tests are executed.</li> </ul>"},{"location":"contributing/#discussion","title":"Discussion","text":"<p>Robolectric welcome discussion in the entire contribution cycle. If you have any idea or question, you can post on GitHub Discussion or Google Groups. The GitHub Discussion is the first choice for discussion if you have GitHub account, because it can help to accumulate community knowledge along with existing GitHub issues.   </p>"},{"location":"custom-test-runner/","title":"Customizing the Test Runner","text":"<p>There are several situations where you want to customize Robolectric's test runner to perform some operation before all tests are run, or even before each test method is run. One good example is initializing a dependency injection framework with a different set of dependencies for your test. Fortunately, Robolectric has a way to hook into the test lifecycle. If you define an <code>Application</code> class in your <code>AndroidManifest.xml</code> file, Robolectric will automatically try and load a test version of your <code>Application</code> class first.</p>"},{"location":"custom-test-runner/#hilt","title":"Hilt","text":"<p>If you're using Hilt, you can check the official Robolectric testing integration guide from Hilt.</p>"},{"location":"device-configuration/","title":"Device Configuration","text":"<p>Robolectric makes it easy to simulate a variety of device configurations. In particular, the properties that make up the <code>Configuration</code> class can be specified at the test method, test class, package, or suite level, as described here.</p>"},{"location":"device-configuration/#specifying-device-configuration","title":"Specifying device configuration","text":"<p>The Android device configuration can be specified using the <code>qualifiers</code> <code>@Config</code> argument:</p> JavaKotlin <pre><code>@Test\n@Config(qualifiers = \"fr-rFR-w360dp-h640dp-xhdpi\")\npublic void testItOnFrenchNexus5() {\n}\n</code></pre> <pre><code>@Test\n@Config(qualifiers = \"fr-rFR-w360dp-h640dp-xhdpi\")\nfun testItOnFrenchNexus5() {\n}\n</code></pre> <p>From version 3.6 on, Robolectric parses the <code>qualifiers</code> property according to the rules set forth here (but with no preceding directory name), and sets up the Android simulation environment with a corresponding configuration. The system's <code>Configuration</code>, <code>Display</code> and <code>DisplayMetrics</code> objects will all reflect the specified configuration, the locale will be set, and appropriate resources will be selected.</p> <p>For unspecified properties, Robolectric picks consistent values based on the properties that have been specified, or uses default values as follows:</p> Property Calculated value (if unspecified) Default Other rules MCC and MNC None None Language, region, and script (locale) None <code>en-rUS</code> Layout direction The locale\u2019s layout direction <code>ldltr</code> Smallest width The smallest of width and height <code>sw320dp</code> Width If screen size is specified, the corresponding width as declared here <code>w320dp</code> If screen orientation is specified, width and height will be swapped as appropriate Height If screen size is specified, the corresponding height as declared here. If screen aspect is specified as long, the height is increased by 25%. <code>h470dp</code> If screen orientation is specified, width and height will be swapped as appropriate Screen size If height and width are specified, the corresponding screen size as declared here <code>normal</code> Screen aspect If width and height are specified, long will be used if the ratio of height to width is at least 1.75 <code>notlong</code> Round screen If UI mode is watch then <code>round</code> <code>notround</code> Wide color gamut None <code>nowidecg</code> High dynamic range None <code>lowdr</code> Screen orientation If width and height are specified, <code>port</code> or <code>land</code> as appropriate <code>port</code> UI mode None <code>normal</code>, except this property isn't included in the qualifier list Night mode None <code>notnight</code> Screen pixel density None <code>mdpi</code> Touchscreen type None <code>finger</code> Keyboard availability None <code>keyssoft</code> Primary text input method None <code>nokeys</code> Navigation key availability None <code>navhidden</code> Primary non-touch navigation method None <code>nonav</code> Platform version The SDK level currently active. Need not be specified."},{"location":"device-configuration/#cumulative-qualifiers","title":"Cumulative qualifiers","text":"<p>By default, specifying qualifiers causes any previous specification of qualifiers to be ignored. For example, qualifiers at the test method level occlude qualifiers at the test class level. However, if the qualifiers config property starts with a <code>+</code> (plus sign), it is interpreted as an overlay to any higher-level qualifiers that have been specified:</p> JavaKotlin <pre><code>@Config(qualifiers = \"xlarge-port\")\npublic class MyTest {\n  @Test\n  public void testItWithXlargePort() {\n    // Config is \"xlarge-port\"\n  }\n\n  @Test\n  @Config(qualifiers = \"+land\")\n  public void testItWithXlargeLand() {\n    // Config is \"xlarge-land\"\n  }\n\n  @Test\n  @Config(qualifiers = \"land\")\n  public void testItWithLand() {\n    // Config is \"normal-land\"\n  }\n}\n</code></pre> <pre><code>@Config(qualifiers = \"xlarge-port\")\nclass MyTest {\n  @Test\n  fun testItWithXlargePort() {\n    // Config is \"xlarge-port\"\n  }\n\n  @Test\n  @Config(qualifiers = \"+land\")\n  fun testItWithXlargeLand() {\n    // Config is \"xlarge-land\"\n  }\n\n  @Test\n  @Config(qualifiers = \"land\")\n  fun testItWithLand() {\n    // Config is \"normal-land\"\n  }\n}\n</code></pre> <p>Values for unspecified properties are calculated, and rules are applied, after all configs have been merged.</p>"},{"location":"device-configuration/#changing-device-configuration","title":"Changing device configuration","text":"<p>The device configuration can be changed within a test using <code>RuntimeEnvironment.setQualifiers()</code>:</p> JavaKotlin <pre><code>@Test\n@Config(qualifiers = \"+port\")\npublic void testOrientationChange() {\n  MyActivity controller = Robolectric.buildActivity(MyActivity.class);\n  controller.setup();\n  // assert that activity is in portrait mode\n  RuntimeEnvironment.setQualifiers(\"+land\");\n  controller.configurationChange();\n  // assert that activity is in landscape mode\n}\n</code></pre> <pre><code>@Test\n@Config(qualifiers = \"+port\")\nfun testOrientationChange() {\n  val controller = Robolectric.buildActivity(MyActivity::class)\n  controller.setup()\n  // assert that activity is in portrait mode\n  RuntimeEnvironment.setQualifiers(\"+land\")\n  controller.configurationChange()\n  // assert that activity is in landscape mode\n}\n</code></pre> <p>The string parameter to <code>RuntimeEnvironment.setQualifiers()</code> has the same rules as <code>Config.qualifiers</code>.</p> <p>Note that <code>RuntimeEnvironment.setQualifiers()</code> updates the system and application resources with the new configuration, but does not trigger any action on extant activities or other components. <code>ActivityController.configurationChange()</code> can be used to simulate the sequence of events that take place on a device when its configuration changes.</p> <p>If the <code>Activity</code> is configured to handle the configuration changes, <code>ActivityController.configurationChange()</code> will call the <code>Activity</code>\u2019s <code>onConfigurationChanged()</code> method. If not, <code>ActivityController</code> destroys and recreates the <code>Activity</code>.</p>"},{"location":"device-configuration/#simulating-displays","title":"Simulating displays","text":"<p>Robolectric allows display properties to be changed during a test using setters on <code>ShadowDisplay</code>. Multiple displays can be simulated using APIs on <code>ShadowDisplayManager</code>.</p>"},{"location":"extending/","title":"Shadows","text":"<p>Robolectric works by creating a runtime environment that includes the real Android framework code. This means when your tests or code under test calls into the Android framework, you get a more realistic experience as for the most part the same code is executed as would be on a real device. However, there are limitations:</p> <ol> <li>Android native code cannot execute on your development machine.</li> <li>There are no Android system services running on your development machine.</li> <li>Android includes next to no APIs suitable for testing.</li> </ol> <p>Robolectric fills these gaps with a set of classes known as Shadows. Each shadow can modify or extend the behavior of a corresponding class in the Android OS. When an Android class is instantiated, Robolectric looks for a corresponding shadow class, and if it finds one, it creates a shadow object to associate with it.</p> <p>Using byte code instrumentation, Robolectric is able to weave in cross-platform fake implementations to substitute for native code and add additional APIs to make testing possible.</p>"},{"location":"extending/#whats-in-a-name","title":"What's in a Name?","text":"<p>Why \"Shadow\"? Shadow objects are not quite Proxies, not quite Fakes, not quite Mocks or Stubs. Shadows are sometimes hidden, sometimes seen, and can lead you to the real object. At least we didn't call them \"sheep\", which we were considering.</p>"},{"location":"extending/#shadow-classes","title":"Shadow Classes","text":"<p>Shadow classes always need a public no-arg constructor so that the Robolectric framework can instantiate them. They are associated to the class that they Shadow with an <code>@Implements</code> annotation on the class declaration.</p> <p>Shadow classes should mimic the production classes' inheritance hierarchy. For example, if you are implementing a Shadow for <code>ViewGroup</code>, <code>ShadowViewGroup</code>, then your Shadow class should extend <code>ViewGroup</code>'s superclass' Shadow, <code>ShadowView</code>.</p> JavaKotlin <pre><code>@Implements(ViewGroup.class)\npublic class ShadowViewGroup extends ShadowView {\n}\n</code></pre> <pre><code>@Implements(ViewGroup::class)\nclass ShadowViewGroup : ShadowView\n</code></pre>"},{"location":"extending/#methods","title":"Methods","text":"<p>Shadow objects implement methods that have the same signature as the corresponding Android class. Robolectric will invoke the method on a Shadow object when a method with the same signature on the Android object is invoked.</p> <p>Suppose an application defined the following line of code:</p> JavaKotlin <pre><code>imageView.setImageResource(R.drawable.robolectric_logo);\n</code></pre> <pre><code>imageView.setImageResource(R.drawable.robolectric_logo)\n</code></pre> <p>Under test, the <code>ShadowImageView#setImageResource(int resId)</code> method on the Shadow instance would be invoked.</p> <p>Shadow methods must be marked with the <code>@Implementation</code> annotation. Robolectric includes a lint test to help ensure this is done correctly.</p> JavaKotlin <pre><code>@Implements(ImageView.class)\npublic class ShadowImageView extends ShadowView {\n  @Implementation\n  protected void setImageResource(int resId) {\n    // Implementation goes here\n  }\n}\n</code></pre> <pre><code>@Implements(ImageView::class)\nclass ShadowImageView : ShadowView {\n  @Implementation\n  protected fun setImageResource(resId: Int) {\n    // Implementation goes here\n  }\n}\n</code></pre> <p>Robolectric supports shadowing all methods on the original class, including <code>private</code>, <code>static</code>, <code>final</code> or <code>native</code>.</p> <p>Typically <code>@Implementation</code> methods should have the <code>protected</code> modifier. The intention is to reduce the API surface area of the Shadows; the test author should always call such methods on the Android framework class directly.</p> <p>It is important that shadow methods are implemented on the corresponding shadow of the class in which they were originally defined. Otherwise, Robolectric's lookup mechanism will not find them (even if they have been declared on a shadow subclass). For example, the method <code>setEnabled()</code> is defined on <code>View</code>. If a <code>setEnabled()</code> method is defined on <code>ShadowViewGroup</code> instead of <code>ShadowView</code> then it will not be found at run time even when <code>setEnabled()</code> is called on an instance of <code>ViewGroup</code>.</p>"},{"location":"extending/#shadowing-constructors","title":"Shadowing Constructors","text":"<p>Once a Shadow object is instantiated, Robolectric will look for a method named  <code>__constructor__</code> and annotated with <code>@Implementation</code> which has the same arguments as the constructor that was invoked on the real object.</p> <p>For instance, if the application code was to invoke the <code>TextView</code> constructor which receives a <code>Context</code>:</p> JavaKotlin <pre><code>new TextView(context);\n</code></pre> <pre><code>TextView(context)\n</code></pre> <p>Robolectric would invoke the following  <code>__constructor__</code> method that receives a <code>Context</code>:</p> JavaKotlin <pre><code>@Implements(TextView.class)\npublic class ShadowTextView {\n  @Implementation\n  protected void __constructor__(Context context) {\n    this.context = context;\n  }\n}\n</code></pre> <pre><code>@Implements(TextView::class)\nclass ShadowTextView {\n  @Implementation\n  protected fun __constructor__(context: Context) {\n    this.context = context\n  }\n</code></pre>"},{"location":"extending/#getting-access-to-the-real-instance","title":"Getting access to the real instance","text":"<p>Sometimes Shadow classes may want to refer to the object they are shadowing, e.g., to manipulate fields. A Shadow class can achieve this by declaring a field annotated with <code>@RealObject</code>:</p> JavaKotlin <pre><code>@Implements(Point.class)\npublic class ShadowPoint {\n  @RealObject private Point realPoint;\n\n  public void __constructor__(int x, int y) {\n    realPoint.x = x;\n    realPoint.y = y;\n  }\n}\n</code></pre> <pre><code>@Implements(Point::class)\nclass ShadowPoint {\n  @RealObject private lateinit var realPoint: Point\n\n  fun __constructor__(x: Int, y: Int) {\n    realPoint.x = x\n    realPoint.y = y\n  }\n}\n</code></pre> <p>Robolectric will set <code>realPoint</code> to the actual instance of <code>Point</code> before invoking any other methods.</p> <p>It is important to note that methods called on the real object will still be intercepted and redirected by Robolectric. This does not often matter in test code, but it has important implications for Shadow class implementors. Since the Shadow class inheritance hierarchy does not always mirror that of their associated Android classes, it is sometimes necessary to make calls through these real objects so that the Robolectric runtime will have the opportunity to route them to the correct Shadow class based on the actual class of the object. Otherwise, methods on Shadows of base classes would be unable to access methods on the Shadows of their subclasses.</p> <p>Methods on your shadow class are able to call through to the Android OS code, using <code>Shadow.directlyOn()</code>.</p>"},{"location":"extending/#custom-shadows","title":"Custom Shadows","text":"<p>Robolectric is a work in progress and we rely, welcome and strongly encourage contributions from the community for bug fixes and feature gaps. However, if you wish to modify shadow behavior in a way that is not appropriate for sharing, or you can't wait for a new release to include a critical fix we do support custom shadows.</p>"},{"location":"extending/#writing-a-custom-shadow","title":"Writing a Custom Shadow","text":"<p>Custom shadows are structured much the same as normal shadow classes. They must include the <code>@Implements</code> annotation on the class definition. You can use the normal shadow implementation options, such as shadowing instance methods using <code>@Implementation</code> or shadowing constructors using <code>__constructor__()</code> methods. Your shadow class may also extend one of the stock Robolectric shadows if you like.</p> JavaKotlin <pre><code>@Implements(Bitmap.class)\npublic class MyShadowBitmap {\n  @RealObject private Bitmap realBitmap;\n  private int bitmapQuality = -1;\n\n  @Implementation\n  public boolean compress(Bitmap.CompressFormat format, int quality, OutputStream stream) {\n    bitmapQuality = quality;\n    return realBitmap.compress(format, quality, stream);\n  }\n\n  public int getQuality() {\n    return bitmapQuality;\n  }\n}\n</code></pre> <pre><code>@Implements(Bitmap::class)\nclass MyShadowBitmap {\n  @RealObject private lateinit var realBitmap: Bitmap\n  private var bitmapQuality: Int = -1\n\n  @Implementation\n  fun compress(format: Bitmap.CompressFormat, quality: Int, stream: OutputStream): Boolean {\n    bitmapQuality = quality\n    return realBitmap.compress(format, quality, stream)\n  }\n\n  fun getQuality(): Int {\n    return bitmapQuality\n  }\n}\n</code></pre>"},{"location":"extending/#using-a-custom-shadows","title":"Using a Custom Shadows","text":"<p>Custom Shadows get hooked up to Robolectric using the <code>@Config</code> annotation on the test class or test method, using the <code>shadows</code> array attribute. To use the <code>MyShadowBitmap</code> class mentioned in the previous section, you would annotate the test in question with <code>@Config(shadows = { MyShadowBitmap.class })</code>. This causes Robolectric to recognize and use your custom shadow when executing code against the class you shadowed.</p> <p>If you would like your custom shadows to be applied to all tests in your suite or a certain package, you can configure shadows through the <code>robolectric.properties</code> file.</p> <p>Note, by default <code>Shadows.shadowOf()</code> method will not work with custom shadows. You can instead use <code>Shadow.extract()</code> and cast the return value to the custom Shadow class you implemented.</p>"},{"location":"extending/#building-a-library-of-custom-shadows","title":"Building a library of Custom Shadows","text":"<p>If you find yourself building a library of custom shadows, you should consider running Robolectric's shadow annotation processor on your library of shadows. This provides a number of benefits such as:</p> <ol> <li>Generating <code>shadowOf</code> methods for each of your shadows.</li> <li>Generating a <code>ServiceLoader</code> so your custom shadows are automatically applied if found on the    classpath.</li> <li>Invoking any <code>static</code> <code>@Resetter</code> methods on teardown to enable you to    reset static state.</li> <li>Perform additional validation and checking on your shadows.</li> </ol> GroovyKotlin <pre><code>android {\n  defaultConfig {\n    javaCompileOptions {\n      annotationProcessorOptions {\n        className 'org.robolectric.annotation.processing.RobolectricProcessor'\n        arguments = ['org.robolectric.annotation.processing.shadowPackage': 'com.example.myshadowpackage']\n      }\n    }\n  }\n}\n\ndependencies {\n  annotationProcessor 'org.robolectric:processor:4.16'\n}\n</code></pre> <p>When you write your shadows in Kotlin, configure <code>kapt</code>:</p> <pre><code>plugins {\n  id(\"kotlin-kapt\")\n}\n\nkapt {\n  arguments {\n    arg(\"org.robolectric.annotation.processing.shadowPackage\", \"com.example.myshadowpackage\")\n  }\n}\n\ndependencies {\n  kapt(\"org.robolectric:processor:4.16\")\n}\n</code></pre>"},{"location":"extending/#best-practices","title":"Best practices","text":""},{"location":"extending/#limit-api-surface-area-of-shadows","title":"Limit API surface area of shadows","text":"<p>Since Robolectric 3.7 <code>@Implementation</code> methods including <code>__constructor__</code> methods can be made <code>protected</code>. This is desirable as test code has no business calling these methods, by making your <code>@Implementation</code> methods protected you encourage test writers to call the public Android APIs instead.</p>"},{"location":"extending/#dont-override-equals-hashcode-and-tostring-in-shadows","title":"Don't override <code>equals</code>, <code>hashCode</code> and <code>toString</code> in shadows","text":"<p>Avoid this unless you are mimicking behaviour in the class being shadowed. To test equality for comparisons in tests prefer helpers or assertion library extensions. Prefer adding a <code>describe()</code> method instead of shadowing <code>toString()</code>.</p>"},{"location":"extending/#write-high-quality-shadows-that-promote-testing-behavior-rather-than-implementation","title":"Write high quality shadows that promote testing behavior rather than implementation","text":"<p>Rather than using shadows as glorified argument captors, prefer writing a shadow that encourages testing behaviour. For example, don't add a method that exposes registered listeners, rather add an <code>@Implementation</code> for a method that would invoke those listeners.</p>"},{"location":"extending/#use-caution-when-shadowing-your-own-code","title":"Use caution when shadowing your own code","text":"<p>Robolectric provides a lot of power which requires responsible usage. Shadows are ideal for testing interaction with the Android framework as the framework doesn't support dependency injection and makes liberal use of static code. Before writing custom shadows for your own code, consider if you can't better refactor your code and use a popular mocking library such as Mockito.</p>"},{"location":"extending/#support-the-community","title":"Support the community","text":"<p>Please contribute your enhancements to Robolectric. This will help the community and reduce the bloat in your own codebase.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Robolectric works with various build systems, which are documented on this page. If you are starting a new project, we recommend Gradle as a first choice, since it is the default build system for Android.</p>"},{"location":"getting-started/#building-with-gradle","title":"Building with Gradle","text":"<p>Start by adding the following to your module's <code>build.gradle</code>/<code>build.gradle.kts</code> file:</p> GroovyKotlin <pre><code>android {\n  testOptions {\n    unitTests {\n      includeAndroidResources = true\n    }\n  }\n}\n\ndependencies {\n  testImplementation 'junit:junit:4.13.2'\n  testImplementation 'org.robolectric:robolectric:4.16'\n}\n</code></pre> <pre><code>android {\n  testOptions {\n    unitTests {\n      isIncludeAndroidResources = true\n    }\n  }\n}\n\ndependencies {\n  testImplementation(\"junit:junit:4.13.2\")\n  testImplementation(\"org.robolectric:robolectric:4.16\")\n}\n</code></pre> <p>Then, mark your test to run with <code>RobolectricTestRunner</code>:</p> JavaKotlin <pre><code>import org.robolectric.RobolectricTestRunner;\n\n@RunWith(RobolectricTestRunner.class)\npublic class SandwichTest {\n}\n</code></pre> <pre><code>import org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass SandwichTest\n</code></pre>"},{"location":"getting-started/#building-with-bazel","title":"Building with Bazel","text":"<p>Robolectric works with Bazel 0.10.0 or higher. Bazel integrates with Robolectric through the <code>android_local_test</code> rule. The Robolectric Java/Kotlin test code is the same for a Bazel project as for a Gradle project (see section above).</p> <p>Robolectric needs to be added as a dependency to your Bazel project with <code>rules_jvm_external</code>. Add the following to your <code>WORKSPACE</code> file:</p> <pre><code>http_archive(\n    name = \"robolectric\",\n    sha256 = \"f7b8e08f246f29f26fddd97b7ab5dfa01aaa6170ccc24b9b6a21931bde01ad6f\",\n    strip_prefix = \"robolectric-bazel-4.12.2\",\n    urls = [\"https://github.com/robolectric/robolectric-bazel/releases/download/4.12.2/robolectric-bazel-4.12.2.tar.gz\"],\n)\nload(\"@robolectric//bazel:robolectric.bzl\", \"robolectric_repositories\")\n\nrobolectric_repositories()\n\nhttp_archive(\n    name = \"rules_jvm_external\",\n    sha256 = \"d31e369b854322ca5098ea12c69d7175ded971435e55c18dd9dd5f29cc5249ac\",\n    strip_prefix = \"rules_jvm_external-5.3\",\n    url = \"https://github.com/bazelbuild/rules_jvm_external/releases/download/5.3/rules_jvm_external-5.3.tar.gz\",\n)\nload(\"@rules_jvm_external//:defs.bzl\", \"maven_install\")\n\nmaven_install(\n    name = \"maven\",\n    artifacts = [\n        \"com.google.truth:truth:1.1.3\",\n        \"org.robolectric:robolectric:4.16\",\n    ],\n    repositories = [\n        \"https://maven.google.com\",\n        \"https://repo1.maven.org/maven2\",\n    ],\n)\n</code></pre> <p>Add an <code>android_local_test</code> rule to your <code>BUILD</code> file:</p> <pre><code>android_local_test(\n    name = \"greeter_activity_test\",\n    srcs = [\"GreeterTest.java\"],\n    manifest = \"TestManifest.xml\",\n    test_class = \"com.example.bazel.GreeterTest\",\n    deps = [\n        \":greeter_activity\",\n        \"@maven//:org_robolectric_robolectric\",\n        \"@robolectric//bazel:android-all\",\n    ],\n)\n</code></pre> <p>Note</p> <p>These instructions use <code>robolectric-bazel</code> 4.12.2 and <code>rules_jvm_external</code> 5.3. Please check <code>robolectric-bazel</code>'s latest release for up-to-date information.</p> <p>If you have any question about Bazel integration, we recommend to check <code>robolectric-bazel</code> first, and file an issue there if you need assistance.</p>"},{"location":"getting-started/#building-with-maven","title":"Building with Maven","text":"<p>Start by adding the following to your module's <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.robolectric&lt;/groupId&gt;\n    &lt;artifactId&gt;robolectric&lt;/artifactId&gt;\n    &lt;version&gt;4.16&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Then, mark your test to run with <code>RobolectricTestRunner</code>:</p> JavaKotlin <pre><code>import org.robolectric.RobolectricTestRunner;\n\n@RunWith(RobolectricTestRunner.class)\npublic class SandwichTest {\n}\n</code></pre> <pre><code>import org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\nclass SandwichTest\n</code></pre>"},{"location":"getting-started/#using-libraries","title":"Using libraries","text":"<p>If you use Maven to build your application, you will need to tell Robolectric where the unpacked resources are located for each library you use. This can either be specified with the <code>@Config</code> annotation:</p> JavaKotlin <pre><code>import org.robolectric.RobolectricTestRunner;\n\n@RunWith(RobolectricTestRunner.class)\n@Config(libraries = {\n  \"build/unpacked-libraries/library1\",\n  \"build/unpacked-libraries/library2\"\n})\npublic class SandwichTest {\n}\n</code></pre> <pre><code>import org.robolectric.RobolectricTestRunner\n\n@RunWith(RobolectricTestRunner::class)\n@Config(libraries = [\n  \"build/unpacked-libraries/library1\",\n  \"build/unpacked-libraries/library2\"\n])\nclass SandwichTest\n</code></pre> <p>or specified in the <code>robolectric.properties</code> file:</p> <pre><code>libraries=build/unpacked-libraries/library1,build/unpacked-libraries/library2\n</code></pre> <p>All paths are relative to the root directory of the project.</p>"},{"location":"getting-started/#debugging-resource-loading-issues","title":"Debugging resource loading issues","text":"<p>If you are not sure if resources are being loaded for a particular library, enable debug logging by setting the system property <code>robolectric.logging.enabled = true</code> and run your tests. You should see lots of output like:</p> <pre><code>Loading resources for 'com.foo' from build/unpacked-libraries/library1...\n</code></pre> <p>If you don't see a particular library in the list, double-check the configuration.</p> <p>If you reference resources that are outside of your project (i.e. in an AAR dependency), you will need to provide Robolectric with a pointer to the exploded AAR in your build system. See using libraries above for more information.</p>"},{"location":"getting-started/#additional-resources","title":"Additional resources","text":"<ul> <li>Build system integration</li> <li>Build with Buck</li> <li>Build with Buck2</li> <li>Android's Testing samples</li> </ul>"},{"location":"simulator/","title":"Robolectric Simulator","text":"<p>Starting with Robolectric 4.15, it's possible to launch an interactive preview of your app or tests in a Robolectric environment. This has been made possible with the significant enhancements to Robolectric over the past four years, particularly related to native graphics.</p> <p>Note that the Robolectric simulator is highly experimental and is still largely in the proof-of-concept stage. If you encounter issues, please file bugs on the Robolectric repository. Problems you experience when running the simulator are likely problems in Robolectric itself and can help drive improvements to the testing framework.</p> <p>The Robolectric simulator can be a useful way to preview how your UI would look in a Robolectric environment. This can be helpful, for instance, when debugging failing Robolectric tests. Also note that UI rendered in the Robolectric simulator may not match an Android emulator or device 100%.</p>"},{"location":"simulator/#launching-the-simulator","title":"Launching the simulator","text":"<p>There are two ways to launch the simulator: with the simulator Gradle plugin or by invoking the simulator APIs from tests.</p>"},{"location":"simulator/#using-the-gradle-plugin","title":"Using the Gradle plugin","text":"<p>To enable the Robolectric simulator with the Gradle plugin, add the plugin to the <code>plugins</code> block of your app's <code>build.gradle</code>/<code>build.gradle.kts</code> file:</p> <p>simulator-gradle-plugin</p> GroovyKotlin <pre><code>id 'org.robolectric.simulator' version '1.0.3'\n</code></pre> <pre><code>id(\"org.robolectric.simulator\") version \"1.0.3\"\n</code></pre> <p>To enable the simulator to work with JDK 23 and newer, you must add the following extra jvmArgs to your unit test configuration:</p> <p>simulator-jvmArgs-configurations</p> GroovyKotlin <pre><code>testOptions {\n    unitTests.all { test -&gt;\n        test.jvmArgs += [\n                \"--add-exports=java.desktop/sun.awt=ALL-UNNAMED\",\n                \"--add-exports=java.base/sun.reflect.misc=ALL-UNNAMED\",\n                \"--add-exports=java.base/sun.security.action=ALL-UNNAMED\",\n                \"--add-exports=java.desktop/sun.swing=ALL-UNNAMED\",\n                \"--add-exports=java.desktop/sun.lwawt.macosx=ALL-UNNAMED\"\n        ]\n    }\n}\n</code></pre> <pre><code>testOptions {\n    unitTests {\n        all { test -&gt;\n            test.jvmArgs(\n                \"--add-exports=java.desktop/sun.awt=ALL-UNNAMED\",\n                \"--add-exports=java.base/sun.reflect.misc=ALL-UNNAMED\",\n                \"--add-exports=java.base/sun.security.action=ALL-UNNAMED\",\n                \"--add-exports=java.desktop/sun.swing=ALL-UNNAMED\",\n                \"--add-exports=java.desktop/sun.lwawt.macosx=ALL-UNNAMED\",\n            )\n        }\n    }\n}\n</code></pre> <p>Then, run <code>./gradlew simulate&lt;variant&gt;</code> (for example, <code>./gradlew simulateDebug</code> or <code>./gradlew simulateDemoDebug</code>) to start the simulator for the <code>&lt;variant&gt;</code> build variant. It will run the main <code>Activity</code> that is configured in your manifest.</p> <p>If the simulator Gradle plugin is not working for you, it is equivalent to running the example code below in the standalone API.</p>"},{"location":"simulator/#standalone-api","title":"Standalone API","text":"<p>Inside a Robolectric test, you can also start the simulator using the standalone API. To do this, first add a dependency to the simulator in your project's <code>build.gradle</code>/<code>build.gradle.kts</code> file.</p> <p>The following example sets up an <code>Activity</code> and subsequently starts the simulator to preview the <code>Activity</code>.</p> <p>Simulator dependency</p> GroovyKotlin <pre><code>testImplementation 'org.robolectric:simulator:4.16'\n</code></pre> <pre><code>testImplementation(\"org.robolectric:simulator:4.16\")\n</code></pre> <p>Next, you can create a Simulator object and start it using:</p> <p>Simulator API</p> JavaKotlin <pre><code>import static android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM;\n\nimport org.robolectric.annotation.GraphicsMode;\nimport org.robolectric.simulator.Simulator;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.Robolectric;\nimport org.robolectric.RobolectricTestRunner;\nimport org.robolectric.annotation.Config;\n\n@RunWith(RobolectricTestRunner.class)\n@Config(sdk = VANILLA_ICE_CREAM)\n@GraphicsMode(GraphicsMode.Mode.NATIVE)\npublic class MainActivityTest {\n  @Test\n  public void simulateMainActivity() throws Exception {\n    Robolectric.setupActivity(MainActivity.class);\n    new Simulator().start();\n  }\n}\n</code></pre> <pre><code>import android.os.Build.VERSION_CODES.VANILLA_ICE_CREAM\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.Robolectric\nimport org.robolectric.RobolectricTestRunner\nimport org.robolectric.annotation.Config\nimport org.robolectric.annotation.GraphicsMode\nimport org.robolectric.simulator.Simulator\n\n@RunWith(RobolectricTestRunner::class)\n@Config(sdk = [VANILLA_ICE_CREAM])\n@GraphicsMode(GraphicsMode.Mode.NATIVE)\nclass MainActivityTest {\n    @Test\n    fun simulateMainActivity() {\n        Robolectric.setupActivity(MainActivity::class.java)\n        Simulator().start()\n    }\n}\n</code></pre> <p>This approach is good if your top-level <code>Activity</code> is unable to be started using the Gradle plugin.</p>"},{"location":"upgrade_to_version_3/","title":"Upgrade to Robolectric 3.x","text":""},{"location":"upgrade_to_version_3/#migrating-to-36","title":"Migrating to 3.6","text":"<p>Previously, Robolectric's <code>Display</code> and <code>DisplayMetrics</code> dimensions defaulted to 480\u00d7800px, regardless of screen size and density. Now they match the requested configuration, which defaults to 320\u00d7470dp mdpi. Tests which rely on the old dimensions for layouts, pixel math, etc. can be modified for new dimensions, or by pinning them to the old size: <code>@Config(qualifiers = \"w480dp-h800dp\")</code>.</p> 3.5 3.6 <code>Shadow.newInstanceOf(Display.class)</code> <code>ShadowDisplay.getDefaultDisplay()</code>"},{"location":"upgrade_to_version_3/#migrating-to-34","title":"Migrating to 3.4","text":""},{"location":"upgrade_to_version_3/#dependencies","title":"Dependencies","text":"<p>Robolectric tests should now be compiled with Java 8 and Android API 26.</p>"},{"location":"upgrade_to_version_3/#packagemanager","title":"PackageManager","text":"<p>We've change <code>PackageManager</code> simulation to follow the standard Shadow pattern as with other framework classes. You can use <code>ShadowPackageManager</code> where you previously used <code>RobolectricPackageManager</code>.</p> 3.3 (was <code>@Deprecated</code>) 3.4 <code>org.robolectric.res.builder.RobolectricPackageManager</code> <code>ShadowPackageManager</code> <code>RuntimeEnvironment.getRobolectricPackageManager()</code> <code>shadowOf(RuntimeEnvironment.application.getPackageManager())</code> <p>If you were using <code>RuntimeEnvironment.setRobolectricPackageManager()</code> to install a custom <code>PackageManager</code>, you should move your custom behavior to a subclass of <code>ShadowApplicationPackageManager</code> and install it as a shadow (using <code>@Config</code> and possibly <code>@Implements(inheritImplementationMethods = true)</code>) instead.</p>"},{"location":"upgrade_to_version_3/#activitycontrollerattach","title":"<code>ActivityController.attach()</code>","text":"<p>The deprecated and redundant <code>attach()</code> method has been removed from <code>ActivityController</code>, <code>FragmentController</code>, and <code>ServiceController</code>. To migrate, remove calls to this method.</p>"},{"location":"upgrade_to_version_3/#other-stuff","title":"Other Stuff","text":"<ul> <li>Because <code>SharedPreferences</code> now uses real Android framework   code, Mockito mocks and spies can lead to tests hanging. Rather than spying on   <code>SharedPreferences</code>, directly assert against its state.</li> </ul>"},{"location":"upgrade_to_version_3/#migrating-to-33","title":"Migrating to 3.3","text":""},{"location":"upgrade_to_version_3/#moved-classes","title":"Moved classes","text":"<p>To simplify classloader logic and cleanup packages, some classes have moved. The old class locations are <code>@Deprecated</code> and will be removed in 3.4.</p> 3.2 (now <code>@Deprecated</code>) 3.3 <code>org.robolectric.internal.Shadow</code> <code>org.robolectric.shadow.api.Shadow</code> <code>org.robolectric.internal.ShadowExtractor.extract()</code> <code>org.robolectric.shadow.api.Shadow.extract()</code> <code>org.robolectric.util.ActivityController</code> <code>org.robolectric.android.controller.ActivityController</code> <code>org.robolectric.util.ContentProviderController</code> <code>org.robolectric.android.controller.ContentProviderController</code> <code>org.robolectric.util.FragmentController</code> <code>org.robolectric.android.controller.FragmentController</code> <code>org.robolectric.util.IntentServiceController</code> <code>org.robolectric.android.controller.IntentServiceController</code> <code>org.robolectric.util.ServiceController</code> <code>org.robolectric.android.controller.ServiceController</code> <code>org.robolectric.util.AccessibilityUtil</code> <code>org.robolectric.android.AccessibilityUtil</code> <code>org.robolectric.util.ApplicationTestUtil</code> <code>org.robolectric.android.ApplicationTestUtil</code> <code>org.robolectric.res.builder.StubPackageManager</code> <code>org.robolectric.android.StubPackageManager</code> \u26a0\ufe0f <code>org.robolectric.res.builder.XmlResourceParserImpl</code> <code>org.robolectric.android.XmlResourceParserImpl</code> \u26a0\ufe0f <code>org.robolectric.internal.fakes.RoboCharsets</code> <code>org.robolectric.android.fakes.RoboCharsets</code> \u26a0\ufe0f <code>org.robolectric.internal.fakes.RoboExtendedResponseCache</code> <code>org.robolectric.android.fakes.RoboExtendedResponseCache</code> \u26a0\ufe0f <code>org.robolectric.util.concurrent.RoboExecutorService</code> <code>org.robolectric.android.util.concurrent.RoboExecutorService</code> \u26a0\ufe0f <p>\u26a0\ufe0f Only use these classes if you really need too</p>"},{"location":"upgrade_to_version_3/#packagemanager_1","title":"<code>PackageManager</code>","text":"<p>We have begun the process of switching from using a subclass of <code>PackageManager</code> towards <code>PackageManager</code> being implemented by a standard shadow, as we do for the rest of the framework. This is for a number of reasons:</p> <ul> <li>It is more consistent with the way other framework code is handled.</li> <li>A shadow will allow users' tests to build against any version of Android.</li> <li>Switching to a shadow will allow us to defer parsing the manifest until the test or code under   test makes calls to the <code>PackageManager</code>.</li> </ul> <p>This should all be backwards compatible for the 3.3 release, but now you can start migrating your code.</p> <p>Before, the Robolectric class <code>DefaultPackageManager</code> implemented all <code>PackageManager</code> functionality. If you wanted to change any of its behavior, you'd extend <code>DefaultPackageManager</code> (or <code>StubPackageManager</code>) and override whichever methods you liked. Test-related setup was achieved by calling <code>RuntimeEnvironment.getRobolectricPackageManager()</code>, which had extra methods for modifying its behavior.</p> <p>As of 3.3, Robolectric uses the normal Android <code>ApplicationPackageManager</code>, and shadows all of its methods, causing it to delegate to an instance of <code>DefaultPackageManager</code>, which works as before. You can still replace it with your own subclass of <code>PackageManager</code> if you like, but that's deprecated. Instead of doing that, put your custom behavior in a subclass of <code>ShadowApplicationPackageManager</code>. For test-related setup, you can still access it through <code>RuntimeEnvironment.getRobolectricPackageManager()</code>, but you should start using <code>shadowOf(PackageManager)</code> instead. Note that we've implemented quite a bit more of <code>PackageManager</code>, so you might not need any custom code any longer.</p> <p>Starting with 3.4, <code>DefaultPackageManager</code> will be removed and its functionality will be moved into <code>ShadowApplicationPackageManager</code>. In general, we recommand using Android Framework APIs where possible.</p> 3.2 (now <code>@Deprecated</code>) 3.3 <code>RobolectricPackageManager rpm = RuntimeEnvironment.getRobolectricPackageManager();</code> <code>ShadowPackageManager shadowPackageManager = shadowOf(context.getPackageManager());</code> <code>PackageManager packageManager = RuntimeEnvironment.getPackageManager();</code> <code>PackageManager packageManager = context.getPackageManager();</code> <code>RuntimeEnvironment.setRobolectricPackageManager(customPackageManager);</code> Use a custom shadow instead! See below. <p>Replace subclasses of <code>DefaultPackageManager</code> by a custom shadow (and be a good citizen by contributing your enhancements upstream \ud83d\ude42):</p> JavaKotlin <pre><code>@Implements(value = ApplicationPackageManager.class, inheritImplementationMethods = true)\npublic class MyCustomPackageManager extends ShadowApplicationPackageManager {\n}\n</code></pre> <pre><code>@Implements(value = ApplicationPackageManager::class, inheritImplementationMethods = true)\nclass MyCustomPackageManager : ShadowApplicationPackageManager\n</code></pre> <p>If you are using a custom subclass of <code>DefaultPackageManager</code> to implement functionality missing in Robolectric, check again as part of this work we've added support for a bunch more widely-used <code>PackageManager</code> features, and it might be now possible to completely remove your custom subclass.</p>"},{"location":"upgrade_to_version_3/#deprecated-classes-methods","title":"Deprecated Classes &amp; Methods","text":"3.2 (now <code>@Deprecated</code>) 3.3 <code>org.robolectric.res.builder.RobolectricPackageManager</code> <code>org.robolectric.shadows.ShadowPackageManager</code> <code>RuntimeEnvironment.getRobolectricPackageManager()</code> <code>shadowOf(RuntimeEnvironment.application.getPackageManager())</code> <code>shadowOf(imageView).getImageResourceId()</code> <code>shadowOf(imageView.getDrawable)</code>.<code>getCreatedFromResId()</code> <code>shadowOf(notification).getProgressBar().isIndeterminate()</code> <code>shadowOf(notification)</code>.<code>isIndeterminate()</code> <p>The following methods and classes are deprecated will be removed in 3.4:</p> <ul> <li><code>RuntimeEnvironment.getPackageManager()</code></li> <li><code>RuntimeEnvironment.getRobolectricPackageManager()</code></li> <li><code>RuntimeEnvironment.setRobolectricPackageManager()</code></li> <li><code>DefaultPackageManager</code></li> <li><code>StubPackageManager</code></li> <li><code>RobolectricPackageManager</code></li> </ul>"},{"location":"upgrade_to_version_3/#new-gradle-integration","title":"New Gradle integration","text":"<p>Starting with Robolectric 3.3 and Android Studio 3.0 alpha 5, we've included better integration with the tool chain. Resources, assets and <code>AndroidManifest.xml</code> are treated as first-class citizens and processed by the build system for correctness, performance and stability between releases. Read more here.</p>"},{"location":"upgrade_to_version_3/#migrating-to-32","title":"Migrating to 3.2","text":""},{"location":"upgrade_to_version_3/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>If you were providing custom configuration by subclassing and overriding methods on <code>RobolectricTestRunner</code>, you'll need to make some changes.</p> <p><code>RobolectricTestRunner.getConfigProperties()</code> should be replaced by overriding <code>RobolectricTestRunner.buildGlobalConfig()</code>.</p>"},{"location":"upgrade_to_version_3/#old-code","title":"Old code","text":"JavaKotlin <pre><code>public class MyTestRunner extends RobolectricTestRunner {\n  @Override protected Properties getConfigProperties() {\n    Properties props = new Properties();\n    props.setProperty(\"sdk\", \"23\");\n    return props;\n  }\n}\n</code></pre> <pre><code>class MyTestRunner : RobolectricTestRunner {\n  override protected fun getConfigProperties(): Properties {\n    val props = Properties()\n    props.setProperty(\"sdk\", \"23\")\n    return props\n  }\n}\n</code></pre>"},{"location":"upgrade_to_version_3/#new-code","title":"New code","text":"JavaKotlin <pre><code>public class MyTestRunner extends RobolectricTestRunner {\n  @Override protected Config buildGlobalConfig() {\n    return new Config.Builder().setSdk(23).build();\n  }\n}\n</code></pre> <pre><code>class MyTestRunner : RobolectricTestRunner {\n  override protected fun buildGlobalConfig(): Config {\n    return Config.Builder().setSdk(23).build()\n  }\n}\n</code></pre>"},{"location":"upgrade_to_version_3/#package-level-configuration","title":"Package-Level Configuration","text":"<p>If you are using a <code>robolectric.properties</code> file to configure all tests, the expected location of the file has been changed.</p> 3.1 3.2 <code>src/test/resources/robolectric.properties</code> <code>src/test/resources/your/package/robolectric.properties</code>"},{"location":"upgrade_to_version_3/#migrating-to-31","title":"Migrating to 3.1","text":""},{"location":"upgrade_to_version_3/#changes","title":"Changes","text":"<ul> <li>To construct an Android components such as an <code>Activity</code>, a   <code>Service</code> or a <code>ContentProvider</code>, you   must now use the Robolectric APIs such as   <code>Robolectric.buildActivity()</code>,   <code>Robolectric.buildService()</code>, or   <code>Robolectric.buildContentProvider()</code>, or the   corresponding <code>setup*()</code> methods; you should not create new instances of these classes yourself.   Calling these methods will create an instance of the component and attach its base   <code>Context</code>. This is now necessary as we've removed code shadowing   <code>Context</code> and <code>ContextWrapper</code> in favor of using real framework   code to improve fidelity.</li> </ul> JavaKotlin <pre><code>Robolectric.buildService(MyService.class).create().get();\nRobolectric.setupContentProvider(MyContentProvider.class);\n</code></pre> <pre><code>Robolectric.buildService(MyService::class).create().get()\nRobolectric.setupContentProvider(MyContentProvider::class)\n</code></pre> <ul> <li>We've removed shadow methods where they duplicate the functionality of the Android APIs. In   general, prefer calling Android framework APIs over Robolectric shadows where possible.</li> </ul> 3.0 3.1 <code>ShadowApplication.getInstance().getContentResolver()</code> <code>RuntimeEnvironment.application</code>.<code>getContentResolver()</code> <code>ShadowApplication.getInstance().getPackageManager()</code> <code>RuntimeEnvironment.application</code>.<code>getPackageManager()</code> <code>ShadowApplication.getInstance().getResources()</code> <code>RuntimeEnvironment.application</code>.<code>getResources()</code> <code>ShadowApplication.getInstance().getString()</code> <code>RuntimeEnvironment.application</code>.<code>getString()</code> <code>ShadowApplication.getInstance().resetResources()</code> <code>RuntimeEnvironment.application</code>.<code>resetResources()</code> <code>ShadowApplication.getInstance().getAssets()</code> <code>RuntimeEnvironment.application</code>.<code>getAssets()</code> <code>ShadowPreferenceManager.getDefaultSharedPreferences()</code> <code>PreferenceManager.getDefaultSharedPreferences()</code> <code>shadowOf(shadowOf(notification).getStyle()).getSummaryText()</code> <code>shadowOf(notification)</code>.<code>getContentText()</code> <ul> <li><code>RoboMenu</code> now requires a <code>Context</code> passed into its constructor. Previously   it was internally using   <code>RuntimeEnvironment.application</code> which you can use as a   sensible default.</li> <li><code>.equals()</code> and <code>.hashCode()</code> methods have been removed from shadows to stop them incorrectly   providing an alternative equality of the shadowed object. For example, <code>Intent.equals()</code> now   behaves as the framework method. Instead of relying on a generically shadowed <code>equals()</code> method   with a vague equality rule, prefer to make assertions on specific fields of interest to the test.   We recommend using <code>square/assertj-android</code> to make assertions clear.</li> <li>Custom shadows now require the <code>public</code> access modifier on methods in the shadow class.</li> </ul>"},{"location":"upgrade_to_version_3/#311-changes","title":"3.1.1 Changes","text":"<ul> <li><code>RoboAttributeSet</code> is deprecated and uses should be replaced with   <code>Robolectric.buildAttributeSet()</code>.</li> <li><code>RobolectricGradleTestRunner</code> is deprecated and uses should be replaced with   <code>RobolectricTestRunner</code>.</li> </ul>"},{"location":"upgrade_to_version_3/#migrating-to-30","title":"Migrating to 3.0","text":""},{"location":"upgrade_to_version_3/#new-features","title":"New Features","text":"<ul> <li>Support for API 19 (KitKat)</li> <li>Support for API 21 (Lollipop)</li> <li>Custom test runner for Gradle / Android Studio:</li> </ul> JavaKotlin <pre><code>@RunWith(RobolectricGradleTestRunner.class)\n@Config(constants = BuildConfig.class)\n</code></pre> <pre><code>@RunWith(RobolectricGradleTestRunner::class)\n@Config(constants = BuildConfig::class)\n</code></pre>"},{"location":"upgrade_to_version_3/#major-changes","title":"Major Changes","text":"2.4 3.0 <code>Robolectric.application</code> <code>RuntimeEnvironment.application</code> <code>Robolectric.shadowOf</code> <code>Shadows.shadowOf</code> <code>Robolectric.Reflection.setFinalStaticField</code> <code>ReflectionHelpers.setStaticField</code> <code>org.robolectric.Robolectric.&lt;xxx&gt;Looper</code> <code>org.robolectric.shadows.ShadowLooper.&lt;xxx&gt;Looper</code> <code>org.robolectric.Robolectric.getBackgroundScheduler</code> <code>org.robolectric.Robolectric.getBackgroundThreadScheduler</code> <code>org.robolectric.Robolectric.runBackgroundTasks</code> <code>org.robolectric.Robolectric.getBackgroundThreadScheduler().advanceBy(0)</code> (also <code>org.robolectric.Robolectric.flushBackgroundThreadScheduler</code> will run delayed background tasks too) <code>org.robolectric.Robolectric.getUiThreadScheduler</code> <code>org.robolectric.Robolectric.getForegroundThreadScheduler</code> <code>org.robolectric.Robolectric.runUiThreadTasks</code> <code>org.robolectric.shadows.ShadowLooper.runUiThreadTasks</code> <code>org.robolectric.Robolectric.runUiThreadTasksIncludingDelayedTasks</code> <code>org.robolectric.shadows.ShadowLooper.runUiThreadTasksIncludingDelayedTasks</code> or <code>org.robolectric.Robolectric.flushForegroundThreadScheduler</code> <code>org.robolectric.Robolectric.getShadowApplication</code> <code>org.robolectric.shadows.ShadowApplication.getInstance</code> <code>FragmentTestUtil.startFragment</code>(v4/v11) <code>SupportFragmentTestUtil.startFragment</code> (v4) / <code>FragmentTestUtil.startFragment</code> (v11) <code>org.robolectric.tester.android.view.TestMenuItem</code> <code>org.robolectric.fakes.RoboMenuItem</code> <code>ActivityController.of</code> <code>Robolectric.buildActivity</code> <code>org.robolectric.Config.properties</code> <code>robolectric.properties</code> <code>@Config(emulateSdk=...)</code> / <code>@Config(reportSdk=...)</code> <code>@Config(sdk=...)</code> <code>org.robolectric.shadows.ShadowHandler</code> <code>org.robolectric.shadows.ShadowLooper</code> <code>org.robolectric.shadows.ShadowSettings.SettingsImpl</code> <code>org.robolectric.shadows.ShadowSettings.ShadowSystem</code> <code>Robolectric.packageManager = instance</code> <code>RuntimeEnvironment.setRobolectricPackageManager(instance)</code> <code>org.robolectric.res.builder.RobolectricPackageManager</code> changed from <code>class</code> to <code>interface</code> <code>org.robolectric.res.builder.DefaultPackageManager</code> <code>org.robolectric.shadows.ShadowMenuInflater</code> ? <code>org.robolectric.Robolectric.clickOn</code> <code>org.robolectric.shadows.ShadowView.clickOn</code> <ul> <li><code>Robolectric.shadowOf_</code> has been removed. Similar functionality exists in   <code>ShadowExtractor.extract</code>.</li> </ul>"},{"location":"upgrade_to_version_3/#modules","title":"Modules","text":"<p>Note</p> <p>Shadows for non-core Android classes have moved out of the main Robolectric module. If you want to use those shadows, you'll need to include the requisite module.</p>"},{"location":"upgrade_to_version_3/#orgrobolectricrobolectric","title":"<code>org.robolectric:robolectric</code>","text":"<p>Main \"core\" module for Robolectric 3.0.</p> GroovyKotlin <pre><code>testCompile 'org.robolectric:robolectric:3.0'\n</code></pre> <pre><code>testCompile(\"org.robolectric:robolectric:3.0\")\n</code></pre> <p>Some of the shadows in Robolectric have been split out into separate modules to reduce the number of transitive dependencies imposed on projects using Robolectric. If you want to use any of these shadows, add the needed artifacts below to your build.</p>"},{"location":"upgrade_to_version_3/#orgrobolectricshadows-support-v4","title":"<code>org.robolectric:shadows-support-v4</code>","text":"<p>Shadows for classes in the Android <code>support-v4</code> library.</p> GroovyKotlin <pre><code>testCompile 'org.robolectric:shadows-support-v4:3.0'\n</code></pre> <pre><code>testCompile(\"org.robolectric:shadows-support-v4:3.0\")\n</code></pre>"},{"location":"upgrade_to_version_3/#orgrobolectricshadows-httpclient","title":"<code>org.robolectric:shadows-httpclient</code>","text":"<p>Shadows for classes in Apache HTTP client. This includes methods like <code>Robolectric.getLatestSentHttpRequest</code>. These methods have moved to <code>FakeHttp.getLatestSentHttpRequest</code>.</p> GroovyKotlin <pre><code>testCompile 'org.robolectric:shadows-httpclient:3.0'\n</code></pre> <pre><code>testCompile(\"org.robolectric:shadows-httpclient:3.0\")\n</code></pre>"},{"location":"upgrade_to_version_3/#orgrobolectricshadows-maps","title":"<code>org.robolectric:shadows-maps</code>","text":"<p>Shadows for classes in Google Maps.</p> GroovyKotlin <pre><code>testCompile 'org.robolectric:shadows-maps:3.0'\n</code></pre> <pre><code>testCompile(\"org.robolectric:shadows-maps:3.0\")\n</code></pre>"},{"location":"upgrade_to_version_4/","title":"Upgrade to Robolectric 4.x","text":""},{"location":"upgrade_to_version_4/#migrating-to-416","title":"Migrating to 4.16","text":""},{"location":"upgrade_to_version_4/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Drop support for API 21 and 22. Robolectric now supports API 23 (M) up to 36 (Baklava).</li> </ul>"},{"location":"upgrade_to_version_4/#deprecations","title":"Deprecations","text":"Deprecated symbol Replacement <code>TextLayoutMode</code> <code>TextLayoutMode.Mode.REALISTIC</code> is the default, and usages of these APIs can be removed. <code>TextLayoutModeConfigurer</code> <code>TextLayoutMode.Mode.REALISTIC</code> is the default, and usages of these APIs can be removed."},{"location":"upgrade_to_version_4/#removals","title":"Removals","text":"Removed symbol Replacement <code>org.robolectric:shadows-playservices</code> Use APIs provided by Google Play Services libraries <code>FakeHttp#addPendingHttpResponseWithContentType(int, String, Header)</code> <code>FakeHttp.getFakeHttpLayer().addPendingHttpResponse(statusCode, responseBody, contentType)</code> <code>ShadowDefaultRequestDirector#getSentHttpRequest(int)</code> <code>FakeHttp.getFakeHttpLayer().getSentHttpRequestInfo(index).getHttpRequest()</code> <code>ShadowDefaultRequestDirector#getSentHttpRequestInfo(int)</code> <code>FakeHttp.getFakeHttpLayer().getSentHttpRequestInfo(index)</code>"},{"location":"upgrade_to_version_4/#migrating-to-415","title":"Migrating to 4.15","text":""},{"location":"upgrade_to_version_4/#deprecations_1","title":"Deprecations","text":"Deprecated symbol Replacement <code>org.robolectric:shadows-playservices</code> Use APIs provided by Google Play Services libraries <code>ActivityController#configurationChange(Configuration, DisplayMetrics, int)</code> <code>ActivityController#configurationChange(Configuration, DisplayMetrics)</code> <code>AttributeSetBuilder</code> <code>Xml#asAttributeSet()</code> <code>Config.Builder#setAssetDir()</code> See build system integration <code>Config.Builder#setLibraries()</code> See build system integration <code>Config.Builder#setPackageName()</code> See build system integration <code>Config.Builder#setResourceDir()</code> See build system integration <code>Robolectric#buildAttributeSet()</code> <code>Robolectric#getAttributeSetFromXml()</code> <code>Robolectric#flushBackgroundThreadScheduler()</code> <code>ShadowLooper#runToEndOfTasks()</code> <code>Robolectric#flushForegroundThreadScheduler()</code> <code>ShadowLooper#runToEndOfTasks()</code> <code>Robolectric#getBackgroundThreadScheduler()</code> This is only needed in the <code>LEGACY</code> looper mode. We strongly encourage you to use the <code>PAUSED</code> looper mode (which is the default) <code>Robolectric#getForegroundThreadScheduler()</code> This is only needed in the <code>LEGACY</code> looper mode. We strongly encourage you to use the <code>PAUSED</code> looper mode (which is the default) <code>RuntimeEnvironment#getMasterScheduler()</code> This is only needed in the <code>LEGACY</code> looper mode. We strongly encourage you to use the <code>PAUSED</code> looper mode (which is the default) <code>RuntimeEnvironment#setMasterScheduler()</code> This is only needed in the <code>LEGACY</code> looper mode. We strongly encourage you to use the <code>PAUSED</code> looper mode (which is the default) <code>ShadowApplication#runBackgroundTasks()</code> This is only needed in the <code>LEGACY</code> looper mode. We strongly encourage you to use the <code>PAUSED</code> looper mode (which is the default) <code>ShadowAssetInputStream#isNinePatch()</code> Only use this in <code>LEGACY</code> graphics mode <code>ShadowRoleManager#addHeldRole()</code> <code>ShadowRoleManager#addRoleHolder()</code> <code>ShadowRoleManager#addAvailableRole()</code> <code>ShadowRoleManager#addRoleHolder()</code> <code>ShadowRoleManager#removeAvailableRole()</code> <code>ShadowRoleManager#removeRoleHolder()</code> <code>ShadowRoleManager#removeHeldRole()</code> <code>ShadowRoleManager#removeRoleHolder()</code>"},{"location":"upgrade_to_version_4/#removals_1","title":"Removals","text":"Removed symbol Replacement <code>org.robolectric:shadows-multidex</code> No longer needed with min SDK being 21+ <code>AndroidManifest#supportsBinaryResourcesMode()</code> N/A (it always returned <code>true</code>) <code>AndroidManifest#supportsLegacyResourcesMode()</code> N/A (it always returned <code>false</code>) <code>ConfigMerger</code> <code>Provider&lt;Config&gt;</code> <code>DependencyResolver#getLocalArtifactUrls()</code> N/A (overriding <code>getLocalArtifactUrl()</code> is enough) <code>Fs#fileFromPath(path)</code> <code>Fs.fromUrl(path)</code> <code>Fs#newFile(file)</code> <code>file.toPath()</code> <code>FsFile</code> <code>Path</code> <code>FsFile#getPath()</code> <code>Fs.externalize(path)</code> <code>FsFile#join(name)</code> <code>path.resolve(name)</code> <code>InvokeDynamicClassInstrumentor</code> <code>ClassInstrumentor</code> <code>IShadow#directlyOn(T, Class&lt;T&gt;)</code> Use a combination of <code>Reflector</code> and <code>Direct</code> <code>MavenManifestFactory</code> See build system integration <code>PackageItemData#getClassName()</code> <code>PackageItemData#getName()</code> <code>ProxyMaker</code> Use a combination of <code>Reflector</code> and <code>Direct</code> <code>Qualifiers#addScreenWidth()</code> <code>Configuration#screenWidthDp</code> <code>Qualifiers#addSmallestScreenWidth()</code> <code>Configuration#smallestScreenWidthDp</code> <code>Qualifiers#getOrientation()</code> <code>Configuration#orientation</code> <code>Qualifiers#getPlatformVersion()</code> <code>Build.VERSION#SDK_INT</code> <code>Qualifiers#getScreenWidth()</code> <code>Configuration#screenWidthDp</code> <code>Qualifiers#getSmallestScreenWidth()</code> <code>Configuration#smallestScreenWidthDp</code> <code>RoboSettings</code> Read/write the <code>robolectric.scheduling.global</code> system property <code>Scheduler#idleConstantly()</code> <code>Scheduler#setIdleState()</code> <code>SdkPicker</code> <code>DefaultSdkPicker</code> <code>Shadow#directlyOn(T, Class&lt;T&gt;)</code> Use a combination of <code>Reflector</code> and <code>Direct</code> <code>ShadowApplication#addWakeLock()</code> Use the <code>PowerManager</code> APIs <code>ShadowApplication#clearWakeLocks()</code> <code>ShadowPowerManager#clearWakeLocks()</code> <code>ShadowApplication#getAppWidgetManager()</code> <code>Context#getSystemService(Context.APPWIDGET_SERVICE)</code> <code>ShadowApplication#getBluetoothAdapter()</code> <code>BluetoothAdapter#getDefaultAdapter()</code> <code>ShadowApplication#getForegroundThreadScheduler()</code> Use the <code>PAUSED</code> looper mode (which is the default) <code>ShadowApplication#getInstance()</code> <code>ApplicationProvider#getApplicationContext()</code> <code>ShadowApplication#getLatestWakeLock()</code> <code>ShadowPowerManager#getLatestWakeLock()</code> <code>ShadowApplication#getSingleton()</code> N/A <code>ShadowAssetInputStream#getDelegate()</code> N/A <code>ShadowImpl#directlyOn(T, Class&lt;T&gt;)</code> Use a combination of <code>Reflector</code> and <code>Direct</code> <code>ShadowMap#convertToShadowName()</code> N/A"},{"location":"upgrade_to_version_4/#other-changes","title":"Other Changes","text":"<ul> <li><code>TestLifecycle</code> no longer has a generic type.</li> <li>Renamed <code>ActivityData#isClearTaskOnLaungh()</code> into <code>ActivityData#isClearTaskOnLaunch()</code>.</li> <li>Renamed <code>ResourceIds#makeIdentifer()</code> into <code>ResourceIds#makeIdentifier()</code>.</li> </ul>"},{"location":"upgrade_to_version_4/#migrating-to-414","title":"Migrating to 4.14","text":""},{"location":"upgrade_to_version_4/#deprecations_2","title":"Deprecations","text":"Deprecated symbol Replacement <code>org.robolectric:shadows-multidex</code> No longer needed with min SDK being 21+ <code>Implements#looseSignatures()</code> Use either <code>@ClassName</code> or <code>@Implementation(methodName)</code> <code>Supercedes</code> <code>Supersedes</code>"},{"location":"upgrade_to_version_4/#removals_2","title":"Removals","text":"Removed symbol Replacement <code>FragmentTestUtil</code> See Test your fragments"},{"location":"upgrade_to_version_4/#migrating-to-413","title":"Migrating to 4.13","text":""},{"location":"upgrade_to_version_4/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>This release bumps the min SDK version from 19 to 21, following the move made by the AndroidX   ecosystem.</li> </ul>"},{"location":"upgrade_to_version_4/#deprecations_3","title":"Deprecations","text":"Deprecated symbol Replacement <code>Scheduler</code> Use <code>LooperMode.Mode.PAUSED</code> and <code>ShadowLooper</code>'s APIs"},{"location":"upgrade_to_version_4/#removals_3","title":"Removals","text":"Removed symbol Replacement <code>Qualifiers#addPlatformVersion()</code> N/A <code>RuntimeEnvironment#useLegacyResources()</code> N/A (it always returned <code>false</code>)"},{"location":"upgrade_to_version_4/#migrating-to-412","title":"Migrating to 4.12","text":""},{"location":"upgrade_to_version_4/#deprecations_4","title":"Deprecations","text":"Deprecated symbol Replacement <code>RoboSettings#isUseGlobalScheduler()</code> <code>LooperMode.Mode.PAUSED</code> <code>RoboSettings#setUseGlobalScheduler()</code> <code>LooperMode.Mode.PAUSED</code>"},{"location":"upgrade_to_version_4/#removals_4","title":"Removals","text":"Removed symbol Replacement <code>RobolectricTestRunner#getConfig()</code> <code>Provider&lt;Config&gt;</code> <code>RuntimeEnvironment#setUseLegacyResources()</code> N/A"},{"location":"upgrade_to_version_4/#migrating-to-411","title":"Migrating to 4.11","text":""},{"location":"upgrade_to_version_4/#breaking-changes_2","title":"Breaking Changes","text":"<ul> <li>This release bumps the min SDK version from 16 to 19, following the move made by the AndroidX   ecosystem.</li> </ul>"},{"location":"upgrade_to_version_4/#deprecations_5","title":"Deprecations","text":"Deprecated symbol Replacement <code>BackgroundTestRule</code> <code>LooperMode.Mode.INSTRUMENTATION_TEST</code>"},{"location":"upgrade_to_version_4/#migrating-to-410","title":"Migrating to 4.10","text":""},{"location":"upgrade_to_version_4/#removals_5","title":"Removals","text":"Removed symbol Replacement <code>Util#intArrayToList()</code> N/A"},{"location":"upgrade_to_version_4/#migrating-to-49","title":"Migrating to 4.9","text":""},{"location":"upgrade_to_version_4/#deprecations_6","title":"Deprecations","text":"Deprecated symbol Replacement <code>Util#intArrayToList()</code> N/A"},{"location":"upgrade_to_version_4/#removals_6","title":"Removals","text":"Removed symbol Replacement <code>org.robolectric:shadows-supportv4</code> See Test your fragments"},{"location":"upgrade_to_version_4/#migrating-to-40","title":"Migrating to 4.0","text":""},{"location":"upgrade_to_version_4/#project-configuration","title":"Project Configuration","text":"<p>Robolectric 4.0 requires Android Gradle Plugin 3.2 or greater.</p> <p>Update the configuration in your module's <code>build.gradle</code>/<code>build.gradle.kts</code> file:</p> GroovyKotlin <pre><code>android {\n  compileSdkVersion 28 // Or newer\n  testOptions.unitTests.includeAndroidResources = true\n}\n</code></pre> <pre><code>android {\n  compileSdkVersion = 28 // Or newer\n  testOptions.unitTests.isIncludeAndroidResources = true\n}\n</code></pre> <p>Add the following in your <code>gradle.properties</code> file:</p> <pre><code>android.enableUnitTestBinaryResources=true\n</code></pre> <p>If you have dependencies on <code>com.android.support.test</code>, switch them to <code>androidx.test</code>; see Migrate to AndroidX.</p>"},{"location":"upgrade_to_version_4/#deprecations_7","title":"Deprecations","text":"3.8 4.0 <code>ShadowApplication.getInstance()</code> <code>RuntimeEnvironment.application</code> <code>ShadowApplication.getLatestAlertDialog()</code> <code>ShadowAlertDialog.getLatestAlertDialog()</code> <code>ShadowApplication.getLatestDialog()</code> <code>ShadowDialog.getLatestDialog()</code> <code>ShadowApplication.getLatestPopupMenu()</code> <code>ShadowPopupMenu.getLatestPopupMenu()</code> <code>ShadowLooper.getShadowMainLooper()</code> <code>shadowOf(Looper.getMainLooper())</code> <p>The automatic migration tool includes a migration to help with this.</p> <p>The following attributes of the <code>@Config</code> annotation are no longer supported when using binary resources mode:</p> <ul> <li><code>assetDir</code> and <code>resourceDir</code>: follow   the recommended file structure of your build system.</li> <li><code>manifest</code>: Robolectric always uses the merged manifest generated by   the Android toolchain. If your test was using a custom manifest you'll need to adapt it to not   rely on that.</li> <li><code>packageName</code>: to change your package name, override the   <code>applicationId</code> in your build system.</li> </ul>"},{"location":"upgrade_to_version_4/#improper-use-of-shadows","title":"Improper Use of Shadows","text":"<p>Prior to Robolectric 4.0, it was possible (but ill-advised) to get the shadow for an Android framework object and invoke framework methods there. This could result in unexpected behavior (e.g., code in overridden methods in subclasses wouldn't be called). Shadow implementation methods are now marked <code>protected</code> to guard against this. Always invoke framework methods directly on the Android class.</p> 3.8 4.0 <code>shadowOf(activity).finish();</code> <code>activity.finish()</code> <code>ShadowSystemClock.currentTimeMillis();</code> <code>System.currentTimeMillis()</code> <p>The automatic migration tool will fix most of these for you.</p>"},{"location":"upgrade_to_version_4/#androidxtest","title":"<code>androidx.test</code>","text":"<p>Robolectric 4.0 includes initial support for <code>androidx.test</code> APIs. We strongly recommend adding the latest version of <code>androidx.test:core</code> as a test dependency and using those APIs whenever possible rather than using Robolectric-specific APIs.</p> 3.8 4.0 <code>RuntimeEnvironment.application</code> <code>ApplicationProvider.getApplicationContext()</code> <code>ShadowMotionEvent</code> <code>MotionEventBuilder</code>"},{"location":"upgrade_to_version_4/#troubleshooting","title":"Troubleshooting","text":"<p>Robolectric 4.0 replaces its old home-grown resource handling code with a direct adaptation of Android's resource handling code, using the full Android toolchain. This greatly improves fidelity to the behavior of a real Android device, but if your tests were relying on the quirks of the old code, you may need to fix your tests.</p> <p>Some likely issues include:</p> <p>android.view.InflateException: Binary XML file line #3: Failed to resolve attribute at index 17: TypedValue{t=0x2/d=0x7f01000e a=-1}</p> <p>This happens when your <code>Activity</code> is using a theme that lacks values for certain attributes used by layouts. Make sure you've specified an appropriate theme for your activities in your <code>AndroidManifest</code>.</p>"},{"location":"using-add-on-modules/","title":"Using add-on modules","text":"<p>In order to reduce the number of external dependencies on the application being tested, Robolectric's shadows are split into various add-on packages. Only shadows for classes provided in the base Android SDK are provided by the main Robolectric module. Additional shadows are provided in dedicated packages.</p> <p>Note</p> <ul> <li>Robolectric 3.4 doesn't include the <code>shadows-</code> prefix in the package     name (i.e., <code>org.robolectric:playservices</code> and <code>org.robolectric:httpclient</code>).</li> <li>Before Robolectric 3.4, <code>org.robolectric:playservices</code> was named <code>shadow-play-services</code>.</li> </ul>"},{"location":"using-add-on-modules/#deprecated-packages","title":"Deprecated packages","text":"SDK package Robolectric add-on package Javadoc Comment <code>org.apache.httpcomponents:httpclient</code> <code>org.robolectric:shadows-httpclient</code> Javadoc These shadows are only provided for legacy compatibility."},{"location":"using-add-on-modules/#removed-packages","title":"Removed packages","text":"SDK package Robolectric add-on package Comment <code>androidx.multidex.MultiDex</code> <code>org.robolectric:shadows-multidex</code> Deprecated in Robolectric 4.14Removed in Robolectric 4.15 <code>com.android.support.multidex</code> <code>org.robolectric:shadows-multidex</code> Deprecated in Robolectric 4.14Removed in Robolectric 4.15 <code>com.android.support.support-v4</code> <code>org.robolectric:shadows-supportv4</code> Deprecated in Robolectric 4.8Removed in Robolectric 4.9 <code>com.google.android.gms:play-services</code> <code>org.robolectric:shadows-playservices</code> Deprecated in Robolectric 4.15Removed in Robolectric 4.16"},{"location":"using-qualifiers/","title":"Using qualified resources","text":"<p>As described in the Android developer docs, resource qualifiers allow you to change how your resources are loaded based on such factors as the language on the device, to the screen size, to whether it is day or night. While these changes are often tedious to test rigorously (every string has a translation for all supported languages), you may find yourself wishing to run tests in different resource qualified contexts.</p>"},{"location":"using-qualifiers/#specifying-resources-in-test","title":"Specifying resources in test","text":"<p>Specifying a resource qualifier is quite simple: simply add the desired qualifiers to the <code>@Config</code> annotation on your test case or test class, depending on whether you would like to change the resource qualifiers for the whole file, or simply one test.</p> <p>Given the following resources:</p> <code>values/strings.xml</code><code>values-en/strings.xml</code><code>values-en-port/strings.xml</code> <pre><code>&lt;string name=\"not_overridden\"&gt;Not overridden&lt;/string&gt;\n&lt;string name=\"overridden\"&gt;Overridden&lt;/string&gt;\n&lt;string name=\"overridden_twice\"&gt;Overridden twice&lt;/string&gt;\n</code></pre> <pre><code>&lt;string name=\"overridden\"&gt;Overridden in en&lt;/string&gt;\n&lt;string name=\"overridden_twice\"&gt;Overridden twice in en&lt;/string&gt;\n</code></pre> <pre><code>&lt;string name=\"overridden_twice\"&gt;Overridden twice in en-port&lt;/string&gt;\n</code></pre> <p>this Robolectric test would pass, using the Android resource qualifier resolution rules:</p> JavaKotlin <pre><code>@Test\n@Config(qualifiers = \"en-port\")\npublic void shouldUseEnglishAndPortraitResources() {\n  final Context context = RuntimeEnvironment.application;\n  assertThat(context.getString(R.id.not_overridden)).isEqualTo(\"Not overridden\");\n  assertThat(context.getString(R.id.overridden)).isEqualTo(\"Overridden in en\");\n  assertThat(context.getString(R.id.overridden_twice)).isEqualTo(\"Overridden twice in en-port\");\n}\n</code></pre> <pre><code>@Test\n@Config(qualifiers = \"en-port\")\nfun shouldUseEnglishAndPortraitResources() {\n    val context = RuntimeEnvironment.application\n    assertThat(context.getString(R.id.not_overridden)).isEqualTo(\"Not overridden\")\n    assertThat(context.getString(R.id.overridden)).isEqualTo(\"Overridden in en\")\n    assertThat(context.getString(R.id.overridden_twice)).isEqualTo(\"Overridden twice in en-port\")\n}\n</code></pre> <p>Multiple qualifiers should be separated by dashes and provided in the order put forth in this list.</p>"},{"location":"writing-a-test/","title":"Writing Your First Test","text":"<p>Let's say that you have an <code>Activity</code> that represents a welcome screen:</p> JavaKotlin <pre><code>public class WelcomeActivity extends Activity {\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.welcome_activity);\n\n        final Button button = findViewById(R.id.login);\n        button.setOnClickListener((view) -&gt; {\n            startActivity(new Intent(WelcomeActivity.this, LoginActivity.class))\n        });\n    }\n}\n</code></pre> <pre><code>class WelcomeActivity : Activity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.welcome_activity)\n\n        val button = findViewById&lt;Button&gt;(R.id.login)\n        button.setOnClickListener {\n            startActivity(Intent(this, LoginActivity::class.java))\n        }\n    }\n}\n</code></pre> welcome_activity.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n\n    &lt;Button\n        android:id=\"@+id/login\"\n        android:text=\"Login\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"/&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>We want to write a test that asserts that when the user clicks on the \"Login\" button, the app launches the <code>LoginActivity</code>.</p> <p>To achieve this, we can check that the correct <code>Intent</code> is started when the click is performed. Since Robolectric is a unit testing framework, the <code>LoginActivity</code> will not actually be started.</p> JavaKotlin <pre><code>@RunWith(RobolectricTestRunner.class)\npublic class WelcomeActivityTest {\n    @Test\n    public void clickingLogin_shouldStartLoginActivity() {\n        try (ActivityController&lt;WelcomeActivity&gt; controller = Robolectric.buildActivity(WelcomeActivity.class)) {\n            controller.setup(); // Moves the Activity to the RESUMED state\n\n            WelcomeActivity activity = controller.get();\n            activity.findViewById&lt;Button&gt;(R.id.login).performClick();\n\n            Intent expectedIntent = new Intent(activity, LoginActivity.class);\n            Intent actual = shadowOf(RuntimeEnvironment.application).getNextStartedActivity();\n            assertEquals(expectedIntent.getComponent(), actual.getComponent());\n        }\n    }\n}\n</code></pre> <pre><code>@RunWith(RobolectricTestRunner::class)\nclass WelcomeActivityTest {\n    @Test\n    fun clickingLogin_shouldStartLoginActivity() {\n        Robolectric.buildActivity(WelcomeActivity::class.java).use { controller -&gt;\n            controller.setup() // Moves the Activity to the RESUMED state\n\n            val activity = controller.get()\n            activity.findViewById&lt;Button&gt;(R.id.login).performClick()\n\n            val expectedIntent = Intent(activity, LoginActivity::class.java)\n            val actual = shadowOf(RuntimeEnvironment.application).nextStartedActivity\n            assertEquals(expectedIntent.component, actual.component)\n        }\n    }\n}\n</code></pre>"},{"location":"writing-a-test/#test-apis","title":"Test APIs","text":"<p>Robolectric extends the Android framework with a large set of test APIs, which offer extra configurability and access to the internal state and history of Android components that are useful for tests.</p> <p>Many test APIs are extensions to individual Android classes, and can be accessed using the <code>shadowOf()</code> method:</p> JavaKotlin <pre><code>// Retrieve all the toasts that have been displayed\nList&lt;Toast&gt; toasts = shadowOf(application).getShownToasts();\n</code></pre> <pre><code>// Retrieve all the toasts that have been displayed\nval toasts = shadowOf(application).shownToasts\n</code></pre> <p>Additional test APIs are accessible as static methods on special classes called shadows, which correspond to Android framework classes:</p> JavaKotlin <pre><code>// Simulate a new display being plugged into the device\nShadowDisplayManager.addDisplay(\"xlarge-port\");\n</code></pre> <pre><code>// Simulate a new display being plugged into the device\nShadowDisplayManager.addDisplay(\"xlarge-port\")\n</code></pre>"},{"location":"blog/","title":"Robolectric Blog","text":""},{"location":"blog/2017/03/01/hermetic-builds/","title":"Hermetic Builds with Robolectric","text":"<p>Robolectric needs access to multiple Android SDK jars in order to perform its magic, which means it needs special configuration beyond just setting up dependencies in your build. By default, it tries to download Android SDK jars from Maven Central.</p> <p>But what if you have a hermetic build environment? You just need to do a little more configuration.</p> <p>Here's a Gradle build script that'll help:</p> <pre><code>def robolectricVersion = '3.3'\n\ndef androidSdkVersions = [\n        '4.1.2_r1-robolectric-0',\n        '4.2.2_r1.2-robolectric-0',\n        '4.3_r2-robolectric-0',\n        '4.4_r1-robolectric-1',\n        '5.0.0_r2-robolectric-1',\n        '5.1.1_r9-robolectric-1',\n        '6.0.0_r1-robolectric-0',\n        '6.0.1_r3-robolectric-0',\n        '7.0.0_r1-robolectric-0',\n        '7.1.0_r7-robolectric-0',\n]\n\ndef shadowArtifacts = [\n        \"org.robolectric:shadows-core:${robolectricVersion}\",\n        \"org.robolectric:shadows-httpclient:${robolectricVersion}\",\n        \"org.robolectric:shadows-maps:${robolectricVersion}\",\n        \"org.robolectric:shadows-multidex:${robolectricVersion}\",\n        \"org.robolectric:shadows-play-services:${robolectricVersion}\",\n        \"org.robolectric:shadows-support-v4:${robolectricVersion}\",\n]\n\napply plugin: 'java'\n\nrepositories {\n    mavenLocal()\n    jcenter()\n}\n\nconfigurations {\n    sandbox\n}\n\ndef allSdkConfigurations = []\n\nandroidSdkVersions.forEach { version -&gt;\n    allSdkConfigurations &lt;&lt; configurations.create(version)\n    dependencies.add(version, \"org.robolectric:android-all:${version}\")\n    dependencies.add('sandbox', \"org.robolectric:android-all:${version}\")\n}\n\n\n// In this section you declare the dependencies for your production and test code\ndependencies {\n    compile(\"org.robolectric:robolectric:${robolectricVersion}\") {\n        // we don't need these MavenDependencyResolver in a hermetic build\n        exclude group: 'org.apache.maven', module: 'maven-ant-tasks'\n        exclude group: 'org.apache.ant', module: 'ant'\n    }\n\n    shadowArtifacts.forEach { shadowArtifact -&gt;\n        compile shadowArtifact\n        sandbox shadowArtifact\n    }\n}\n\n\ntask createRobolectricDeps {\n}\n\ntask copyLibs(type: Copy) {\n    into \"$buildDir/output/libs\"\n    from configurations.compile\n\n    doLast {\n        def f = new File(\"$buildDir/output/README.txt\")\n        f.delete()\n\n        f &lt;&lt; \"# Include the following jar files on your classpath:\\n\"\n        f &lt;&lt; \"#\\n\"\n\n        source.forEach { file -&gt;\n            f &lt;&lt; \"libs/${file.name}\\n\"\n        }\n    }\n}\n\ntask copySdks(type: Copy) {\n    into \"$buildDir/output/libs\"\n    from allSdkConfigurations\n\n    doLast {\n        def f = new File(\"$buildDir/output/robolectric-deps.properties\")\n        f.delete()\n\n        f &lt;&lt; \"# Place this file in your test resources dir (e.g. src/test/resources).\\n\"\n        f &lt;&lt; \"# Paths below should be absolute, or relative to this file.\\n\"\n        f &lt;&lt; \"#\\n\"\n\n        allSdkConfigurations.forEach { config -&gt;\n            config.allDependencies.forEach { dep -&gt;\n                def files = new ArrayList(config.files)\n                if (files.size != 1) {\n                    throw new RuntimeException(\"huh, more than one file in ${dep}? ${files}\")\n                }\n                def file = files[0]\n                f &lt;&lt; \"${dep.group}\\\\:${dep.name}\\\\:${dep.version}=path/to/${file.name}\\n\"\n            }\n        }\n    }\n}\n\ntask filesForHermeticBuild {\n    dependsOn createRobolectricDeps\n    dependsOn copyLibs\n    dependsOn copySdks\n}\n</code></pre> <ol> <li>Create an empty Gradle project (either <code>gradle init</code> or use Android Studio or IntelliJ).</li> <li>Paste the script into your <code>build.gradle</code>.</li> <li>Change the first line (<code>robolectricVersion</code>) to the version of Robolectric you want.</li> <li>Change the list of <code>shadowArtifacts</code> or <code>androidSdkVersions</code> if you like.</li> <li>Run the <code>filesForHermeticBuild</code> task: <code>./gradlew filesForHermeticBuild</code></li> </ol> <p>Gradle will download all the dependencies you need to run Robolectric and place them in <code>build/output/libs</code>. Place the <code>.jar</code> files in your project's libs directory.</p> <p>Add the <code>.jar</code> files listed in <code>build/output/README.txt</code> as compile-time dependencies.</p> <p>Place the file called <code>build/output/robolectric-deps.properties</code> in your test <code>resources</code> directory. Change the paths as indicated in the comment in that file.</p> <p>You're all set! Robolectric will now load Android SDKs from the filesystem instead of attempting to download them from Maven Central.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/","title":"Robolectric 3.3 and Roadmap","text":"<p>Your Robolectric maintainers are pleased to announce the release of Robolectric 3.3! There's been a bunch of activity recently in Robolectric, and we wanted to give a quick update on our thinking about where the project is going.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#introduction","title":"Introduction","text":"<p>Robolectric started life in 2010 as a quick hack to allow Android tests to be run on a regular JVM rather than a device or emulator, allowing for fast TDD cycles. It was mostly developed in brief spurts as needed for testing specific projects.</p> <p>Since then, it's been cool to see Robolectric grow with the help of the community, and become quite widely used. It's become a critical part of the test infrastructure of lots of companies and projects. It's rather outgrown the scrappy side-project Robolectric was for much of its life and needs some full-time attention.</p> <p>Here's a high-level view of what we see as the steps ahead toward making Robolectric a trusted, well-supported and dependable Android test framework. In the coming months we\u2019ll be working on:</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#android-fidelity-and-trustworthiness","title":"Android Fidelity and Trustworthiness","text":"<p>Long ago, Robolectric lurked mostly in the shadows: there was no real Android code behind the scenes, only the bits we implemented (which we called Shadows). From 2.0 on, we've had real Android implementations available to use, but lots of old shadow implementations lingered and gave peculiar behavior, plus some bits remained unimplemented or were implemented with behavior that doesn't match that of a device. All this has left Robolectric's trustworthiness in doubt. We're working to match Android's behavior as closely as possible in the spots where we can, and to provide predictable behavior in those places where it's necessary to diverge.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#api-stability","title":"API Stability","text":"<p>We've had a bit of API thrash and regressions in the past, and we're going to work diligently to ease the pain of staying current with robolectric releases. We'll be deprecating APIs before their removal and providing guidance on migration. We do expect a few more large and high-benefit API changes in the coming major releases, but we'll do our best to minimize their impact. We'll be careful to document changes in release notes.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#documentation","title":"Documentation","text":"<p>Robolectric\u2019s documentation has always been sparse. We're aiming for clear and comprehensive documentation that reveals how the various parts of the Android SDK are simulated by Robolectric, and details extended APIs for testing.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#performance","title":"Performance","text":"<p>Robolectric was created to make TDD super fast, so it's disappointing to us too that performance has dipped. We're going to set up a perf suite and spend some time in a profiler and try to squeeze every second out of test startup and run time.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#toolchain-integration","title":"Toolchain Integration","text":"<p>We're working on easier project integration for several build systems, tighter integration with Android Studio, and easier and more flexible configuration in general.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#android-sdk-support","title":"Android SDK Support","text":"<p>As new SDKs and new features are released, we'll make sure Robolectric supports them quickly.</p>"},{"location":"blog/2017/03/02/robolectric-3-3-and-roadmap/#community","title":"Community","text":"<p>We're going to do our best to stay on top of bug reports and pull requests. We'll be continuing to develop in the open on GitHub, and we'd love your input on changes and designs.</p> <p>As always, thanks for your pull requests, bug reports, ideas and questions!</p>"},{"location":"blog/2017/11/13/resources-for-real/","title":"Keepin' It Real With Resources","text":"<p>Up until now, Robolectric has relied on rough approximations of the Android framework's resource handling logic, backwards-engineered to be 'good enough' for many testing purposes.</p> <p>We've gotten to the point where 'good enough' is no longer good enough. We've completely reimplemented Robolectric's resources system, transliterating the real native Android resource handling code from the original C++ to Java, and in the coming several releases we'll be rolling it out. The new code will fix numerous bugs in the old Robolectric simulation, which we expect will expose places where your tests rely on incorrect Robolectric behavior.</p> <p>We're doing this in three separate releases to give you a chance to fix your tests in smaller batches. We strongly recommend you apply each upgrade individually and watch the release notes for migration hints.</p> <p>The releases will be:</p> <ul> <li>3.6: Resource selection based on transliterated framework code. Configuration properties set   from <code>@Config(qualifiers)</code>.</li> <li>3.7: Manifest parsing based on transliterated framework code.</li> <li>3.8: Resource loading from <code>aapt</code>-processed binary resource files.</li> </ul> <p>We'll keep the changes in each release focused and narrow, and provide lots of notes on migration. Stick with us through this, we think you'll be happy with the improvements.</p> <p>Going forward, we're applying a higher standard for accuracy in Robolectric's implementations of native code. We'll keep you posted as we revamp more parts of Robolectric's framework simulation.</p> <p>As always, thanks for your pull requests, bug reports, ideas and questions! \ud83d\udcaf</p>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/","title":"Robolectric 4.0 Alpha &amp; Jetpack","text":"<p>The Robolectric team is super excited to announce the first alpha release of Robolectric 4.0, as well as some new developments in the world of Robolectric and Android testing in general.</p>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/#androidxtest","title":"<code>androidx.test</code>","text":"<p>We\u2019re collaborating closely with the Android Jetpack testing team to develop common APIs for writing Android tests that can run as both local (JVM-based) and on-device (instrumentation) tests. From 4.0 on, Robolectric will support Jetpack\u2019s <code>androidx.test</code> APIs, starting with support for the <code>AndroidJUnit4</code> test runner, <code>ActivityTestRule</code>, and Espresso for interacting with UI components.</p>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/#a-robolectric-3x-style-test","title":"A Robolectric 3.x style test","text":"<pre><code>@RunWith(RobolectricTestRunner::class)\nclass RobolectricTest {\n  @Test fun clickingOnTitle_shouldLaunchEditAction() {\n    val activity = Robolectric.setupActivity(NoteListActivity::class.java)\n    ShadowView.clickOn(activity.findViewById(R.id.title))\n    assertThat(ShadowApplication.getInstance().peekNextStartedActivity().action)\n            .isEqualTo(\"android.intent.action.EDIT\")\n  }\n}\n</code></pre>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/#robolectric-4xinstrumentation-test","title":"Robolectric 4.x/instrumentation test","text":"<pre><code>@RunWith(AndroidJUnit4::class)\nclass OnDeviceTest {\n  @get:Rule val rule = ActivityTestRule(NoteListActivity::class.java)\n\n  @Test fun clickingOnTitle_shouldLaunchEditAction() {\n    onView(withId(R.id.button)).perform(click())\n    intended(hasAction(equalTo(\"android.intent.action.EDIT\")))\n  }\n}\n</code></pre> <p>As you can see, many of the idioms common in instrumentation tests are now supported by Robolectric tests. In the near future we'll be expanding <code>androidx.test</code> support on Robolectric, as well as introducing some Robolectric-originated testing paradigms to traditional instrumentation tests.</p>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/#binary-resources","title":"Binary Resources","text":"<p>In conjunction with Android Studio 3.2, Robolectric can now use resources processed using the Android build toolchain, and loads and handles those resources using the same logic as on an actual Android device. Robolectric's old idiosyncratic resource handling mode is still available for projects not yet using the latest version of the build toolchain.</p> <p>To enable the use of toolchain-processed resources in Robolectric tests, make sure you're using Android Gradle Plugin version <code>com.android.tools.build:gradle:3.2.0-alpha14</code> or higher, and add the following to your <code>gradle.properties</code>:</p> <pre><code>android.enableUnitTestBinaryResources=true\n</code></pre>"},{"location":"blog/2018/05/09/robolectric-4-0-alpha/#release-notes","title":"Release Notes","text":"<p>Release notes are available here. Robolectric 4.0 is currently in alpha release, meaning that it is not yet feature-complete, and APIs are likely to change before the final release. Use with caution.</p> <p>As always, thanks for your pull requests, bug reports, ideas and questions! \ud83d\udcaf</p>"},{"location":"blog/2018/10/25/robolectric-4-0/","title":"Robolectric 4.0 Released!","text":"<p>Robolectric 4.0 is released! Here's what's new!</p>"},{"location":"blog/2018/10/25/robolectric-4-0/#androidxtest","title":"<code>androidx.test</code>","text":"<p>The different idioms for testing using Robolectric and instrumentation tests have long been a headache. With today's release of Robolectric 4.0 and <code>androidx.test</code> 1.0.0, both testing environments are converging on a set of common test APIs. Robolectric now supports the <code>AndroidJUnit4</code> test runner, <code>ActivityTestRule</code>, and Espresso for interacting with UI components.</p>"},{"location":"blog/2018/10/25/robolectric-4-0/#a-robolectric-3x-style-test","title":"A Robolectric 3.x style test","text":"<pre><code>@RunWith(RobolectricTestRunner::class)\nclass RobolectricTest {\n  @Test fun clickingOnTitle_shouldLaunchEditAction() {\n    val activity = Robolectric.setupActivity(NoteListActivity::class.java)\n    ShadowView.clickOn(activity.findViewById(R.id.title))\n    assertThat(ShadowApplication.getInstance().peekNextStartedActivity().action)\n            .isEqualTo(\"android.intent.action.EDIT\")\n  }\n}\n</code></pre>"},{"location":"blog/2018/10/25/robolectric-4-0/#robolectric-4xinstrumentation-test","title":"Robolectric 4.x/instrumentation test","text":"<pre><code>@RunWith(AndroidJUnit4::class)\nclass OnDeviceTest {\n  @get:Rule val rule = ActivityTestRule(NoteListActivity::class.java)\n\n  @Test fun clickingOnTitle_shouldLaunchEditAction() {\n    onView(withId(R.id.button)).perform(click())\n    intended(hasAction(equalTo(\"android.intent.action.EDIT\")))\n  }\n}\n</code></pre> <p>As you can see, many of the idioms common in instrumentation tests are now supported by Robolectric tests. In future releases we'll be expanding <code>androidx.test</code> support on Robolectric, as well as introducing some Robolectric-originated testing paradigms to traditional instrumentation tests.</p>"},{"location":"blog/2018/10/25/robolectric-4-0/#binary-resources","title":"Binary Resources","text":"<p>In conjunction with Android Studio 3.2, Robolectric can now use resources processed using the Android build toolchain, and loads and handles those resources using the same logic as on an actual Android device. Robolectric's old idiosyncratic resource handling mode is still available for projects not yet using the latest version of the build toolchain, but is now deprecated and will be removed in a future release.</p> <p>To enable the use of toolchain-processed resources in Robolectric tests, make sure you're using Android Gradle Plugin version <code>com.android.tools.build:gradle:3.2.1</code> or higher, and add the following to your <code>gradle.properties</code>:</p> <pre><code>android {\n  testOptions {\n    unitTests {\n      includeAndroidResources = true\n    }\n  }\n}\n\ndependencies {\n  testImplementation 'org.robolectric:robolectric:4.16'\n}\n</code></pre> <p>Add this line to your <code>gradle.properties</code> (no longer necessary with Android Studio 3.3+):</p> <pre><code>android.enableUnitTestBinaryResources=true\n</code></pre>"},{"location":"blog/2018/10/25/robolectric-4-0/#migration-tool","title":"Migration Tool","text":"<p>Robolectric 4.0 contains a number of API changes that may require modifications to your test code. Check out the migration notes and use the new automated migration tool to help convert your existing tests to be compatible with Robolectric 4.0.</p>"},{"location":"blog/2018/10/25/robolectric-4-0/#release-notes","title":"Release Notes","text":"<p>Release notes are available here.</p> <p>As always, thanks for your pull requests, bug reports, ideas and questions! \ud83d\udcaf</p>"},{"location":"blog/2019/06/04/paused-looper/","title":"Improving Robolectric's Looper simulation","text":"<p>TL;DR: We'd love your feedback on improvements we've made to make Robolectric's <code>Looper</code> behavior more realistic. Try it out today by annotating your tests with <code>@LooperMode(PAUSED)</code> and let us know your experience!</p>"},{"location":"blog/2019/06/04/paused-looper/#background","title":"Background","text":"<p>Unlike on a real device, Robolectric shares a single thread for both UI operations and Test code. By default, Robolectric will execute tasks posted to <code>Looper</code>s synchronously inline. This causes Robolectric to execute tasks earlier than they would be on a real device. While in many cases this has no observable effect, it can lead to bugs that are hard to track down.</p> <p>Consider the code below. When run on the UI thread on a device, the assertion would pass.</p> <pre><code>List&lt;String&gt; events = new ArrayList&lt;&gt;();\nevents.add(\"before\");\nnew Handler(Looper.getMainLooper()).post(() -&gt; events.add(\"after\"));\nevents.add(\"between\");\n\nassertThat(events).containsExactly(\"before\", \"between\", \"after\").inOrder();\n</code></pre> <p>Robolectric\u2019s default behavior is to process posted code synchronously and immediately, so the assertion fails with <code>[before, after, between]</code>, which is clearly incorrect.</p> <p>Robolectric\u2019s current implementation is notoriously prone to deadlocks, infinite loops and other race conditions. Robolectric will duplicate each task posted to a <code>Looper</code> into a separate list stored in <code>Scheduler</code>. The <code>Looper</code>\u2019s set of tasks and the <code>Scheduler</code>s can get out of sync, causing hard-to-diagnose errors.</p>"},{"location":"blog/2019/06/04/paused-looper/#solution","title":"Solution","text":"<p>We\u2019ve re-written Robolectric\u2019s threading model and <code>Looper</code> simulation in a way that we hope will address the deficiencies of the current behavior. It\u2019s available to try out now by applying a <code>@LooperMode(PAUSED)</code> annotation to your test classes or methods. Some of the highlights of the <code>PAUSED</code> mode vs. the existing <code>LEGACY</code> mode include:</p> <ul> <li>Tasks posted to the main <code>Looper</code> are not automatically executed inline. Similar to the   legacy <code>PAUSED</code> <code>IdleState</code>, tasks posted to the main <code>Looper</code> must be   explicitly executed via <code>ShadowLooper</code> APIs. However, we\u2019ve made a couple   additional improvements in <code>PAUSED</code> mode that make this easier:</li> <li>Robolectric will warn users if a test fails with unexecuted tasks in the main <code>Looper</code> queue.   This is a hint that the unexecuted behavior is important for the test case.</li> <li>AndroidX Test APIs, like <code>ActivityScenario</code>,   <code>FragmentScenario</code> and Espresso will automatically idle the main   <code>Looper</code>.</li> <li>Tasks posted to background <code>Looper</code>s are executed in real threads. This will hopefully   eliminate the need for hacks when trying to test code that asserts that it is running in a   background thread.</li> </ul>"},{"location":"blog/2019/06/04/paused-looper/#using-paused-loopermode","title":"Using <code>PAUSED</code> <code>LooperMode</code>","text":"<p>To switch to <code>PAUSED</code>:</p> <ul> <li> <p>Use Robolectric 4.3. In Gradle, add:</p> <pre><code>dependencies {\n  testImplementation 'org.robolectric:robolectric:4.3'\n}\n</code></pre> </li> <li> <p>Apply the <code>@LooperMode(PAUSED)</code> annotation to your test package/class/method.</p> </li> <li>Convert any background <code>Scheduler</code> calls for controlling <code>Looper</code>s to   <code>shadowOf(looper)</code>.</li> <li>Recommended, but not mandatory: Convert any foreground <code>Scheduler</code> calls to <code>shadowOf(getMainLooper())</code>. The <code>Scheduler</code> APIs will be deprecated and removed over time.</li> <li>Convert any <code>RoboExecutorService</code> usages to   <code>PausedExecutorService</code> or   <code>InlineExecutorService</code>.</li> <li>Run your tests. If you see test failures like <code>Main looper has queued unexecuted runnables</code>, you may need to insert <code>shadowOf(getMainLooper()).idle()</code> calls to your test to drain the main <code>Looper</code>. It's recommended to step through your test code with a watch set on <code>Looper.getMainLooper().getQueue()</code> to see the status of the <code>Looper</code> queue, to determine the appropriate point to add a <code>shadowOf(getMainLooper()).idle()</code> call.</li> </ul> <p>Example:</p> <pre><code>import static android.os.Looper.getMainLooper;\nimport static org.robolectric.annotation.LooperMode.Mode.PAUSED;\nimport static org.robolectric.Shadows.shadowOf;\n\nimport org.robolectric.annotation.LooperMode;\n\n@RunWith(AndroidJUnit4.class)\n@LooperMode(PAUSED)\npublic class MyTest {\n  @Test\n  public void testCodeThatPosts() {\n    List&lt;String&gt; events = new ArrayList&lt;&gt;();\n    events.add(\"before\");\n    new Handler(Looper.getMainLooper()).post(() -&gt; events.add(\"after\"));\n    events.add(\"between\");\n\n    // the 'after' task is posted, but has not been executed yet\n    assertThat(events).containsExactly(\"before\", \"between\").inOrder();\n    // execute all tasks posted to main Looper \n    shadowOf(getMainLooper()).idle();\n\n    assertThat(events).containsExactly(\"before\", \"between\", \"after\").inOrder();\n  }\n}\n</code></pre> <p>Take a look at Robolectric\u2019s <code>ShadowPausedAsyncTaskTest</code> for an example of using <code>PAUSED</code> <code>LooperMode</code> and background tasks.</p>"},{"location":"blog/2019/06/04/paused-looper/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Animations: Use of Animations can cause delayed tasks to be posted to the main <code>Looper</code> queue. You   can use the <code>ShadowLooper.idleFor()</code> or   <code>ShadowLooper.runToEndOfTasks()</code> APIs to execute these tasks.</li> </ul>"},{"location":"blog/2019/06/04/paused-looper/#feedback","title":"Feedback","text":"<p>Please let us know of any roadblocks to adopting <code>PAUSED</code> <code>LooperMode</code>. We\u2019d like to make it the default mode for tests in the next release, and thus your feedback would be most welcome.</p>"},{"location":"blog/2021/09/13/a-memorial-tribute-for-jonathan-gerrish/","title":"A memorial tribute for Jonathan Gerrish","text":"<p>In late August, 2021, we were incredibly saddened to learn of the tragic passing of Jonathan Gerrish and his family while they were hiking near Mariposa, CA. Jonathan was a long-time Robolectric maintainer and active contributor since 2014. He saw incredible potential in Robolectric and championed it within Google, elevating it to an officially supported testing tool that grew to be used by tens of thousands of Android developers.</p> <p>The breadth of the contributions that Jonathan made to the project are too wide to list in this post. He was involved in many high-profile projects such as revamping <code>PackageManager</code> support and binary resources. He also worked extensively to get first-class support for Robolectric in Gradle and Bazel. Jonathan was passionate about continually improving the fidelity of Robolectric to the point where write-once, run-everywhere was possible. This allowed the same test to either be run in Robolectric or any physical or virtual Android device.</p> <p>More importantly, Jonathan had a great spirit and was beloved by friends and family. He was friendly, easy-going, and respectful. He settled near Mariposa, CA to be closer to nature and to enjoy the open space and fresh air.</p> <p>We miss you dearly, Jon. You will always be remembered by the Robolectric community.</p>"},{"location":"blog/2021/10/06/sharedTest/","title":"<code>sharedTest</code> pattern: sharing tests and speeding up development","text":"<p>After Robolectric's 4.0 release, Robolectric supports the <code>AndroidJUnit4</code> test runner, <code>ActivityScenario</code>, and Espresso for interacting with UI components. As we know, we also can run those tests with an official emulator. This article will show an often overlooked but widely-used pattern called <code>sharedTest</code> to share tests between local and instrumentation tests. This will provide the benefit of fast unit testing while ensuring that tests are high-fidelity by enabling them to be run in an emulator.</p>"},{"location":"blog/2021/10/06/sharedTest/#using-sharedtest-steps-by-steps","title":"Using sharedTest steps by steps","text":"<p>The first thing that <code>sharedTest</code> needs is <code>AndroidJUnit4</code> test runner. It is a test runner that supports both Robolectric and <code>androidx.test</code>. There is a sample class, called <code>SampleFragmentTest.kt</code> from FragmentScenarioSample that uses <code>AndroidJUnit4</code> test runner:</p> <pre><code>import androidx.fragment.app.testing.launchFragmentInContainer\nimport androidx.test.espresso.Espresso.onView\nimport androidx.test.espresso.assertion.ViewAssertions.matches\nimport androidx.test.espresso.matcher.ViewMatchers.withId\nimport androidx.test.espresso.matcher.ViewMatchers.withText\nimport androidx.test.ext.junit.runners.AndroidJUnit4\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\nimport org.robolectric.annotation.LooperMode\n\n/**\n * A test using the androidx.test unified API, which can execute on an Android device or locally using Robolectric.\n *\n * See [testing documentation](https://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass SampleFragmentTest {\n    @Test\n    fun launchFragmentAndVerifyUI() {\n        // use launchInContainer to launch the fragment with UI\n        launchFragmentInContainer&lt;SampleFragment&gt;()\n\n        // now use espresso to look for the fragment's text view and verify it is displayed\n        onView(withId(R.id.textView)).check(matches(withText(\"I am a fragment\")));\n    }\n}\n</code></pre> <p>The second thing to enable <code>sharedTest</code> is to create a directory called <code>sharedTest</code>, at the same directory level with <code>test</code> and <code>androidTest</code>. Android Studio doesn't support it, so we should create it manually. <code>FragmentScenarioSample</code>'s <code>sharedTest</code> directory is a good example for it.</p> <p>The next step we should do is to add <code>sharedTest</code> directory to <code>test</code>'s and <code>androidTest</code>'s source directory. <code>FragmentScenarioSample</code>'s <code>build.gradle</code> is also a good example for it:</p> <pre><code>// share the unified tests\nsourceSets {\n    test {\n        java.srcDir 'src/sharedTest/java'\n    }\n    androidTest {\n        java.srcDir 'src/sharedTest/java'\n    }\n}\n</code></pre> <p>If you want to share resources too, you can check Robolectric's PR: Add ctesque common tests to android test that used to reuse tests to improve CI fidelity with <code>sharedTest</code> pattern:</p> <pre><code>sourceSets {\n    String sharedTestDir = 'src/sharedTest/'\n    String sharedTestSourceDir = sharedTestDir + 'java'\n    String sharedTestResourceDir = sharedTestDir + 'resources'\n    test.resources.srcDirs += sharedTestResourceDir\n    test.java.srcDirs += sharedTestSourceDir\n    androidTest.resources.srcDirs += sharedTestResourceDir\n    androidTest.java.srcDirs += sharedTestSourceDir\n}\n</code></pre> <p>The last thing is to test it with <code>./gradlew test</code> for local tests on Robolectric and <code>./gradlew connectedCheck</code> for instrumentation tests on Emulator.</p>"},{"location":"blog/2021/10/06/sharedTest/#why-androidjunit4-test-runner","title":"Why <code>AndroidJUnit4</code> test runner?","text":"<p>There is an aspirational long-term goal for Android tests, write once, run everywhere tests on Android. The <code>AndroidJUnit4</code> test runner is selected as the bridge for different devices that used to run tests. We can check <code>AndroidJUnit4#getRunnerClassName()</code>, and we can find how <code>AndroidJUnit4</code> to delegate tests to real test runner based on running environment:</p> <pre><code>private static String getRunnerClassName() {\n  String runnerClassName = System.getProperty(\"android.junit.runner\", null);\n  if (runnerClassName == null) {\n    if (!System.getProperty(\"java.runtime.name\").toLowerCase().contains(\"android\")\n        &amp;&amp; hasClass(\"org.robolectric.RobolectricTestRunner\")) {\n      return \"org.robolectric.RobolectricTestRunner\";\n    } else {\n      return \"androidx.test.internal.runner.junit4.AndroidJUnit4ClassRunner\";\n    }\n  }\n  return runnerClassName;\n}\n</code></pre> <p>If it finds current running environment has <code>RobolectricTestRunner</code>, it will delegate tests to Robolectric's <code>RobolectricTestRunner</code>; otherwise to <code>androidx.test</code>'s <code>AndroidJUnit4ClassRunner</code>.</p>"},{"location":"blog/2021/10/06/sharedTest/#not-only-sharing-code-but-also-speeding-up-development","title":"Not only sharing code, but also speeding up development","text":"<p>With <code>sharedTest</code> pattern, we can share test code as much as possible. Is it the only benefit to encourage you to use <code>sharedTest</code> pattern? Not yet. Actually, Robolectric is a simulated Android environment inside a JVM. It has better speed to establish and destroy tests environment, and developers can get test results more quickly. It can help developers to speed up TDD cycles:</p> <p></p>"},{"location":"blog/2021/10/06/sharedTest/#references","title":"References","text":"<p>There are some articles have shown <code>sharedTest</code> pattern, and they should be mentioned here:</p> <ul> <li>Sharing code between local and instrumentation tests by Alex Zhukovich</li> <li>Powerful Approaches to Develop Shared Android Tests by Oleksandr Hrybuk</li> <li>Sharing code between unit tests and instrumentation tests on Android by Dan Lew</li> </ul> <p>There is an awesome book has introduced <code>sharedTest</code> pattern too:</p> <ul> <li>Android Test-Driven Development by Tutorials, by Fernando Sproviero, Victoria Gonda and Lance Gleason, Razeware LLC (July 20, 2021)</li> </ul> <p>There are some Google's projects have used <code>sharedTest</code> pattern to sharing test code:</p> <ul> <li>accompanist: [All] Share tests to run on Robolectric &amp; Emulators by chrisbanes</li> </ul>"},{"location":"blog/2022/09/06/Umesh-GSoC-on-ConscryptMode/","title":"GSoC 2022 - ConscryptMode","text":"<p>My name is Umesh Singh, and I was an open source contributor through Google Summer of Code this year. Google Summer of Code (GSoC) is a program where external participants can contribute to an open source project over a few months. We learn new computer science concepts, how to work on open source repositories, and create real code contributions to projects!</p> <p>My project was <code>Switching Robolectric from BouncyCastle to Conscrypt as the default security provider</code>. Robolectric was using BouncyCastle as the Java Cryptography Extension (JCE) security provider. After the introduction of Android P, Android switched to using Google Conscrypt as the security provider. To be more consistent with Android, Robolectric needed to be updated to use Conscrypt as the default security provider.</p> <p>When I encountered Robolectric in the GSoC organization list, I know it would be a great fit. I had prior experience with Android development and was looking for growth opportunities in this area. Robolectric also offered a lot of learning opportunities in Java, security, and unit testing concepts.</p> <p>The initial approach for this project was to drop BouncyCastle entirely and switch to Conscrypt. This seemed appealing due to the prior issues with BouncyCastle, such as #5456. However, we discovered that we couldn't completely switch Robolectric to Conscrypt. Conscrypt only supports the security primitives provided by BoringSSL, and there were some legacy security primitives that were still being used in Android. Because of this, we realized that BouncyCastle was needed as the fallback security provider. We settled on having a <code>@ConscryptMode</code> annotation that lets users choose whether Conscrypt will be installed or not. When Conscrypt is enabled, Robolectric will search for a requested security feature from Conscrypt first. If it does not support it, the other security providers will be queried. This is more consistent with how Android does it.</p> <ul> <li>If <code>ConscryptMode.Mode</code> is <code>ON</code>, it will install   Conscrypt and BouncyCastle.</li> <li>If <code>ConscryptMode.Mode</code> is <code>OFF</code>, it will only   install BouncyCastle.</li> </ul> <p>I have learned a lot about unit testing, such as how to test whether a piece of code is working according to the expected behavior, and about writing tests for specific scenarios. I have also learned about providing self-explanatory names to methods so that other developers can understand them easily in the future.</p> <p>I gained experience debugging a large, complex codebase like Robolectric, and how to find the root cause of errors and test case failures. I learned about defining new Java runtime annotations. These get compiled into the bytecode and can later be inspected in other parts of the project.</p> <p>I have also learned about the tradeoffs that sometimes arise in software projects. For example, Conscrypt does not currently support Mac M1, and to some extent this is out of our control. We were aware of this issue yet decided to move forward with making Conscrypt the default security provider on Linux, Windows, and Mac x86_64. The increased fidelity for these environments outweighs the lack of M1 support. We also have opportunities to collaborate with Conscrypt for Mac M1 support, or explore alternatives like repackaging Conscrypt for Robolectric until Conscrypt supports M1.</p> <p>You can see my changes here in this pull request and here is a short documentation about it.</p>"},{"location":"blog/2023/11/11/improving-android-all-downloading/","title":"Improving android-all Downloading on CI","text":"<p>In recent years, the team has received multiple issues regarding Robolectric's inability to download/resolve the necessary android-all jars when running Robolectric tests in a CI environment. Some examples include:</p> <ol> <li>android-all not downloaded as part of robolectric, or is it a separate dependency?</li> <li>Robolectric failing because not downloading dependencies in Jenkins when using Artifactory</li> <li>Flaky SHA mismatch on CI builds when retrieving Maven artifacts since upgrading to 4.10.x</li> </ol> <p>Robolectric downloads the necessary android-all jars using its MavenArtifactFetcher when running Robolectric tests. It does not use any proxies defined by the Gradle build system. In a CI environment, especially in environments used by large companies internally, there are often network restrictions that can cause the aforementioned issues. This article provides some solutions to mitigate these issues as much as possible, including setting a custom proxy for <code>MavenArtifactFetcher</code>, leveraging Robolectric's offline mode, and manually fetching the necessary android-all jars before running Robolectric tests.</p>"},{"location":"blog/2023/11/11/improving-android-all-downloading/#setting-custom-proxy-for-mavenartifactfetcher","title":"Setting custom proxy for <code>MavenArtifactFetcher</code>","text":"<p>The first solution is setting a custom proxy for <code>MavenArtifactFetcher</code> like the following snippet:</p> <pre><code>testOptions {\n    unitTests {\n        includeAndroidResources = true\n        returnDefaultValues = true\n        isIncludeUnitTestDependencies = true\n        all {\n            it.systemProperty(\"robolectric.dependency.repo.url\", \"https://local-mirror/repo\")\n            it.systemProperty(\"robolectric.dependency.repo.id\", \"local\")\n            // Username and password only needed when local repository\n            // needs account information.\n            it.systemProperty(\"robolectric.dependency.repo.username\", \"username\")\n            it.systemProperty(\"robolectric.dependency.repo.password\", \"password\")\n            // Since Robolectric 4.9.1, these are available\n            it.systemProperty(\"robolectric.dependency.proxy.host\", System.getenv(\"ROBOLECTRIC_PROXY_HOST\"))\n            it.systemProperty(\"robolectric.dependency.proxy.port\", System.getenv(\"ROBOLECTRIC_PROXY_PORT\"))\n        }\n    }\n}\n</code></pre> <p>The <code>MavenArtifactFetcher</code> supports the above system properties to leverage a custom Maven repository link, although it needs a username and password. It also supports a custom proxy host and port for internally allowed proxy servers.</p> <p><code>robolectric.dependency.repo.url</code> and <code>robolectric.dependency.repo.id</code> are enough for most scenarios. For example, I often set the repository to a custom Chinese popular Maven mirror for my custom projects:</p> <pre><code>testOptions {\n    unitTests {\n        includeAndroidResources = true\n        returnDefaultValues = true\n        isIncludeUnitTestDependencies = true\n        all {\n            it.systemProperty(\"robolectric.dependency.repo.url\", \"https://maven.aliyun.com/repository\")\n            it.systemProperty(\"robolectric.dependency.repo.id\", \"public\")\n        }\n    }\n}\n</code></pre> <p>Robolectric's configuration documentation contains a detailed description of these special Robolectric properties, and you can read it for more details.</p>"},{"location":"blog/2023/11/11/improving-android-all-downloading/#leveraging-robolectrics-offline-mode","title":"Leveraging Robolectric's offline mode","text":"<p>Robolectric supports using android-all jars in a local directory with its offline mode without downloading any android-all jars from the network when running Robolectric tests. We can follow the following snippet to enable Robolectric's offline mode for the project:</p> <pre><code>testOptions {\n    unitTests {\n        includeAndroidResources = true\n        returnDefaultValues = true\n        isIncludeUnitTestDependencies = true\n        all {\n            it.systemProperty(\"robolectric.offline\", \"true\")\n            it.systemProperty(\n                \"robolectric.dependency.dir\",\n                \"${rootDir}/robolectric-jars/preinstrumented\"\n            )\n        }\n    }\n}\n</code></pre> <p>To make it work, we need to download android-all jars into the <code>${rootDir}/robolectric-jars/preinstrumented</code> directory before running any Robolectric tests. I created a sample project to provide build scripts to download these android-all jars into this preinstrumented directory: robolectric-offline-sample.</p> <pre><code>plugins {\n    `java-library`\n}\n\nval versions = listOf(\n    \"14-robolectric-10818077-i4\",\n    \"13-robolectric-9030017-i4\",\n    \"12.1-robolectric-8229987-i4\",\n    \"12-robolectric-7732740-i4\",\n    \"11-robolectric-6757853-i4\",\n    \"10-robolectric-5803371-i4\",\n    \"9-robolectric-4913185-2-i4\",\n    \"8.1.0-robolectric-4611349-i4\",\n    \"8.0.0_r4-robolectric-r1-i4\",\n    \"7.1.0_r7-robolectric-r1-i4\",\n    \"7.0.0_r1-robolectric-r1-i4\",\n    \"6.0.1_r3-robolectric-r1-i4\",\n    \"5.1.1_r9-robolectric-r2-i4\",\n    \"5.0.2_r3-robolectric-r0-i4\",\n    \"4.4_r1-robolectric-r2-i4\"\n)\n\nval downloadTasks = versions.map { version -&gt;\n    val configurationName = \"robolectric$version\".replace(\".\", \"_\").replace(\"-\", \"_\")\n    val customConfiguration = configurations.create(configurationName) {\n        extendsFrom(configurations.implementation.get())\n        isCanBeResolved = true\n        isCanBeConsumed = false\n    }\n\n    dependencies {\n        add(configurationName, \"org.robolectric:android-all-instrumented:$version\")\n    }\n\n    val jarFileDirectory = customConfiguration.resolve().map { it.parentFile.absolutePath }\n    val allFilesInDirectory = jarFileDirectory.flatMap { fileTree(it).files }\n\n    val downloadTask = tasks.register&lt;Copy&gt;(\"downloadRobolectricJars$version\") {\n        from(allFilesInDirectory)\n        into(\"preinstrumented\")\n    }\n\n    downloadTask\n}\n\n\nval deleteTask = tasks.register&lt;Delete&gt;(\"deleteRobolectricJars\") { delete(\"preinstrumented\") }\n\ntasks.register(\"downloadAllRobolectricJars\") {\n    dependsOn(deleteTask)\n    dependsOn(downloadTasks)\n}\n</code></pre> <p>The above <code>build.gradle.kts</code> is just a sample to download necessary android-all jars manually before running Robolectric tests. It's easy to maintain. Because Robolectric might add a new android-all jar for a new Android version or modify internal logic to update an existing android-all jar's version, these android-all jars might change across different Robolectric versions. If you store them in a Git repository, your Git repository might become bigger and bigger. If you like this approach, you can store android-all jars in an external repository like AndroidX.</p> <p>Robolectric's configuring documentation contains a detailed description of these special Robolectric properties, and you can read it for details.</p>"},{"location":"blog/2023/11/11/improving-android-all-downloading/#fetching-android-all-jars-manually-before-running-robolectric-tests","title":"Fetching android-all jars manually before running Robolectric tests","text":"<p>If you don't store android-all jars in your Git repository to leverage offline mode, and you don't want to modify your system properties for Robolectric in your <code>build.gradle.kts</code>, you can try to download android-all jars in a script and download them manually before running any Gradle tasks.</p> <p>For example, I created a project to do it for myself: robolectric-android-all-fetcher. You can change the Maven mirror to any one you like and run the script to download all android-all jars for a specific Robolectric version.</p>"},{"location":"blog/2023/11/11/improving-android-all-downloading/#conclusion","title":"Conclusion","text":"<p>Most of these issues are caused by a network issue when downloading necessary android-all jars, and we can fix them or ease them by making android-all jars accessible before running Robolectric tests and letting <code>MavenArtifactFetcher</code> use them directly. The above potential solutions are some stable and recommended solutions for developers to try. Hope it can help you.</p>"},{"location":"blog/2024/02/25/robolectric-2024-gsoc/","title":"Robolectric in Google Summer of Code 2024","text":"<p>We have some exciting news to share - Robolectric has been accepted as a host organization for the Google Summer of Code (GSOC) 2024! This will provide an opportunity for students interested in Android development to contribute to one of the most widely used testing frameworks for Android.</p>"},{"location":"blog/2024/02/25/robolectric-2024-gsoc/#what-is-robolectric","title":"What is Robolectric?","text":"<p>For those new to Robolectric, it's a powerful testing framework that allows Android tests to be executed on the JVM instead of an emulator or a real device. This makes Android tests that run on Robolectric much faster and more reliable.</p> <p>Robolectric is used by many organizations building Android applications. Robolectric has received code contributions from developers at companies such as Google, ByteDance, Meta, Block, Amazon, and many more.</p> <p>Contributions and improvements to Robolectric make a meaningful impact on the quality of Android testing, and thus improve the quality of the Android ecosystem as a whole.</p>"},{"location":"blog/2024/02/25/robolectric-2024-gsoc/#the-robolectric-gsoc-experience","title":"The Robolectric GSOC experience","text":"<p>This is the second time Robolectric has participated in GSOC (the last time being in 2022). Students who work on Robolectric will gain a deeper understanding of the Android framework, JVM internals, and testing methodologies. Students will also collaborate with the Robolectric maintainers and other members of the Robolectric community, many of whom are professional Android developers. Students participating in GSOC will also receive a stipend from Google!</p>"},{"location":"blog/2024/02/25/robolectric-2024-gsoc/#ideal-gsoc-candidates","title":"Ideal GSOC candidates","text":"<p>Ideally, students applying for Robolectric in GSOC should have a solid grasp of Java fundamentals and some background in Android application development. While none of these are absolutely required, it will make the learning curve more manageable. More importantly, we are looking for students that have demonstrated a passion for programming and open-source.</p> <p>We also ask that students interested in applying should attempt to make one small contribution to Robolectric in order to gain some familiarity with the development environment.</p> <p>Note that time zone differences will be a consideration when reviewing applications. Because of the limited number of mentors. We would prefer if each mentor and host were in a compatible time zone.</p>"},{"location":"blog/2024/02/25/robolectric-2024-gsoc/#more-information","title":"More information","text":"<p>The Robolectric profile for GSOC 2024 can be found here.</p> <p>Review the Robolectric GSOC 2024 project list for a list of project ideas.</p> <p>If you have any questions, please start a discussion here or email any of the Robolectric maintainers.</p> <p>We are very excited for the summer and hope that GSOC 2024 is an awesome experience for everyone involved!</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/archive/2022/","title":"2022","text":""},{"location":"blog/archive/2021/","title":"2021","text":""},{"location":"blog/archive/2019/","title":"2019","text":""},{"location":"blog/archive/2018/","title":"2018","text":""},{"location":"blog/archive/2017/","title":"2017","text":""},{"location":"blog/page/2/","title":"Robolectric Blog","text":""}]}